"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// ../../node_modules/.pnpm/nice-try@1.0.5/node_modules/nice-try/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/nice-try@1.0.5/node_modules/nice-try/src/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(fn) {
      try {
        return fn();
      } catch (e) {
      }
    };
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs5 = require("fs");
    function checkPathExt(path5, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path5.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path5, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path5, options);
    }
    function isexe(path5, options, cb) {
      fs5.stat(path5, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path5, options));
      });
    }
    function sync(path5, options) {
      return checkStat(fs5.statSync(path5), path5, options);
    }
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs5 = require("fs");
    function isexe(path5, options, cb) {
      fs5.stat(path5, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path5, options) {
      return checkStat(fs5.statSync(path5), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports, module2) {
    var fs5 = require("fs");
    var core2;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core2 = require_windows();
    } else {
      core2 = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path5, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path5, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core2(path5, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path5, options) {
      try {
        return core2.sync(path5, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js
var require_which = __commonJS({
  "../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js"(exports, module2) {
    module2.exports = which2;
    which2.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path5 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      er.code = "ENOENT";
      return er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON;
      var pathEnv = opt.path || process.env.PATH || "";
      var pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
        pathExt = pathExtExe.split(colon);
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
        pathEnv = [""];
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which2(cmd, opt, cb) {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      (function F(i, l) {
        if (i === l) {
          if (opt.all && found.length)
            return cb(null, found);
          else
            return cb(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path5.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
          if (ii === ll)
            return F(i + 1, l);
          var ext2 = pathExt[ii];
          isexe(p + ext2, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext2);
              else
                return cb(null, p + ext2);
            }
            return E(ii + 1, ll);
          });
        })(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      for (var i = 0, l = pathEnv.length; i < l; i++) {
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path5.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j];
          var is;
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }
  }
});

// ../../node_modules/.pnpm/path-key@2.0.1/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../../node_modules/.pnpm/path-key@2.0.1/node_modules/path-key/index.js"(exports, module2) {
    "use strict";
    module2.exports = (opts) => {
      opts = opts || {};
      const env = opts.env || process.env;
      const platform = opts.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var which2 = require_which();
    var pathKey = require_path_key()();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      if (hasCustomCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which2.sync(parsed.command, {
          path: (parsed.options.env || process.env)[pathKey],
          pathExt: withoutPathExt ? path5.delimiter : void 0
        });
      } catch (e) {
      } finally {
        process.chdir(cwd);
      }
      if (resolved) {
        resolved = path5.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// ../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/escape.js"(exports, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// ../../node_modules/.pnpm/shebang-regex@1.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../../node_modules/.pnpm/shebang-regex@1.0.0/node_modules/shebang-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = /^#!.*/;
  }
});

// ../../node_modules/.pnpm/shebang-command@1.2.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../../node_modules/.pnpm/shebang-command@1.2.0/node_modules/shebang-command/index.js"(exports, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = function(str2) {
      var match2 = str2.match(shebangRegex);
      if (!match2) {
        return null;
      }
      var arr = match2[0].replace(/#! ?/, "").split(" ");
      var bin = arr[0].split("/").pop();
      var arg = arr[1];
      return bin === "env" ? arg : bin + (arg ? " " + arg : "");
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module2) {
    "use strict";
    var fs5 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      let buffer;
      if (Buffer.alloc) {
        buffer = Buffer.alloc(size);
      } else {
        buffer = new Buffer(size);
        buffer.fill(0);
      }
      let fd;
      try {
        fd = fs5.openSync(command, "r");
        fs5.readSync(fd, buffer, 0, size, 0);
        fs5.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// ../../node_modules/.pnpm/semver@5.7.2/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/semver@5.7.2/node_modules/semver/semver.js"(exports, module2) {
    exports = module2.exports = SemVer;
    var debug6;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug6 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug6 = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "\\d+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug6(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports.parse = parse4;
    function parse4(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version2, options) {
      var v = parse4(version2, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version2, options) {
      var s = parse4(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === options.loose) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError("Invalid Version: " + version2);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version2, options);
      }
      debug6("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version2.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version2);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug6("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug6("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version2, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse4(version1);
        var v2 = parse4(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric2 = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric2.test(a);
      var bnum = numeric2.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte2;
    function gte2(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte2;
    function lte2(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte2(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte2(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug6("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug6("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      debug6("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        version2 = new SemVer(version2, this.options);
      }
      return cmp(version2, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies3(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies3(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range2 instanceof Range) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        return new Range(range2.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range2, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range3) {
        return this.parseRange(range3.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range2) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace);
      debug6("hyphen replace", range2);
      range2 = range2.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
      debug6("comparator trim", range2, safeRe[COMPARATORTRIM]);
      range2 = range2.replace(safeRe[TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(safeRe[CARETTRIM], caretTrimReplace);
      var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var set2 = range2.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set2 = set2.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set2 = set2.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set2;
    };
    Range.prototype.intersects = function(range2, options) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range2.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports.toComparators = toComparators;
    function toComparators(range2, options) {
      return new Range(range2, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug6("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug6("caret", comp);
      comp = replaceTildes(comp, options);
      debug6("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug6("xrange", comp);
      comp = replaceStars(comp, options);
      debug6("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug6("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug6("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug6("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug6("caret", comp, options);
      var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug6("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug6("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug6("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug6("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug6("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug6("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug6("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug6("replaceStars", comp, options);
      return comp.trim().replace(safeRe[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        version2 = new SemVer(version2, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set2, version2, options) {
      for (var i2 = 0; i2 < set2.length; i2++) {
        if (!set2[i2].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set2.length; i2++) {
          debug6(set2[i2].semver);
          if (set2[i2].semver === ANY) {
            continue;
          }
          if (set2[i2].semver.prerelease.length > 0) {
            var allowed = set2[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies3;
    function satisfies3(version2, range2, options) {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range2, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range2, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range2, loose) {
      range2 = new Range(range2, loose);
      var minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range2.set.length; ++i2) {
        var comparators = range2.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range2, options) {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version2, range2, options) {
      return outside(version2, range2, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version2, range2, options) {
      return outside(version2, range2, ">", options);
    }
    exports.outside = outside;
    function outside(version2, range2, hilo, options) {
      version2 = new SemVer(version2, options);
      range2 = new Range(range2, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte2;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte2;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies3(version2, range2, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range2.set.length; ++i2) {
        var comparators = range2.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse4(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce2;
    function coerce2(version2) {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      var match2 = version2.match(safeRe[COERCE]);
      if (match2 == null) {
        return null;
      }
      return parse4(match2[1] + "." + (match2[2] || "0") + "." + (match2[3] || "0"));
    }
  }
});

// ../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/parse.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var niceTry = require_src();
    var resolveCommand = require_resolveCommand();
    var escape2 = require_escape();
    var readShebang = require_readShebang();
    var semver = require_semver();
    var isWin3 = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    var supportsShellOption = niceTry(() => semver.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin3) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path5.normalize(parsed.command);
        parsed.command = escape2.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parseShell(parsed) {
      if (supportsShellOption) {
        return parsed;
      }
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      if (isWin3) {
        parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.options.windowsVerbatimArguments = true;
      } else {
        if (typeof parsed.options.shell === "string") {
          parsed.command = parsed.options.shell;
        } else if (process.platform === "android") {
          parsed.command = "/system/bin/sh";
        } else {
          parsed.command = "/bin/sh";
        }
        parsed.args = ["-c", shellCommand];
      }
      return parsed;
    }
    function parse4(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parseShell(parsed) : parseNonShell(parsed);
    }
    module2.exports = parse4;
  }
});

// ../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/enoent.js"(exports, module2) {
    "use strict";
    var isWin3 = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin3) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin3 && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin3 && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/index.js"(exports, module2) {
    "use strict";
    var cp = require("child_process");
    var parse4 = require_parse();
    var enoent = require_enoent();
    function spawn2(command, args, options) {
      const parsed = parse4(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse4(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse4;
    module2.exports._enoent = enoent;
  }
});

// ../../node_modules/.pnpm/strip-eof@1.0.0/node_modules/strip-eof/index.js
var require_strip_eof = __commonJS({
  "../../node_modules/.pnpm/strip-eof@1.0.0/node_modules/strip-eof/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(x) {
      var lf = typeof x === "string" ? "\n" : "\n".charCodeAt();
      var cr = typeof x === "string" ? "\r" : "\r".charCodeAt();
      if (x[x.length - 1] === lf) {
        x = x.slice(0, x.length - 1);
      }
      if (x[x.length - 1] === cr) {
        x = x.slice(0, x.length - 1);
      }
      return x;
    };
  }
});

// ../../node_modules/.pnpm/npm-run-path@2.0.2/node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "../../node_modules/.pnpm/npm-run-path@2.0.2/node_modules/npm-run-path/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var pathKey = require_path_key();
    module2.exports = (opts) => {
      opts = Object.assign({
        cwd: process.cwd(),
        path: process.env[pathKey()]
      }, opts);
      let prev;
      let pth = path5.resolve(opts.cwd);
      const ret = [];
      while (prev !== pth) {
        ret.push(path5.join(pth, "node_modules/.bin"));
        prev = pth;
        pth = path5.resolve(pth, "..");
      }
      ret.push(path5.dirname(process.execPath));
      return ret.concat(opts.path).join(path5.delimiter);
    };
    module2.exports.env = (opts) => {
      opts = Object.assign({
        env: process.env
      }, opts);
      const env = Object.assign({}, opts.env);
      const path6 = pathKey({ env });
      opts.path = env[path6];
      env[path6] = module2.exports(opts);
      return env;
    };
  }
});

// ../../node_modules/.pnpm/is-stream@1.1.0/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../../node_modules/.pnpm/is-stream@1.1.0/node_modules/is-stream/index.js"(exports, module2) {
    "use strict";
    var isStream = module2.exports = function(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    };
    isStream.writable = function(stream) {
      return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    };
    isStream.readable = function(stream) {
      return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    };
    isStream.duplex = function(stream) {
      return isStream.writable(stream) && isStream.readable(stream);
    };
    isStream.transform = function(stream) {
      return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    };
  }
});

// ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS({
  "../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// ../../node_modules/.pnpm/end-of-stream@1.4.1/node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "../../node_modules/.pnpm/end-of-stream@1.4.1/node_modules/end-of-stream/index.js"(exports, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        if (readable && !(rs && rs.ended))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && ws.ended))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// ../../node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js
var require_pump = __commonJS({
  "../../node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js"(exports, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs5;
    try {
      fs5 = require("fs");
    } catch (e) {
    }
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs5)
        return false;
      return (stream instanceof (fs5.ReadStream || noop) || stream instanceof (fs5.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// ../../node_modules/.pnpm/get-stream@4.1.0/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@4.1.0/node_modules/get-stream/buffer-stream.js"(exports, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = (options) => {
      options = Object.assign({}, options);
      const { array } = options;
      let { encoding } = options;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream = new PassThrough({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream.getBufferedLength = () => len;
      return stream;
    };
  }
});

// ../../node_modules/.pnpm/get-stream@4.1.0/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@4.1.0/node_modules/get-stream/index.js"(exports, module2) {
    "use strict";
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = Object.assign({ maxBuffer: Infinity }, options);
      const { maxBuffer } = options;
      let stream;
      return new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error) {
            error.bufferedData = stream.getBufferedValue();
          }
          reject(error);
        };
        stream = pump(inputStream, bufferStream(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      }).then(() => stream.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, { encoding: "buffer" }));
    module2.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// ../../node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "../../node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js"(exports, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports, module2) {
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert2 = require("assert");
      signals = require_signals();
      isWin3 = /^win/i.test(process2.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert2.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load2();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin3 && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load2 = function load3() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load2;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert2;
    var signals;
    var isWin3;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load2;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// ../../node_modules/.pnpm/execa@1.0.0/node_modules/execa/lib/errname.js
var require_errname = __commonJS({
  "../../node_modules/.pnpm/execa@1.0.0/node_modules/execa/lib/errname.js"(exports, module2) {
    "use strict";
    var util3 = require("util");
    var uv;
    if (typeof util3.getSystemErrorName === "function") {
      module2.exports = util3.getSystemErrorName;
    } else {
      try {
        uv = process.binding("uv");
        if (typeof uv.errname !== "function") {
          throw new TypeError("uv.errname is not a function");
        }
      } catch (err) {
        console.error("execa/lib/errname: unable to establish process.binding('uv')", err);
        uv = null;
      }
      module2.exports = (code) => errname(uv, code);
    }
    module2.exports.__test__ = errname;
    function errname(uv2, code) {
      if (uv2) {
        return uv2.errname(code);
      }
      if (!(code < 0)) {
        throw new Error("err >= 0");
      }
      return `Unknown system error ${code}`;
    }
  }
});

// ../../node_modules/.pnpm/execa@1.0.0/node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "../../node_modules/.pnpm/execa@1.0.0/node_modules/execa/lib/stdio.js"(exports, module2) {
    "use strict";
    var alias = ["stdin", "stdout", "stderr"];
    var hasAlias = (opts) => alias.some((x) => Boolean(opts[x]));
    module2.exports = (opts) => {
      if (!opts) {
        return null;
      }
      if (opts.stdio && hasAlias(opts)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map((x) => `\`${x}\``).join(", ")}`);
      }
      if (typeof opts.stdio === "string") {
        return opts.stdio;
      }
      const stdio = opts.stdio || [];
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const result = [];
      const len = Math.max(stdio.length, alias.length);
      for (let i = 0; i < len; i++) {
        let value = null;
        if (stdio[i] !== void 0) {
          value = stdio[i];
        } else if (opts[alias[i]] !== void 0) {
          value = opts[alias[i]];
        }
        result[i] = value;
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/execa@1.0.0/node_modules/execa/index.js
var require_execa = __commonJS({
  "../../node_modules/.pnpm/execa@1.0.0/node_modules/execa/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var childProcess = require("child_process");
    var crossSpawn = require_cross_spawn();
    var stripEof = require_strip_eof();
    var npmRunPath = require_npm_run_path();
    var isStream = require_is_stream();
    var _getStream = require_get_stream();
    var pFinally = require_p_finally();
    var onExit = require_signal_exit();
    var errname = require_errname();
    var stdio = require_stdio();
    var TEN_MEGABYTES = 1e3 * 1e3 * 10;
    function handleArgs(cmd, args, opts) {
      let parsed;
      opts = Object.assign({
        extendEnv: true,
        env: {}
      }, opts);
      if (opts.extendEnv) {
        opts.env = Object.assign({}, process.env, opts.env);
      }
      if (opts.__winShell === true) {
        delete opts.__winShell;
        parsed = {
          command: cmd,
          args,
          options: opts,
          file: cmd,
          original: {
            cmd,
            args
          }
        };
      } else {
        parsed = crossSpawn._parse(cmd, args, opts);
      }
      opts = Object.assign({
        maxBuffer: TEN_MEGABYTES,
        buffer: true,
        stripEof: true,
        preferLocal: true,
        localDir: parsed.options.cwd || process.cwd(),
        encoding: "utf8",
        reject: true,
        cleanup: true
      }, parsed.options);
      opts.stdio = stdio(opts);
      if (opts.preferLocal) {
        opts.env = npmRunPath.env(Object.assign({}, opts, { cwd: opts.localDir }));
      }
      if (opts.detached) {
        opts.cleanup = false;
      }
      if (process.platform === "win32" && path5.basename(parsed.command) === "cmd.exe") {
        parsed.args.unshift("/q");
      }
      return {
        cmd: parsed.command,
        args: parsed.args,
        opts,
        parsed
      };
    }
    function handleInput(spawned, input) {
      if (input === null || input === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    }
    function handleOutput(opts, val) {
      if (val && opts.stripEof) {
        val = stripEof(val);
      }
      return val;
    }
    function handleShell(fn, cmd, opts) {
      let file = "/bin/sh";
      let args = ["-c", cmd];
      opts = Object.assign({}, opts);
      if (process.platform === "win32") {
        opts.__winShell = true;
        file = process.env.comspec || "cmd.exe";
        args = ["/s", "/c", `"${cmd}"`];
        opts.windowsVerbatimArguments = true;
      }
      if (opts.shell) {
        file = opts.shell;
        delete opts.shell;
      }
      return fn(file, args, opts);
    }
    function getStream(process2, stream, { encoding, buffer, maxBuffer }) {
      if (!process2[stream]) {
        return null;
      }
      let ret;
      if (!buffer) {
        ret = new Promise((resolve, reject) => {
          process2[stream].once("end", resolve).once("error", reject);
        });
      } else if (encoding) {
        ret = _getStream(process2[stream], {
          encoding,
          maxBuffer
        });
      } else {
        ret = _getStream.buffer(process2[stream], { maxBuffer });
      }
      return ret.catch((err) => {
        err.stream = stream;
        err.message = `${stream} ${err.message}`;
        throw err;
      });
    }
    function makeError(result, options) {
      const { stdout, stderr } = result;
      let err = result.error;
      const { code, signal } = result;
      const { parsed, joinedCmd } = options;
      const timedOut = options.timedOut || false;
      if (!err) {
        let output = "";
        if (Array.isArray(parsed.opts.stdio)) {
          if (parsed.opts.stdio[2] !== "inherit") {
            output += output.length > 0 ? stderr : `
${stderr}`;
          }
          if (parsed.opts.stdio[1] !== "inherit") {
            output += `
${stdout}`;
          }
        } else if (parsed.opts.stdio !== "inherit") {
          output = `
${stderr}${stdout}`;
        }
        err = new Error(`Command failed: ${joinedCmd}${output}`);
        err.code = code < 0 ? errname(code) : code;
      }
      err.stdout = stdout;
      err.stderr = stderr;
      err.failed = true;
      err.signal = signal || null;
      err.cmd = joinedCmd;
      err.timedOut = timedOut;
      return err;
    }
    function joinCmd(cmd, args) {
      let joinedCmd = cmd;
      if (Array.isArray(args) && args.length > 0) {
        joinedCmd += " " + args.join(" ");
      }
      return joinedCmd;
    }
    module2.exports = (cmd, args, opts) => {
      const parsed = handleArgs(cmd, args, opts);
      const { encoding, buffer, maxBuffer } = parsed.opts;
      const joinedCmd = joinCmd(cmd, args);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
      } catch (err) {
        return Promise.reject(err);
      }
      let removeExitHandler;
      if (parsed.opts.cleanup) {
        removeExitHandler = onExit(() => {
          spawned.kill();
        });
      }
      let timeoutId = null;
      let timedOut = false;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        if (removeExitHandler) {
          removeExitHandler();
        }
      };
      if (parsed.opts.timeout > 0) {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          timedOut = true;
          spawned.kill(parsed.opts.killSignal);
        }, parsed.opts.timeout);
      }
      const processDone = new Promise((resolve) => {
        spawned.on("exit", (code, signal) => {
          cleanup();
          resolve({ code, signal });
        });
        spawned.on("error", (err) => {
          cleanup();
          resolve({ error: err });
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (err) => {
            cleanup();
            resolve({ error: err });
          });
        }
      });
      function destroy() {
        if (spawned.stdout) {
          spawned.stdout.destroy();
        }
        if (spawned.stderr) {
          spawned.stderr.destroy();
        }
      }
      const handlePromise = () => pFinally(Promise.all([
        processDone,
        getStream(spawned, "stdout", { encoding, buffer, maxBuffer }),
        getStream(spawned, "stderr", { encoding, buffer, maxBuffer })
      ]).then((arr) => {
        const result = arr[0];
        result.stdout = arr[1];
        result.stderr = arr[2];
        if (result.error || result.code !== 0 || result.signal !== null) {
          const err = makeError(result, {
            joinedCmd,
            parsed,
            timedOut
          });
          err.killed = err.killed || spawned.killed;
          if (!parsed.opts.reject) {
            return err;
          }
          throw err;
        }
        return {
          stdout: handleOutput(parsed.opts, result.stdout),
          stderr: handleOutput(parsed.opts, result.stderr),
          code: 0,
          failed: false,
          killed: false,
          signal: null,
          cmd: joinedCmd,
          timedOut: false
        };
      }), destroy);
      crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);
      handleInput(spawned, parsed.opts.input);
      spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);
      spawned.catch = (onrejected) => handlePromise().catch(onrejected);
      return spawned;
    };
    module2.exports.stdout = (...args) => module2.exports(...args).then((x) => x.stdout);
    module2.exports.stderr = (...args) => module2.exports(...args).then((x) => x.stderr);
    module2.exports.shell = (cmd, opts) => handleShell(module2.exports, cmd, opts);
    module2.exports.sync = (cmd, args, opts) => {
      const parsed = handleArgs(cmd, args, opts);
      const joinedCmd = joinCmd(cmd, args);
      if (isStream(parsed.opts.input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
      const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
      result.code = result.status;
      if (result.error || result.status !== 0 || result.signal !== null) {
        const err = makeError(result, {
          joinedCmd,
          parsed
        });
        if (!parsed.opts.reject) {
          return err;
        }
        throw err;
      }
      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: false,
        signal: null,
        cmd: joinedCmd,
        timedOut: false
      };
    };
    module2.exports.shellSync = (cmd, opts) => handleShell(module2.exports.sync, cmd, opts);
  }
});

// ../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs5) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs5);
      }
      if (!fs5.lutimes) {
        patchLutimes(fs5);
      }
      fs5.chown = chownFix(fs5.chown);
      fs5.fchown = chownFix(fs5.fchown);
      fs5.lchown = chownFix(fs5.lchown);
      fs5.chmod = chmodFix(fs5.chmod);
      fs5.fchmod = chmodFix(fs5.fchmod);
      fs5.lchmod = chmodFix(fs5.lchmod);
      fs5.chownSync = chownFixSync(fs5.chownSync);
      fs5.fchownSync = chownFixSync(fs5.fchownSync);
      fs5.lchownSync = chownFixSync(fs5.lchownSync);
      fs5.chmodSync = chmodFixSync(fs5.chmodSync);
      fs5.fchmodSync = chmodFixSync(fs5.fchmodSync);
      fs5.lchmodSync = chmodFixSync(fs5.lchmodSync);
      fs5.stat = statFix(fs5.stat);
      fs5.fstat = statFix(fs5.fstat);
      fs5.lstat = statFix(fs5.lstat);
      fs5.statSync = statFixSync(fs5.statSync);
      fs5.fstatSync = statFixSync(fs5.fstatSync);
      fs5.lstatSync = statFixSync(fs5.lstatSync);
      if (fs5.chmod && !fs5.lchmod) {
        fs5.lchmod = function(path5, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchmodSync = function() {
        };
      }
      if (fs5.chown && !fs5.lchown) {
        fs5.lchown = function(path5, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs5.rename = typeof fs5.rename !== "function" ? fs5.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs5.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs5.rename);
      }
      fs5.read = typeof fs5.read !== "function" ? fs5.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs5.read);
      fs5.readSync = typeof fs5.readSync !== "function" ? fs5.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs5, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs5.readSync);
      function patchLchmod(fs6) {
        fs6.lchmod = function(path5, mode, callback) {
          fs6.open(
            path5,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs6.fchmod(fd, mode, function(err2) {
                fs6.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs6.lchmodSync = function(path5, mode) {
          var fd = fs6.openSync(path5, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs6.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs6.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs6.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs6) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs6.futimes) {
          fs6.lutimes = function(path5, at, mt, cb) {
            fs6.open(path5, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs6.futimes(fd, at, mt, function(er2) {
                fs6.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs6.lutimesSync = function(path5, at, mt) {
            var fd = fs6.openSync(path5, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs6.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs6.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs6.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs6.futimes) {
          fs6.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs6.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs5, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs5, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs5, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs5, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs5, target, options, callback) : orig.call(fs5, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs5, target, options) : orig.call(fs5, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs5) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path5, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path5, options);
        Stream.call(this);
        var self = this;
        this.path = path5;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs5.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path5, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path5, options);
        Stream.call(this);
        this.path = path5;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs5.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs5 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util3 = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug6 = noop;
    if (util3.debuglog)
      debug6 = util3.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug6 = function() {
        var m = util3.format.apply(util3, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs5[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs5, queue);
      fs5.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs5, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs5.close);
      fs5.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs5, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs5.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug6(fs5[gracefulQueue]);
          require("assert").equal(fs5[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs5[gracefulQueue]);
    }
    module2.exports = patch(clone(fs5));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs5.__patched) {
      module2.exports = patch(fs5);
      fs5.__patched = true;
    }
    function patch(fs6) {
      polyfills(fs6);
      fs6.gracefulify = patch;
      fs6.createReadStream = createReadStream;
      fs6.createWriteStream = createWriteStream;
      var fs$readFile = fs6.readFile;
      fs6.readFile = readFile3;
      function readFile3(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path5, options, cb);
        function go$readFile(path6, options2, cb2, startTime) {
          return fs$readFile(path6, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path6, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs6.writeFile;
      fs6.writeFile = writeFile2;
      function writeFile2(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path5, data, options, cb);
        function go$writeFile(path6, data2, options2, cb2, startTime) {
          return fs$writeFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs6.appendFile;
      if (fs$appendFile)
        fs6.appendFile = appendFile;
      function appendFile(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path5, data, options, cb);
        function go$appendFile(path6, data2, options2, cb2, startTime) {
          return fs$appendFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs6.copyFile;
      if (fs$copyFile)
        fs6.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs6.readdir;
      fs6.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, options2, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path5, options, cb);
        function fs$readdirCallback(path6, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path6, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs6);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs6.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs6.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs6, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs6, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs6, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs6, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path5, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path5, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path5, options) {
        return new fs6.ReadStream(path5, options);
      }
      function createWriteStream(path5, options) {
        return new fs6.WriteStream(path5, options);
      }
      var fs$open = fs6.open;
      fs6.open = open;
      function open(path5, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path5, flags, mode, cb);
        function go$open(path6, flags2, mode2, cb2, startTime) {
          return fs$open(path6, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path6, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs6;
    }
    function enqueue(elem) {
      debug6("ENQUEUE", elem[0].name, elem[1]);
      fs5[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs5[gracefulQueue].length; ++i) {
        if (fs5[gracefulQueue][i].length > 2) {
          fs5[gracefulQueue][i][3] = now;
          fs5[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs5[gracefulQueue].length === 0)
        return;
      var elem = fs5[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug6("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug6("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug6("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs5[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs5[key] === "function";
    });
    Object.assign(exports, fs5);
    api.forEach((method) => {
      exports[method] = u(fs5[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs5.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs5.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs5.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs5.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs5.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs5.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs5.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs5.realpath.native === "function") {
      exports.realpath.native = u(fs5.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path5.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults2 = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults2, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs5.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs5.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    function pathExists(path5) {
      return fs5.access(path5).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs5.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    function utimesMillis(path5, atime, mtime, callback) {
      fs5.open(path5, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs5.futimes(fd, atime, mtime, (futimesErr) => {
          fs5.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path5, atime, mtime) {
      const fd = fs5.openSync(path5, "r+");
      fs5.futimesSync(fd, atime, mtime);
      return fs5.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/stat.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var path5 = require("path");
    var util3 = require("util");
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs5.stat(file, { bigint: true }) : (file) => fs5.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs5.statSync(file, { bigint: true }) : (file) => fs5.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util3.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path5.basename(src);
            const destBaseName = path5.basename(dest);
            if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
          }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path5.basename(src);
          const destBaseName = path5.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return cb();
      fs5.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs5.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path5.resolve(src).split(path5.sep).filter((i) => i);
      const destArr = path5.resolve(dest).split(path5.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          runFilter(src, dest, opts, (err3, include) => {
            if (err3)
              return cb(err3);
            if (!include)
              return cb();
            checkParentDir(destStat, src, dest, opts, cb);
          });
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path5.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return getStats(destStat, src, dest, opts, cb);
        });
      });
    }
    function runFilter(src, dest, opts, cb) {
      if (!opts.filter)
        return cb(null, true);
      Promise.resolve(opts.filter(src, dest)).then((include) => cb(null, include), (error) => cb(error));
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs5.stat : fs5.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
        return cb(new Error(`Unknown file: ${src}`));
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs5.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs5.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs5.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs5.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs5.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs5.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      runFilter(srcItem, destItem, opts, (err, include) => {
        if (err)
          return cb(err);
        if (!include)
          return copyDirItems(items, src, dest, opts, cb);
        stat.checkPaths(srcItem, destItem, "copy", opts, (err2, stats) => {
          if (err2)
            return cb(err2);
          const { destStat } = stats;
          getStats(destStat, srcItem, destItem, opts, (err3) => {
            if (err3)
              return cb(err3);
            return copyDirItems(items, src, dest, opts, cb);
          });
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs5.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs5.symlink(resolvedSrc, dest, cb);
        } else {
          fs5.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs5.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path5.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs5.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs5.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path5.dirname(dest);
      if (!fs5.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs5.statSync : fs5.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs5.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs5.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs5.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs5.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs5.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs5.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs5.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs5.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs5.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs5.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path5.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs5.unlinkSync(dest);
      return fs5.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove(path5, callback) {
      fs5.rm(path5, { recursive: true, force: true }, callback);
    }
    function removeSync(path5) {
      fs5.rmSync(path5, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs5.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path5.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs5.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path5.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = require("path");
    var fs5 = require_graceful_fs();
    var mkdir = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs5.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs5.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path5.dirname(file);
        fs5.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs5.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs5.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path5.dirname(file);
      try {
        if (!fs5.statSync(dir).isDirectory()) {
          fs5.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs5.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = require("path");
    var fs5 = require_graceful_fs();
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs5.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      fs5.lstat(dstpath, (_, dstStat) => {
        fs5.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            return callback(err);
          }
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          const dir = path5.dirname(dstpath);
          pathExists(dir, (err2, dirExists) => {
            if (err2)
              return callback(err2);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs5.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs5.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path5.dirname(dstpath);
      const dirExists = fs5.existsSync(dir);
      if (dirExists)
        return fs5.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs5.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var fs5 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path5.isAbsolute(srcpath)) {
        return fs5.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path5.dirname(dstpath);
        const relativeToDst = path5.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs5.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path5.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path5.isAbsolute(srcpath)) {
        exists = fs5.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path5.dirname(dstpath);
        const relativeToDst = path5.join(dstdir, srcpath);
        exists = fs5.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs5.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path5.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    function symlinkType(srcpath, type2, callback) {
      callback = typeof type2 === "function" ? type2 : callback;
      type2 = typeof type2 === "function" ? false : type2;
      if (type2)
        return callback(null, type2);
      fs5.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type2 = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type2);
      });
    }
    function symlinkTypeSync(srcpath, type2) {
      let stats;
      if (type2)
        return type2;
      try {
        stats = fs5.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = require("path");
    var fs5 = require_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type2, callback) {
      callback = typeof type2 === "function" ? type2 : callback;
      type2 = typeof type2 === "function" ? false : type2;
      fs5.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([
            fs5.stat(srcpath),
            fs5.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat))
              return callback(null);
            _createSymlink(srcpath, dstpath, type2, callback);
          });
        } else
          _createSymlink(srcpath, dstpath, type2, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type2, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative) => {
        if (err)
          return callback(err);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type2, (err2, type3) => {
          if (err2)
            return callback(err2);
          const dir = path5.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return fs5.symlink(srcpath, dstpath, type3, callback);
            mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              fs5.symlink(srcpath, dstpath, type3, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type2) {
      let stats;
      try {
        stats = fs5.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs5.statSync(srcpath);
        const dstStat = fs5.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type2 = symlinkTypeSync(relative.toCwd, type2);
      const dir = path5.dirname(dstpath);
      const exists = fs5.existsSync(dir);
      if (exists)
        return fs5.symlinkSync(srcpath, dstpath, type2);
      mkdirsSync(dir);
      return fs5.symlinkSync(srcpath, dstpath, type2);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports, module2) {
    function stringify2(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str2 = JSON.stringify(obj, replacer, spaces);
      return str2.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify: stringify2, stripBom };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify: stringify2, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs5 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs5.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile3 = universalify.fromPromise(_readFile);
    function readFileSync2(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs5 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs5.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs5 = options.fs || _fs;
      const str2 = stringify2(obj, options);
      await universalify.fromCallback(fs5.writeFile)(file, str2, options);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj, options = {}) {
      const fs5 = options.fs || _fs;
      const str2 = stringify2(obj, options);
      return fs5.writeFileSync(file, str2, options);
    }
    var jsonfile = {
      readFile: readFile3,
      readFileSync: readFileSync2,
      writeFile: writeFile2,
      writeFileSync: writeFileSync2
    };
    module2.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/output-file/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path5.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs5.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs5.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path5.dirname(file);
      if (fs5.existsSync(dir)) {
        return fs5.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs5.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var { stringify: stringify2 } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str2 = stringify2(data, options);
      await outputFile(file, str2, options);
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var { stringify: stringify2 } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str2 = stringify2(data, options);
      outputFileSync(file, str2, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, isChangingCase = false } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp(path5.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }
    function isParentRoot(dest) {
      const parent = path5.dirname(dest);
      const parsedPath = path5.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename(src, dest, overwrite, cb);
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs5.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move-sync.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path5.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path5.dirname(dest);
      const parsedPath = path5.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs5.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs5.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// ../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/version.js
var require_version = __commonJS({
  "../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/version.js"(exports, module2) {
    var VERSION_PATTERN = [
      "v?",
      "(?:",
      /* */
      "(?:(?<epoch>[0-9]+)!)?",
      // epoch
      /* */
      "(?<release>[0-9]+(?:\\.[0-9]+)*)",
      // release segment
      /* */
      "(?<pre>",
      // pre-release
      /*    */
      "[-_\\.]?",
      /*    */
      "(?<pre_l>(a|b|c|rc|alpha|beta|pre|preview))",
      /*    */
      "[-_\\.]?",
      /*    */
      "(?<pre_n>[0-9]+)?",
      /* */
      ")?",
      /* */
      "(?<post>",
      // post release
      /*    */
      "(?:-(?<post_n1>[0-9]+))",
      /*    */
      "|",
      /*    */
      "(?:",
      /*        */
      "[-_\\.]?",
      /*        */
      "(?<post_l>post|rev|r)",
      /*        */
      "[-_\\.]?",
      /*        */
      "(?<post_n2>[0-9]+)?",
      /*    */
      ")",
      /* */
      ")?",
      /* */
      "(?<dev>",
      // dev release
      /*    */
      "[-_\\.]?",
      /*    */
      "(?<dev_l>dev)",
      /*    */
      "[-_\\.]?",
      /*    */
      "(?<dev_n>[0-9]+)?",
      /* */
      ")?",
      ")",
      "(?:\\+(?<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?"
      // local version
    ].join("");
    module2.exports = {
      VERSION_PATTERN,
      valid,
      clean,
      explain,
      parse: parse4,
      stringify: stringify2
    };
    var validRegex = new RegExp("^" + VERSION_PATTERN + "$", "i");
    function valid(version2) {
      return validRegex.test(version2) ? version2 : null;
    }
    var cleanRegex = new RegExp("^\\s*" + VERSION_PATTERN + "\\s*$", "i");
    function clean(version2) {
      return stringify2(parse4(version2, cleanRegex));
    }
    function parse4(version2, regex) {
      const { groups } = (regex || validRegex).exec(version2) || {};
      if (!groups) {
        return null;
      }
      const parsed = {
        epoch: Number(groups.epoch ? groups.epoch : 0),
        release: groups.release.split(".").map(Number),
        pre: normalize_letter_version(groups.pre_l, groups.pre_n),
        post: normalize_letter_version(
          groups.post_l,
          groups.post_n1 || groups.post_n2
        ),
        dev: normalize_letter_version(groups.dev_l, groups.dev_n),
        local: parse_local_version(groups.local)
      };
      return parsed;
    }
    function stringify2(parsed) {
      if (!parsed) {
        return null;
      }
      const { epoch, release, pre, post, dev, local } = parsed;
      const parts = [];
      if (epoch !== 0) {
        parts.push(`${epoch}!`);
      }
      parts.push(release.join("."));
      if (pre) {
        parts.push(pre.join(""));
      }
      if (post) {
        parts.push("." + post.join(""));
      }
      if (dev) {
        parts.push("." + dev.join(""));
      }
      if (local) {
        parts.push(`+${local}`);
      }
      return parts.join("");
    }
    function normalize_letter_version(letterIn, numberIn) {
      let letter = letterIn;
      let number = numberIn;
      if (letter) {
        if (!number) {
          number = 0;
        }
        letter = letter.toLowerCase();
        if (letter === "alpha") {
          letter = "a";
        } else if (letter === "beta") {
          letter = "b";
        } else if (["c", "pre", "preview"].includes(letter)) {
          letter = "rc";
        } else if (["rev", "r"].includes(letter)) {
          letter = "post";
        }
        return [letter, Number(number)];
      }
      if (!letter && number) {
        letter = "post";
        return [letter, Number(number)];
      }
      return null;
    }
    function parse_local_version(local) {
      if (local) {
        return local.split(/[._-]/).map(
          (part) => Number.isNaN(Number(part)) ? part.toLowerCase() : Number(part)
        );
      }
      return null;
    }
    function explain(version2) {
      const parsed = parse4(version2);
      if (!parsed) {
        return parsed;
      }
      const { epoch, release, pre, post, dev, local } = parsed;
      let base_version = "";
      if (epoch !== 0) {
        base_version += epoch + "!";
      }
      base_version += release.join(".");
      const is_prerelease = Boolean(dev || pre);
      const is_devrelease = Boolean(dev);
      const is_postrelease = Boolean(post);
      return {
        epoch,
        release,
        pre,
        post: post ? post[1] : post,
        dev: dev ? dev[1] : dev,
        local: local ? local.join(".") : local,
        public: stringify2(parsed).split("+", 1)[0],
        base_version,
        is_prerelease,
        is_devrelease,
        is_postrelease
      };
    }
  }
});

// ../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/operator.js
var require_operator = __commonJS({
  "../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/operator.js"(exports, module2) {
    var { parse: parse4 } = require_version();
    module2.exports = {
      compare,
      rcompare,
      lt,
      le,
      eq,
      ne,
      ge,
      gt,
      "<": lt,
      "<=": le,
      "==": eq,
      "!=": ne,
      ">=": ge,
      ">": gt,
      "===": arbitrary
    };
    function lt(version2, other) {
      return compare(version2, other) < 0;
    }
    function le(version2, other) {
      return compare(version2, other) <= 0;
    }
    function eq(version2, other) {
      return compare(version2, other) === 0;
    }
    function ne(version2, other) {
      return compare(version2, other) !== 0;
    }
    function ge(version2, other) {
      return compare(version2, other) >= 0;
    }
    function gt(version2, other) {
      return compare(version2, other) > 0;
    }
    function arbitrary(version2, other) {
      return version2.toLowerCase() === other.toLowerCase();
    }
    function compare(version2, other) {
      const parsedVersion = parse4(version2);
      const parsedOther = parse4(other);
      const keyVersion = calculateKey(parsedVersion);
      const keyOther = calculateKey(parsedOther);
      return pyCompare(keyVersion, keyOther);
    }
    function rcompare(version2, other) {
      return -compare(version2, other);
    }
    function pyCompare(elemIn, otherIn) {
      let elem = elemIn;
      let other = otherIn;
      if (elem === other) {
        return 0;
      }
      if (Array.isArray(elem) !== Array.isArray(other)) {
        elem = Array.isArray(elem) ? elem : [elem];
        other = Array.isArray(other) ? other : [other];
      }
      if (Array.isArray(elem)) {
        const len = Math.min(elem.length, other.length);
        for (let i = 0; i < len; i += 1) {
          const res = pyCompare(elem[i], other[i]);
          if (res !== 0) {
            return res;
          }
        }
        return elem.length - other.length;
      }
      if (elem === -Infinity || other === Infinity) {
        return -1;
      }
      if (elem === Infinity || other === -Infinity) {
        return 1;
      }
      return elem < other ? -1 : 1;
    }
    function calculateKey(input) {
      const { epoch } = input;
      let { release, pre, post, local, dev } = input;
      release = release.concat();
      release.reverse();
      while (release.length && release[0] === 0) {
        release.shift();
      }
      release.reverse();
      if (!pre && !post && dev)
        pre = -Infinity;
      else if (!pre)
        pre = Infinity;
      if (!post)
        post = -Infinity;
      if (!dev)
        dev = Infinity;
      if (!local) {
        local = -Infinity;
      } else {
        local = local.map(
          (i) => Number.isNaN(Number(i)) ? [-Infinity, i] : [Number(i), ""]
        );
      }
      return [epoch, release, pre, post, dev, local];
    }
  }
});

// ../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/specifier.js
var require_specifier = __commonJS({
  "../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/specifier.js"(exports, module2) {
    var { VERSION_PATTERN, explain: explainVersion } = require_version();
    var Operator = require_operator();
    var RANGE_PATTERN = [
      "(?<operator>(===|~=|==|!=|<=|>=|<|>))",
      "\\s*",
      "(",
      /*  */
      "(?<version>(?:" + VERSION_PATTERN.replace(/\?<\w+>/g, "?:") + "))",
      /*  */
      "(?<prefix>\\.\\*)?",
      /*  */
      "|",
      /*  */
      "(?<legacy>[^,;\\s)]+)",
      ")"
    ].join("");
    module2.exports = {
      RANGE_PATTERN,
      parse: parse4,
      satisfies: satisfies3,
      filter: filter2,
      validRange,
      maxSatisfying,
      minSatisfying
    };
    var isEqualityOperator = (op) => ["==", "!=", "==="].includes(op);
    var rangeRegex = new RegExp("^" + RANGE_PATTERN + "$", "i");
    function parse4(ranges) {
      if (!ranges.trim()) {
        return [];
      }
      const specifiers = ranges.split(",").map((range2) => rangeRegex.exec(range2.trim()) || {}).map(({ groups }) => {
        if (!groups) {
          return null;
        }
        let { ...spec } = groups;
        const { operator, version: version2, prefix, legacy } = groups;
        if (version2) {
          spec = { ...spec, ...explainVersion(version2) };
          if (operator === "~=") {
            if (spec.release.length < 2) {
              return null;
            }
          }
          if (!isEqualityOperator(operator) && spec.local) {
            return null;
          }
          if (prefix) {
            if (!isEqualityOperator(operator) || spec.dev || spec.local) {
              return null;
            }
          }
        }
        if (legacy && operator !== "===") {
          return null;
        }
        return spec;
      });
      if (specifiers.filter(Boolean).length !== specifiers.length) {
        return null;
      }
      return specifiers;
    }
    function filter2(versions, specifier, options = {}) {
      const filtered = pick(versions, specifier, options);
      if (filtered.length === 0 && options.prereleases === void 0) {
        return pick(versions, specifier, { prereleases: true });
      }
      return filtered;
    }
    function maxSatisfying(versions, range2, options) {
      const found = filter2(versions, range2, options).sort(Operator.compare);
      return found.length === 0 ? null : found[found.length - 1];
    }
    function minSatisfying(versions, range2, options) {
      const found = filter2(versions, range2, options).sort(Operator.compare);
      return found.length === 0 ? null : found[0];
    }
    function pick(versions, specifier, options) {
      const parsed = parse4(specifier);
      if (!parsed) {
        return [];
      }
      return versions.filter((version2) => {
        const explained = explainVersion(version2);
        if (!parsed.length) {
          return explained && !(explained.is_prerelease && !options.prereleases);
        }
        return parsed.reduce((pass, spec) => {
          if (!pass) {
            return false;
          }
          return contains({ ...spec, ...options }, { version: version2, explained });
        }, true);
      });
    }
    function satisfies3(version2, specifier, options = {}) {
      const filtered = pick([version2], specifier, options);
      return filtered.length === 1;
    }
    function arrayStartsWith(array, prefix) {
      if (prefix.length > array.length) {
        return false;
      }
      for (let i = 0; i < prefix.length; i += 1) {
        if (prefix[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
    function contains(specifier, input) {
      const { explained } = input;
      let { version: version2 } = input;
      const { ...spec } = specifier;
      if (spec.prereleases === void 0) {
        spec.prereleases = spec.is_prerelease;
      }
      if (explained && explained.is_prerelease && !spec.prereleases) {
        return false;
      }
      if (spec.operator === "~=") {
        let compatiblePrefix = spec.release.slice(0, -1).concat("*").join(".");
        if (spec.epoch) {
          compatiblePrefix = spec.epoch + "!" + compatiblePrefix;
        }
        return satisfies3(version2, `>=${spec.version}, ==${compatiblePrefix}`);
      }
      if (spec.prefix) {
        const isMatching = explained.epoch === spec.epoch && arrayStartsWith(explained.release, spec.release);
        const isEquality = spec.operator !== "!=";
        return isEquality ? isMatching : !isMatching;
      }
      if (explained) {
        if (explained.local && spec.version) {
          version2 = explained.public;
          spec.version = explainVersion(spec.version).public;
        }
      }
      if (spec.operator === "<" || spec.operator === ">") {
        if (Operator.eq(spec.release.join("."), explained.release.join("."))) {
          return false;
        }
      }
      const op = Operator[spec.operator];
      return op(version2, spec.version || spec.legacy);
    }
    function validRange(specifier) {
      return Boolean(parse4(specifier));
    }
  }
});

// ../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/semantic.js
var require_semantic = __commonJS({
  "../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/lib/semantic.js"(exports, module2) {
    var { explain, parse: parse4, stringify: stringify2 } = require_version();
    module2.exports = {
      major,
      minor,
      patch,
      inc
    };
    function major(input) {
      const version2 = explain(input);
      if (!version2) {
        throw new TypeError("Invalid Version: " + input);
      }
      return version2.release[0];
    }
    function minor(input) {
      const version2 = explain(input);
      if (!version2) {
        throw new TypeError("Invalid Version: " + input);
      }
      if (version2.release.length < 2) {
        return 0;
      }
      return version2.release[1];
    }
    function patch(input) {
      const version2 = explain(input);
      if (!version2) {
        throw new TypeError("Invalid Version: " + input);
      }
      if (version2.release.length < 3) {
        return 0;
      }
      return version2.release[2];
    }
    function inc(input, release, preReleaseIdentifier) {
      let identifier = preReleaseIdentifier || `a`;
      const version2 = parse4(input);
      if (!version2) {
        return null;
      }
      if (!["a", "b", "c", "rc", "alpha", "beta", "pre", "preview"].includes(
        identifier
      )) {
        return null;
      }
      switch (release) {
        case "premajor":
          {
            const [majorVersion] = version2.release;
            version2.release.fill(0);
            version2.release[0] = majorVersion + 1;
          }
          version2.pre = [identifier, 0];
          delete version2.post;
          delete version2.dev;
          delete version2.local;
          break;
        case "preminor":
          {
            const [majorVersion, minorVersion = 0] = version2.release;
            version2.release.fill(0);
            version2.release[0] = majorVersion;
            version2.release[1] = minorVersion + 1;
          }
          version2.pre = [identifier, 0];
          delete version2.post;
          delete version2.dev;
          delete version2.local;
          break;
        case "prepatch":
          {
            const [majorVersion, minorVersion = 0, patchVersion = 0] = version2.release;
            version2.release.fill(0);
            version2.release[0] = majorVersion;
            version2.release[1] = minorVersion;
            version2.release[2] = patchVersion + 1;
          }
          version2.pre = [identifier, 0];
          delete version2.post;
          delete version2.dev;
          delete version2.local;
          break;
        case "prerelease":
          if (version2.pre === null) {
            const [majorVersion, minorVersion = 0, patchVersion = 0] = version2.release;
            version2.release.fill(0);
            version2.release[0] = majorVersion;
            version2.release[1] = minorVersion;
            version2.release[2] = patchVersion + 1;
            version2.pre = [identifier, 0];
          } else {
            if (preReleaseIdentifier === void 0 && version2.pre !== null) {
              [identifier] = version2.pre;
            }
            const [letter, number] = version2.pre;
            if (letter === identifier) {
              version2.pre = [letter, number + 1];
            } else {
              version2.pre = [identifier, 0];
            }
          }
          delete version2.post;
          delete version2.dev;
          delete version2.local;
          break;
        case "major":
          if (version2.release.slice(1).some((value) => value !== 0) || version2.pre === null) {
            const [majorVersion] = version2.release;
            version2.release.fill(0);
            version2.release[0] = majorVersion + 1;
          }
          delete version2.pre;
          delete version2.post;
          delete version2.dev;
          delete version2.local;
          break;
        case "minor":
          if (version2.release.slice(2).some((value) => value !== 0) || version2.pre === null) {
            const [majorVersion, minorVersion = 0] = version2.release;
            version2.release.fill(0);
            version2.release[0] = majorVersion;
            version2.release[1] = minorVersion + 1;
          }
          delete version2.pre;
          delete version2.post;
          delete version2.dev;
          delete version2.local;
          break;
        case "patch":
          if (version2.release.slice(3).some((value) => value !== 0) || version2.pre === null) {
            const [majorVersion, minorVersion = 0, patchVersion = 0] = version2.release;
            version2.release.fill(0);
            version2.release[0] = majorVersion;
            version2.release[1] = minorVersion;
            version2.release[2] = patchVersion + 1;
          }
          delete version2.pre;
          delete version2.post;
          delete version2.dev;
          delete version2.local;
          break;
        default:
          return null;
      }
      return stringify2(version2);
    }
  }
});

// ../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/index.js
var require_pep440 = __commonJS({
  "../../node_modules/.pnpm/@renovatebot+pep440@4.2.1/node_modules/@renovatebot/pep440/index.js"(exports, module2) {
    var { valid, clean, explain, parse: parse4 } = require_version();
    var { lt, le, eq, ne, ge, gt, compare, rcompare } = require_operator();
    var {
      filter: filter2,
      maxSatisfying,
      minSatisfying,
      RANGE_PATTERN,
      satisfies: satisfies3,
      validRange
    } = require_specifier();
    var { major, minor, patch, inc } = require_semantic();
    module2.exports = {
      // version
      valid,
      clean,
      explain,
      parse: parse4,
      // operator
      lt,
      le,
      lte: le,
      eq,
      ne,
      neq: ne,
      ge,
      gte: ge,
      gt,
      compare,
      rcompare,
      // range
      filter: filter2,
      maxSatisfying,
      minSatisfying,
      RANGE_PATTERN,
      satisfies: satisfies3,
      validRange,
      // semantic
      major,
      minor,
      patch,
      inc
    };
  }
});

// ../../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/dist/ohm.cjs
var require_ohm = __commonJS({
  "../../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/dist/ohm.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function abstract(optMethodName) {
      const methodName = optMethodName || "";
      return function() {
        throw new Error(
          "this method " + methodName + " is abstract! (it has no implementation in class " + this.constructor.name + ")"
        );
      };
    }
    function assert2(cond, message) {
      if (!cond) {
        throw new Error(message || "Assertion failed");
      }
    }
    function defineLazyProperty(obj, propName, getterFn) {
      let memo;
      Object.defineProperty(obj, propName, {
        get() {
          if (!memo) {
            memo = getterFn.call(this);
          }
          return memo;
        }
      });
    }
    function clone(obj) {
      if (obj) {
        return Object.assign({}, obj);
      }
      return obj;
    }
    function repeatFn(fn, n) {
      const arr = [];
      while (n-- > 0) {
        arr.push(fn());
      }
      return arr;
    }
    function repeatStr(str2, n) {
      return new Array(n + 1).join(str2);
    }
    function repeat2(x, n) {
      return repeatFn(() => x, n);
    }
    function getDuplicates(array) {
      const duplicates = [];
      for (let idx = 0; idx < array.length; idx++) {
        const x = array[idx];
        if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {
          duplicates.push(x);
        }
      }
      return duplicates;
    }
    function copyWithoutDuplicates(array) {
      const noDuplicates = [];
      array.forEach((entry) => {
        if (noDuplicates.indexOf(entry) < 0) {
          noDuplicates.push(entry);
        }
      });
      return noDuplicates;
    }
    function isSyntactic(ruleName) {
      const firstChar = ruleName[0];
      return firstChar === firstChar.toUpperCase();
    }
    function isLexical(ruleName) {
      return !isSyntactic(ruleName);
    }
    function padLeft(str2, len, optChar) {
      const ch = optChar || " ";
      if (str2.length < len) {
        return repeatStr(ch, len - str2.length) + str2;
      }
      return str2;
    }
    function StringBuffer() {
      this.strings = [];
    }
    StringBuffer.prototype.append = function(str2) {
      this.strings.push(str2);
    };
    StringBuffer.prototype.contents = function() {
      return this.strings.join("");
    };
    var escapeUnicode = (str2) => String.fromCodePoint(parseInt(str2, 16));
    function unescapeCodePoint(s) {
      if (s.charAt(0) === "\\") {
        switch (s.charAt(1)) {
          case "b":
            return "\b";
          case "f":
            return "\f";
          case "n":
            return "\n";
          case "r":
            return "\r";
          case "t":
            return "	";
          case "v":
            return "\v";
          case "x":
            return escapeUnicode(s.slice(2, 4));
          case "u":
            return s.charAt(2) === "{" ? escapeUnicode(s.slice(3, -1)) : escapeUnicode(s.slice(2, 6));
          default:
            return s.charAt(1);
        }
      } else {
        return s;
      }
    }
    function unexpectedObjToString(obj) {
      if (obj == null) {
        return String(obj);
      }
      const baseToString = Object.prototype.toString.call(obj);
      try {
        let typeName;
        if (obj.constructor && obj.constructor.name) {
          typeName = obj.constructor.name;
        } else if (baseToString.indexOf("[object ") === 0) {
          typeName = baseToString.slice(8, -1);
        } else {
          typeName = typeof obj;
        }
        return typeName + ": " + JSON.stringify(String(obj));
      } catch (e) {
        return baseToString;
      }
    }
    function checkNotNull(obj, message = "unexpected null value") {
      if (obj == null) {
        throw new Error(message);
      }
      return obj;
    }
    var common2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      abstract,
      assert: assert2,
      defineLazyProperty,
      clone,
      repeatFn,
      repeatStr,
      repeat: repeat2,
      getDuplicates,
      copyWithoutDuplicates,
      isSyntactic,
      isLexical,
      padLeft,
      StringBuffer,
      unescapeCodePoint,
      unexpectedObjToString,
      checkNotNull
    });
    var UnicodeCategories = {
      // Letters
      Lu: /\p{Lu}/u,
      Ll: /\p{Ll}/u,
      Lt: /\p{Lt}/u,
      Lm: /\p{Lm}/u,
      Lo: /\p{Lo}/u,
      // Numbers
      Nl: /\p{Nl}/u,
      Nd: /\p{Nd}/u,
      // Marks
      Mn: /\p{Mn}/u,
      Mc: /\p{Mc}/u,
      // Punctuation, Connector
      Pc: /\p{Pc}/u,
      // Separator, Space
      Zs: /\p{Zs}/u,
      // These two are not real Unicode categories, but our useful for Ohm.
      // L is a combination of all the letter categories.
      // Ltmo is a combination of Lt, Lm, and Lo.
      L: /\p{Letter}/u,
      Ltmo: /\p{Lt}|\p{Lm}|\p{Lo}/u
    };
    var PExpr = class _PExpr {
      constructor() {
        if (this.constructor === _PExpr) {
          throw new Error("PExpr cannot be instantiated -- it's abstract");
        }
      }
      // Set the `source` property to the interval containing the source for this expression.
      withSource(interval) {
        if (interval) {
          this.source = interval.trimmed();
        }
        return this;
      }
    };
    var any = Object.create(PExpr.prototype);
    var end = Object.create(PExpr.prototype);
    var Terminal = class extends PExpr {
      constructor(obj) {
        super();
        this.obj = obj;
      }
    };
    var Range = class extends PExpr {
      constructor(from, to) {
        super();
        this.from = from;
        this.to = to;
        this.matchCodePoint = from.length > 1 || to.length > 1;
      }
    };
    var Param = class extends PExpr {
      constructor(index) {
        super();
        this.index = index;
      }
    };
    var Alt = class extends PExpr {
      constructor(terms) {
        super();
        this.terms = terms;
      }
    };
    var Extend = class extends Alt {
      constructor(superGrammar, name, body) {
        const origBody = superGrammar.rules[name].body;
        super([body, origBody]);
        this.superGrammar = superGrammar;
        this.name = name;
        this.body = body;
      }
    };
    var Splice = class extends Alt {
      constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
        const origBody = superGrammar.rules[ruleName].body;
        super([...beforeTerms, origBody, ...afterTerms]);
        this.superGrammar = superGrammar;
        this.ruleName = ruleName;
        this.expansionPos = beforeTerms.length;
      }
    };
    var Seq = class extends PExpr {
      constructor(factors) {
        super();
        this.factors = factors;
      }
    };
    var Iter = class extends PExpr {
      constructor(expr) {
        super();
        this.expr = expr;
      }
    };
    var Star = class extends Iter {
    };
    var Plus = class extends Iter {
    };
    var Opt = class extends Iter {
    };
    Star.prototype.operator = "*";
    Plus.prototype.operator = "+";
    Opt.prototype.operator = "?";
    Star.prototype.minNumMatches = 0;
    Plus.prototype.minNumMatches = 1;
    Opt.prototype.minNumMatches = 0;
    Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
    Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
    Opt.prototype.maxNumMatches = 1;
    var Not = class extends PExpr {
      constructor(expr) {
        super();
        this.expr = expr;
      }
    };
    var Lookahead = class extends PExpr {
      constructor(expr) {
        super();
        this.expr = expr;
      }
    };
    var Lex = class extends PExpr {
      constructor(expr) {
        super();
        this.expr = expr;
      }
    };
    var Apply = class extends PExpr {
      constructor(ruleName, args = []) {
        super();
        this.ruleName = ruleName;
        this.args = args;
      }
      isSyntactic() {
        return isSyntactic(this.ruleName);
      }
      // This method just caches the result of `this.toString()` in a non-enumerable property.
      toMemoKey() {
        if (!this._memoKey) {
          Object.defineProperty(this, "_memoKey", { value: this.toString() });
        }
        return this._memoKey;
      }
    };
    var UnicodeChar = class extends PExpr {
      constructor(category) {
        super();
        this.category = category;
        this.pattern = UnicodeCategories[category];
      }
    };
    function createError(message, optInterval) {
      let e;
      if (optInterval) {
        e = new Error(optInterval.getLineAndColumnMessage() + message);
        e.shortMessage = message;
        e.interval = optInterval;
      } else {
        e = new Error(message);
      }
      return e;
    }
    function intervalSourcesDontMatch() {
      return createError("Interval sources don't match");
    }
    function grammarSyntaxError(matchFailure) {
      const e = new Error();
      Object.defineProperty(e, "message", {
        enumerable: true,
        get() {
          return matchFailure.message;
        }
      });
      Object.defineProperty(e, "shortMessage", {
        enumerable: true,
        get() {
          return "Expected " + matchFailure.getExpectedText();
        }
      });
      e.interval = matchFailure.getInterval();
      return e;
    }
    function undeclaredGrammar(grammarName, namespace, interval) {
      const message = namespace ? `Grammar ${grammarName} is not declared in namespace '${namespace}'` : "Undeclared grammar " + grammarName;
      return createError(message, interval);
    }
    function duplicateGrammarDeclaration(grammar2, namespace) {
      return createError("Grammar " + grammar2.name + " is already declared in this namespace");
    }
    function grammarDoesNotSupportIncrementalParsing(grammar2) {
      return createError(`Grammar '${grammar2.name}' does not support incremental parsing`);
    }
    function undeclaredRule(ruleName, grammarName, optInterval) {
      return createError(
        "Rule " + ruleName + " is not declared in grammar " + grammarName,
        optInterval
      );
    }
    function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
      return createError(
        "Cannot override rule " + ruleName + " because it is not declared in " + grammarName,
        optSource
      );
    }
    function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
      return createError(
        "Cannot extend rule " + ruleName + " because it is not declared in " + grammarName,
        optSource
      );
    }
    function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
      let message = "Duplicate declaration for rule '" + ruleName + "' in grammar '" + grammarName + "'";
      if (grammarName !== declGrammarName) {
        message += " (originally declared in '" + declGrammarName + "')";
      }
      return createError(message, optSource);
    }
    function wrongNumberOfParameters(ruleName, expected, actual, source) {
      return createError(
        "Wrong number of parameters for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
        source
      );
    }
    function wrongNumberOfArguments(ruleName, expected, actual, expr) {
      return createError(
        "Wrong number of arguments for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
        expr
      );
    }
    function duplicateParameterNames(ruleName, duplicates, source) {
      return createError(
        "Duplicate parameter names in rule " + ruleName + ": " + duplicates.join(", "),
        source
      );
    }
    function invalidParameter(ruleName, expr) {
      return createError(
        "Invalid parameter to rule " + ruleName + ": " + expr + " has arity " + expr.getArity() + ", but parameter expressions must have arity 1",
        expr.source
      );
    }
    var syntacticVsLexicalNote = "NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. See https://ohmjs.org/d/svl for more details.";
    function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
      return createError(
        "Cannot apply syntactic rule " + ruleName + " from here (inside a lexical context)",
        applyExpr.source
      );
    }
    function applySyntacticWithLexicalRuleApplication(applyExpr) {
      const { ruleName } = applyExpr;
      return createError(
        `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` + syntacticVsLexicalNote,
        applyExpr.source
      );
    }
    function unnecessaryExperimentalApplySyntactic(applyExpr) {
      return createError(
        "applySyntactic is not required here (in a syntactic context)",
        applyExpr.source
      );
    }
    function incorrectArgumentType(expectedType, expr) {
      return createError("Incorrect argument type: expected " + expectedType, expr.source);
    }
    function multipleSuperSplices(expr) {
      return createError("'...' can appear at most once in a rule body", expr.source);
    }
    function invalidCodePoint(applyWrapper) {
      const node = applyWrapper._node;
      assert2(node && node.isNonterminal() && node.ctorName === "escapeChar_unicodeCodePoint");
      const digitIntervals = applyWrapper.children.slice(1, -1).map((d) => d.source);
      const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));
      return createError(
        `U+${fullInterval.contents} is not a valid Unicode code point`,
        fullInterval
      );
    }
    function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
      const actuals = applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];
      const expr = kleeneExpr.expr.substituteParams(actuals);
      let message = "Nullable expression " + expr + " is not allowed inside '" + kleeneExpr.operator + "' (possible infinite loop)";
      if (applicationStack.length > 0) {
        const stackTrace = applicationStack.map((app) => new Apply(app.ruleName, app.args)).join("\n");
        message += "\nApplication stack (most recent application last):\n" + stackTrace;
      }
      return createError(message, kleeneExpr.expr.source);
    }
    function inconsistentArity(ruleName, expected, actual, expr) {
      return createError(
        "Rule " + ruleName + " involves an alternation which has inconsistent arity (expected " + expected + ", got " + actual + ")",
        expr.source
      );
    }
    function multipleErrors(errors) {
      const messages = errors.map((e) => e.message);
      return createError(["Errors:"].concat(messages).join("\n- "), errors[0].interval);
    }
    function missingSemanticAction(ctorName, name, type2, stack) {
      let stackTrace = stack.slice(0, -1).map((info) => {
        const ans = "  " + info[0].name + " > " + info[1];
        return info.length === 3 ? ans + " for '" + info[2] + "'" : ans;
      }).join("\n");
      stackTrace += "\n  " + name + " > " + ctorName;
      let moreInfo = "";
      if (ctorName === "_iter") {
        moreInfo = [
          "\nNOTE: as of Ohm v16, there is no default action for iteration nodes \u2014 see ",
          "  https://ohmjs.org/d/dsa for details."
        ].join("\n");
      }
      const message = [
        `Missing semantic action for '${ctorName}' in ${type2} '${name}'.${moreInfo}`,
        "Action stack (most recent call last):",
        stackTrace
      ].join("\n");
      const e = createError(message);
      e.name = "missingSemanticAction";
      return e;
    }
    function throwErrors(errors) {
      if (errors.length === 1) {
        throw errors[0];
      }
      if (errors.length > 1) {
        throw multipleErrors(errors);
      }
    }
    function padNumbersToEqualLength(arr) {
      let maxLen = 0;
      const strings = arr.map((n) => {
        const str2 = n.toString();
        maxLen = Math.max(maxLen, str2.length);
        return str2;
      });
      return strings.map((s) => padLeft(s, maxLen));
    }
    function strcpy(dest, src, offset) {
      const origDestLen = dest.length;
      const start = dest.slice(0, offset);
      const end2 = dest.slice(offset + src.length);
      return (start + src + end2).substr(0, origDestLen);
    }
    function lineAndColumnToMessage(...ranges) {
      const lineAndCol = this;
      const { offset } = lineAndCol;
      const { repeatStr: repeatStr2 } = common2;
      const sb = new StringBuffer();
      sb.append("Line " + lineAndCol.lineNum + ", col " + lineAndCol.colNum + ":\n");
      const lineNumbers = padNumbersToEqualLength([
        lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
        lineAndCol.lineNum,
        lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
      ]);
      const appendLine = (num, content, prefix) => {
        sb.append(prefix + lineNumbers[num] + " | " + content + "\n");
      };
      if (lineAndCol.prevLine != null) {
        appendLine(0, lineAndCol.prevLine, "  ");
      }
      appendLine(1, lineAndCol.line, "> ");
      const lineLen = lineAndCol.line.length;
      let indicationLine = repeatStr2(" ", lineLen + 1);
      for (let i = 0; i < ranges.length; ++i) {
        let startIdx = ranges[i][0];
        let endIdx = ranges[i][1];
        assert2(startIdx >= 0 && startIdx <= endIdx, "range start must be >= 0 and <= end");
        const lineStartOffset = offset - lineAndCol.colNum + 1;
        startIdx = Math.max(0, startIdx - lineStartOffset);
        endIdx = Math.min(endIdx - lineStartOffset, lineLen);
        indicationLine = strcpy(indicationLine, repeatStr2("~", endIdx - startIdx), startIdx);
      }
      const gutterWidth = 2 + lineNumbers[1].length + 3;
      sb.append(repeatStr2(" ", gutterWidth));
      indicationLine = strcpy(indicationLine, "^", lineAndCol.colNum - 1);
      sb.append(indicationLine.replace(/ +$/, "") + "\n");
      if (lineAndCol.nextLine != null) {
        appendLine(2, lineAndCol.nextLine, "  ");
      }
      return sb.contents();
    }
    var builtInRulesCallbacks = [];
    function awaitBuiltInRules(cb) {
      builtInRulesCallbacks.push(cb);
    }
    function announceBuiltInRules(grammar2) {
      builtInRulesCallbacks.forEach((cb) => {
        cb(grammar2);
      });
      builtInRulesCallbacks = null;
    }
    function getLineAndColumn(str2, offset) {
      let lineNum = 1;
      let colNum = 1;
      let currOffset = 0;
      let lineStartOffset = 0;
      let nextLine = null;
      let prevLine = null;
      let prevLineStartOffset = -1;
      while (currOffset < offset) {
        const c = str2.charAt(currOffset++);
        if (c === "\n") {
          lineNum++;
          colNum = 1;
          prevLineStartOffset = lineStartOffset;
          lineStartOffset = currOffset;
        } else if (c !== "\r") {
          colNum++;
        }
      }
      let lineEndOffset = str2.indexOf("\n", lineStartOffset);
      if (lineEndOffset === -1) {
        lineEndOffset = str2.length;
      } else {
        const nextLineEndOffset = str2.indexOf("\n", lineEndOffset + 1);
        nextLine = nextLineEndOffset === -1 ? str2.slice(lineEndOffset) : str2.slice(lineEndOffset, nextLineEndOffset);
        nextLine = nextLine.replace(/^\r?\n/, "").replace(/\r$/, "");
      }
      if (prevLineStartOffset >= 0) {
        prevLine = str2.slice(prevLineStartOffset, lineStartOffset).replace(/\r?\n$/, "");
      }
      const line = str2.slice(lineStartOffset, lineEndOffset).replace(/\r$/, "");
      return {
        offset,
        lineNum,
        colNum,
        line,
        prevLine,
        nextLine,
        toString: lineAndColumnToMessage
      };
    }
    function getLineAndColumnMessage(str2, offset, ...ranges) {
      return getLineAndColumn(str2, offset).toString(...ranges);
    }
    var uniqueId = (() => {
      let idCounter = 0;
      return (prefix) => "" + prefix + idCounter++;
    })();
    var Interval = class _Interval {
      constructor(sourceString, startIdx, endIdx) {
        this.sourceString = sourceString;
        this.startIdx = startIdx;
        this.endIdx = endIdx;
      }
      get contents() {
        if (this._contents === void 0) {
          this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
        }
        return this._contents;
      }
      get length() {
        return this.endIdx - this.startIdx;
      }
      coverageWith(...intervals) {
        return _Interval.coverage(...intervals, this);
      }
      collapsedLeft() {
        return new _Interval(this.sourceString, this.startIdx, this.startIdx);
      }
      collapsedRight() {
        return new _Interval(this.sourceString, this.endIdx, this.endIdx);
      }
      getLineAndColumn() {
        return getLineAndColumn(this.sourceString, this.startIdx);
      }
      getLineAndColumnMessage() {
        const range2 = [this.startIdx, this.endIdx];
        return getLineAndColumnMessage(this.sourceString, this.startIdx, range2);
      }
      // Returns an array of 0, 1, or 2 intervals that represents the result of the
      // interval difference operation.
      minus(that) {
        if (this.sourceString !== that.sourceString) {
          throw intervalSourcesDontMatch();
        } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
          return [];
        } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
          return [
            new _Interval(this.sourceString, this.startIdx, that.startIdx),
            new _Interval(this.sourceString, that.endIdx, this.endIdx)
          ];
        } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
          return [new _Interval(this.sourceString, that.endIdx, this.endIdx)];
        } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
          return [new _Interval(this.sourceString, this.startIdx, that.startIdx)];
        } else {
          return [this];
        }
      }
      // Returns a new Interval that has the same extent as this one, but which is relative
      // to `that`, an Interval that fully covers this one.
      relativeTo(that) {
        if (this.sourceString !== that.sourceString) {
          throw intervalSourcesDontMatch();
        }
        assert2(
          this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
          "other interval does not cover this one"
        );
        return new _Interval(
          this.sourceString,
          this.startIdx - that.startIdx,
          this.endIdx - that.startIdx
        );
      }
      // Returns a new Interval which contains the same contents as this one,
      // but with whitespace trimmed from both ends.
      trimmed() {
        const { contents } = this;
        const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
        const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
        return new _Interval(this.sourceString, startIdx, endIdx);
      }
      subInterval(offset, len) {
        const newStartIdx = this.startIdx + offset;
        return new _Interval(this.sourceString, newStartIdx, newStartIdx + len);
      }
    };
    Interval.coverage = function(firstInterval, ...intervals) {
      let { startIdx, endIdx } = firstInterval;
      for (const interval of intervals) {
        if (interval.sourceString !== firstInterval.sourceString) {
          throw intervalSourcesDontMatch();
        } else {
          startIdx = Math.min(startIdx, interval.startIdx);
          endIdx = Math.max(endIdx, interval.endIdx);
        }
      }
      return new Interval(firstInterval.sourceString, startIdx, endIdx);
    };
    var MAX_CHAR_CODE = 65535;
    var InputStream = class {
      constructor(source) {
        this.source = source;
        this.pos = 0;
        this.examinedLength = 0;
      }
      atEnd() {
        const ans = this.pos >= this.source.length;
        this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
        return ans;
      }
      next() {
        const ans = this.source[this.pos++];
        this.examinedLength = Math.max(this.examinedLength, this.pos);
        return ans;
      }
      nextCharCode() {
        const nextChar = this.next();
        return nextChar && nextChar.charCodeAt(0);
      }
      nextCodePoint() {
        const cp = this.source.slice(this.pos++).codePointAt(0);
        if (cp > MAX_CHAR_CODE) {
          this.pos += 1;
        }
        this.examinedLength = Math.max(this.examinedLength, this.pos);
        return cp;
      }
      matchString(s, optIgnoreCase) {
        let idx;
        if (optIgnoreCase) {
          for (idx = 0; idx < s.length; idx++) {
            const actual = this.next();
            const expected = s[idx];
            if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
              return false;
            }
          }
          return true;
        }
        for (idx = 0; idx < s.length; idx++) {
          if (this.next() !== s[idx]) {
            return false;
          }
        }
        return true;
      }
      sourceSlice(startIdx, endIdx) {
        return this.source.slice(startIdx, endIdx);
      }
      interval(startIdx, optEndIdx) {
        return new Interval(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
      }
    };
    var MatchResult = class {
      constructor(matcher, input, startExpr, cst, cstOffset, rightmostFailurePosition, optRecordedFailures) {
        this.matcher = matcher;
        this.input = input;
        this.startExpr = startExpr;
        this._cst = cst;
        this._cstOffset = cstOffset;
        this._rightmostFailurePosition = rightmostFailurePosition;
        this._rightmostFailures = optRecordedFailures;
        if (this.failed()) {
          defineLazyProperty(this, "message", function() {
            const detail = "Expected " + this.getExpectedText();
            return getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
          });
          defineLazyProperty(this, "shortMessage", function() {
            const detail = "expected " + this.getExpectedText();
            const errorInfo = getLineAndColumn(
              this.input,
              this.getRightmostFailurePosition()
            );
            return "Line " + errorInfo.lineNum + ", col " + errorInfo.colNum + ": " + detail;
          });
        }
      }
      succeeded() {
        return !!this._cst;
      }
      failed() {
        return !this.succeeded();
      }
      getRightmostFailurePosition() {
        return this._rightmostFailurePosition;
      }
      getRightmostFailures() {
        if (!this._rightmostFailures) {
          this.matcher.setInput(this.input);
          const matchResultWithFailures = this.matcher._match(this.startExpr, {
            tracing: false,
            positionToRecordFailures: this.getRightmostFailurePosition()
          });
          this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
        }
        return this._rightmostFailures;
      }
      toString() {
        return this.succeeded() ? "[match succeeded]" : "[match failed at position " + this.getRightmostFailurePosition() + "]";
      }
      // Return a string summarizing the expected contents of the input stream when
      // the match failure occurred.
      getExpectedText() {
        if (this.succeeded()) {
          throw new Error("cannot get expected text of a successful MatchResult");
        }
        const sb = new StringBuffer();
        let failures = this.getRightmostFailures();
        failures = failures.filter((failure) => !failure.isFluffy());
        for (let idx = 0; idx < failures.length; idx++) {
          if (idx > 0) {
            if (idx === failures.length - 1) {
              sb.append(failures.length > 2 ? ", or " : " or ");
            } else {
              sb.append(", ");
            }
          }
          sb.append(failures[idx].toString());
        }
        return sb.contents();
      }
      getInterval() {
        const pos = this.getRightmostFailurePosition();
        return new Interval(this.input, pos, pos);
      }
    };
    var PosInfo = class {
      constructor() {
        this.applicationMemoKeyStack = [];
        this.memo = {};
        this.maxExaminedLength = 0;
        this.maxRightmostFailureOffset = -1;
        this.currentLeftRecursion = void 0;
      }
      isActive(application) {
        return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
      }
      enter(application) {
        this.applicationMemoKeyStack.push(application.toMemoKey());
      }
      exit() {
        this.applicationMemoKeyStack.pop();
      }
      startLeftRecursion(headApplication, memoRec) {
        memoRec.isLeftRecursion = true;
        memoRec.headApplication = headApplication;
        memoRec.nextLeftRecursion = this.currentLeftRecursion;
        this.currentLeftRecursion = memoRec;
        const { applicationMemoKeyStack } = this;
        const indexOfFirstInvolvedRule = applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
        const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(
          indexOfFirstInvolvedRule
        );
        memoRec.isInvolved = function(applicationMemoKey) {
          return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
        };
        memoRec.updateInvolvedApplicationMemoKeys = function() {
          for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
            const applicationMemoKey = applicationMemoKeyStack[idx];
            if (!this.isInvolved(applicationMemoKey)) {
              involvedApplicationMemoKeys.push(applicationMemoKey);
            }
          }
        };
      }
      endLeftRecursion() {
        this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
      }
      // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
      // the memoized result (which starts out being a failure) is always used.
      shouldUseMemoizedResult(memoRec) {
        if (!memoRec.isLeftRecursion) {
          return true;
        }
        const { applicationMemoKeyStack } = this;
        for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
          const applicationMemoKey = applicationMemoKeyStack[idx];
          if (memoRec.isInvolved(applicationMemoKey)) {
            return false;
          }
        }
        return true;
      }
      memoize(memoKey, memoRec) {
        this.memo[memoKey] = memoRec;
        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
        this.maxRightmostFailureOffset = Math.max(
          this.maxRightmostFailureOffset,
          memoRec.rightmostFailureOffset
        );
        return memoRec;
      }
      clearObsoleteEntries(pos, invalidatedIdx) {
        if (pos + this.maxExaminedLength <= invalidatedIdx) {
          return;
        }
        const { memo } = this;
        this.maxExaminedLength = 0;
        this.maxRightmostFailureOffset = -1;
        Object.keys(memo).forEach((k) => {
          const memoRec = memo[k];
          if (pos + memoRec.examinedLength > invalidatedIdx) {
            delete memo[k];
          } else {
            this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
            this.maxRightmostFailureOffset = Math.max(
              this.maxRightmostFailureOffset,
              memoRec.rightmostFailureOffset
            );
          }
        });
      }
    };
    var BALLOT_X = "\u2717";
    var CHECK_MARK = "\u2713";
    var DOT_OPERATOR = "\u22C5";
    var RIGHTWARDS_DOUBLE_ARROW = "\u21D2";
    var SYMBOL_FOR_HORIZONTAL_TABULATION = "\u2409";
    var SYMBOL_FOR_LINE_FEED = "\u240A";
    var SYMBOL_FOR_CARRIAGE_RETURN = "\u240D";
    var Flags = {
      succeeded: 1 << 0,
      isRootNode: 1 << 1,
      isImplicitSpaces: 1 << 2,
      isMemoized: 1 << 3,
      isHeadOfLeftRecursion: 1 << 4,
      terminatesLR: 1 << 5
    };
    function spaces(n) {
      return repeat2(" ", n).join("");
    }
    function getInputExcerpt(input, pos, len) {
      const excerpt = asEscapedString(input.slice(pos, pos + len));
      if (excerpt.length < len) {
        return excerpt + repeat2(" ", len - excerpt.length).join("");
      }
      return excerpt;
    }
    function asEscapedString(obj) {
      if (typeof obj === "string") {
        return obj.replace(/ /g, DOT_OPERATOR).replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION).replace(/\n/g, SYMBOL_FOR_LINE_FEED).replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
      }
      return String(obj);
    }
    var Trace = class _Trace {
      constructor(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
        this.input = input;
        this.pos = this.pos1 = pos1;
        this.pos2 = pos2;
        this.source = new Interval(input, pos1, pos2);
        this.expr = expr;
        this.bindings = bindings;
        this.children = optChildren || [];
        this.terminatingLREntry = null;
        this._flags = succeeded ? Flags.succeeded : 0;
      }
      get displayString() {
        return this.expr.toDisplayString();
      }
      clone() {
        return this.cloneWithExpr(this.expr);
      }
      cloneWithExpr(expr) {
        const ans = new _Trace(
          this.input,
          this.pos,
          this.pos2,
          expr,
          this.succeeded,
          this.bindings,
          this.children
        );
        ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
        ans.isImplicitSpaces = this.isImplicitSpaces;
        ans.isMemoized = this.isMemoized;
        ans.isRootNode = this.isRootNode;
        ans.terminatesLR = this.terminatesLR;
        ans.terminatingLREntry = this.terminatingLREntry;
        return ans;
      }
      // Record the trace information for the terminating condition of the LR loop.
      recordLRTermination(ruleBodyTrace, value) {
        this.terminatingLREntry = new _Trace(
          this.input,
          this.pos,
          this.pos2,
          this.expr,
          false,
          [value],
          [ruleBodyTrace]
        );
        this.terminatingLREntry.terminatesLR = true;
      }
      // Recursively traverse this trace node and all its descendents, calling a visitor function
      // for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property
      // is a function to call before visiting the children of a node, and its 'exit' property is
      // a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'
      // function.
      //
      // The functions are called with three arguments: the Trace node, its parent Trace, and a number
      // representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if
      // specified, is the value to use for `this` when executing the visitor functions.
      walk(visitorObjOrFn, optThisArg) {
        let visitor = visitorObjOrFn;
        if (typeof visitor === "function") {
          visitor = { enter: visitor };
        }
        function _walk(node, parent, depth) {
          let recurse = true;
          if (visitor.enter) {
            if (visitor.enter.call(optThisArg, node, parent, depth) === _Trace.prototype.SKIP) {
              recurse = false;
            }
          }
          if (recurse) {
            node.children.forEach((child) => {
              _walk(child, node, depth + 1);
            });
            if (visitor.exit) {
              visitor.exit.call(optThisArg, node, parent, depth);
            }
          }
        }
        if (this.isRootNode) {
          this.children.forEach((c) => {
            _walk(c, null, 0);
          });
        } else {
          _walk(this, null, 0);
        }
      }
      // Return a string representation of the trace.
      // Sample:
      //     12+2*3  exp   "12"
      //     12+2*3    addExp (LR)   "12"
      //     12+2*3        addExp_plus
      toString() {
        const sb = new StringBuffer();
        this.walk((node, parent, depth) => {
          if (!node) {
            return this.SKIP;
          }
          const ctorName = node.expr.constructor.name;
          if (ctorName === "Alt") {
            return;
          }
          sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
          sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + " " + node.displayString);
          if (node.isHeadOfLeftRecursion) {
            sb.append(" (LR)");
          }
          if (node.succeeded) {
            const contents = asEscapedString(node.source.contents);
            sb.append(" " + RIGHTWARDS_DOUBLE_ARROW + "  ");
            sb.append(typeof contents === "string" ? '"' + contents + '"' : contents);
          }
          sb.append("\n");
        });
        return sb.contents();
      }
    };
    Trace.prototype.SKIP = {};
    Object.keys(Flags).forEach((name) => {
      const mask = Flags[name];
      Object.defineProperty(Trace.prototype, name, {
        get() {
          return (this._flags & mask) !== 0;
        },
        set(val) {
          if (val) {
            this._flags |= mask;
          } else {
            this._flags &= ~mask;
          }
        }
      });
    });
    PExpr.prototype.allowsSkippingPrecedingSpace = abstract("allowsSkippingPrecedingSpace");
    any.allowsSkippingPrecedingSpace = end.allowsSkippingPrecedingSpace = Apply.prototype.allowsSkippingPrecedingSpace = Terminal.prototype.allowsSkippingPrecedingSpace = Range.prototype.allowsSkippingPrecedingSpace = UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
      return true;
    };
    Alt.prototype.allowsSkippingPrecedingSpace = Iter.prototype.allowsSkippingPrecedingSpace = Lex.prototype.allowsSkippingPrecedingSpace = Lookahead.prototype.allowsSkippingPrecedingSpace = Not.prototype.allowsSkippingPrecedingSpace = Param.prototype.allowsSkippingPrecedingSpace = Seq.prototype.allowsSkippingPrecedingSpace = function() {
      return false;
    };
    var BuiltInRules$1;
    awaitBuiltInRules((g) => {
      BuiltInRules$1 = g;
    });
    var lexifyCount;
    PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar2) {
      lexifyCount = 0;
      this._assertAllApplicationsAreValid(ruleName, grammar2);
    };
    PExpr.prototype._assertAllApplicationsAreValid = abstract(
      "_assertAllApplicationsAreValid"
    );
    any._assertAllApplicationsAreValid = end._assertAllApplicationsAreValid = Terminal.prototype._assertAllApplicationsAreValid = Range.prototype._assertAllApplicationsAreValid = Param.prototype._assertAllApplicationsAreValid = UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
    };
    Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
      lexifyCount++;
      this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
      lexifyCount--;
    };
    Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
      for (let idx = 0; idx < this.terms.length; idx++) {
        this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
      }
    };
    Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
      for (let idx = 0; idx < this.factors.length; idx++) {
        this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
      }
    };
    Iter.prototype._assertAllApplicationsAreValid = Not.prototype._assertAllApplicationsAreValid = Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
      this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
    };
    Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2, skipSyntacticCheck = false) {
      const ruleInfo = grammar2.rules[this.ruleName];
      const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;
      if (!ruleInfo) {
        throw undeclaredRule(this.ruleName, grammar2.name, this.source);
      }
      if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {
        throw applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
      }
      const actual = this.args.length;
      const expected = ruleInfo.formals.length;
      if (actual !== expected) {
        throw wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
      }
      const isBuiltInApplySyntactic = BuiltInRules$1 && ruleInfo === BuiltInRules$1.rules.applySyntactic;
      const isBuiltInCaseInsensitive = BuiltInRules$1 && ruleInfo === BuiltInRules$1.rules.caseInsensitive;
      if (isBuiltInCaseInsensitive) {
        if (!(this.args[0] instanceof Terminal)) {
          throw incorrectArgumentType('a Terminal (e.g. "abc")', this.args[0]);
        }
      }
      if (isBuiltInApplySyntactic) {
        const arg = this.args[0];
        if (!(arg instanceof Apply)) {
          throw incorrectArgumentType("a syntactic rule application", arg);
        }
        if (!isSyntactic(arg.ruleName)) {
          throw applySyntacticWithLexicalRuleApplication(arg);
        }
        if (isContextSyntactic) {
          throw unnecessaryExperimentalApplySyntactic(this);
        }
      }
      this.args.forEach((arg) => {
        arg._assertAllApplicationsAreValid(ruleName, grammar2, isBuiltInApplySyntactic);
        if (arg.getArity() !== 1) {
          throw invalidParameter(this.ruleName, arg);
        }
      });
    };
    PExpr.prototype.assertChoicesHaveUniformArity = abstract(
      "assertChoicesHaveUniformArity"
    );
    any.assertChoicesHaveUniformArity = end.assertChoicesHaveUniformArity = Terminal.prototype.assertChoicesHaveUniformArity = Range.prototype.assertChoicesHaveUniformArity = Param.prototype.assertChoicesHaveUniformArity = Lex.prototype.assertChoicesHaveUniformArity = UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
    };
    Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
      if (this.terms.length === 0) {
        return;
      }
      const arity = this.terms[0].getArity();
      for (let idx = 0; idx < this.terms.length; idx++) {
        const term = this.terms[idx];
        term.assertChoicesHaveUniformArity();
        const otherArity = term.getArity();
        if (arity !== otherArity) {
          throw inconsistentArity(ruleName, arity, otherArity, term);
        }
      }
    };
    Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
      const actualArity = this.terms[0].getArity();
      const expectedArity = this.terms[1].getArity();
      if (actualArity !== expectedArity) {
        throw inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
      }
    };
    Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
      for (let idx = 0; idx < this.factors.length; idx++) {
        this.factors[idx].assertChoicesHaveUniformArity(ruleName);
      }
    };
    Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
      this.expr.assertChoicesHaveUniformArity(ruleName);
    };
    Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
    };
    Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
      this.expr.assertChoicesHaveUniformArity(ruleName);
    };
    Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
    };
    PExpr.prototype.assertIteratedExprsAreNotNullable = abstract(
      "assertIteratedExprsAreNotNullable"
    );
    any.assertIteratedExprsAreNotNullable = end.assertIteratedExprsAreNotNullable = Terminal.prototype.assertIteratedExprsAreNotNullable = Range.prototype.assertIteratedExprsAreNotNullable = Param.prototype.assertIteratedExprsAreNotNullable = UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
    };
    Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
      for (let idx = 0; idx < this.terms.length; idx++) {
        this.terms[idx].assertIteratedExprsAreNotNullable(grammar2);
      }
    };
    Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
      for (let idx = 0; idx < this.factors.length; idx++) {
        this.factors[idx].assertIteratedExprsAreNotNullable(grammar2);
      }
    };
    Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
      this.expr.assertIteratedExprsAreNotNullable(grammar2);
      if (this.expr.isNullable(grammar2)) {
        throw kleeneExprHasNullableOperand(this, []);
      }
    };
    Opt.prototype.assertIteratedExprsAreNotNullable = Not.prototype.assertIteratedExprsAreNotNullable = Lookahead.prototype.assertIteratedExprsAreNotNullable = Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
      this.expr.assertIteratedExprsAreNotNullable(grammar2);
    };
    Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
      this.args.forEach((arg) => {
        arg.assertIteratedExprsAreNotNullable(grammar2);
      });
    };
    var Node = class {
      constructor(matchLength) {
        this.matchLength = matchLength;
      }
      get ctorName() {
        throw new Error("subclass responsibility");
      }
      numChildren() {
        return this.children ? this.children.length : 0;
      }
      childAt(idx) {
        if (this.children) {
          return this.children[idx];
        }
      }
      indexOfChild(arg) {
        return this.children.indexOf(arg);
      }
      hasChildren() {
        return this.numChildren() > 0;
      }
      hasNoChildren() {
        return !this.hasChildren();
      }
      onlyChild() {
        if (this.numChildren() !== 1) {
          throw new Error(
            "cannot get only child of a node of type " + this.ctorName + " (it has " + this.numChildren() + " children)"
          );
        } else {
          return this.firstChild();
        }
      }
      firstChild() {
        if (this.hasNoChildren()) {
          throw new Error(
            "cannot get first child of a " + this.ctorName + " node, which has no children"
          );
        } else {
          return this.childAt(0);
        }
      }
      lastChild() {
        if (this.hasNoChildren()) {
          throw new Error(
            "cannot get last child of a " + this.ctorName + " node, which has no children"
          );
        } else {
          return this.childAt(this.numChildren() - 1);
        }
      }
      childBefore(child) {
        const childIdx = this.indexOfChild(child);
        if (childIdx < 0) {
          throw new Error("Node.childBefore() called w/ an argument that is not a child");
        } else if (childIdx === 0) {
          throw new Error("cannot get child before first child");
        } else {
          return this.childAt(childIdx - 1);
        }
      }
      childAfter(child) {
        const childIdx = this.indexOfChild(child);
        if (childIdx < 0) {
          throw new Error("Node.childAfter() called w/ an argument that is not a child");
        } else if (childIdx === this.numChildren() - 1) {
          throw new Error("cannot get child after last child");
        } else {
          return this.childAt(childIdx + 1);
        }
      }
      isTerminal() {
        return false;
      }
      isNonterminal() {
        return false;
      }
      isIteration() {
        return false;
      }
      isOptional() {
        return false;
      }
    };
    var TerminalNode = class extends Node {
      get ctorName() {
        return "_terminal";
      }
      isTerminal() {
        return true;
      }
      get primitiveValue() {
        throw new Error("The `primitiveValue` property was removed in Ohm v17.");
      }
    };
    var NonterminalNode = class extends Node {
      constructor(ruleName, children, childOffsets, matchLength) {
        super(matchLength);
        this.ruleName = ruleName;
        this.children = children;
        this.childOffsets = childOffsets;
      }
      get ctorName() {
        return this.ruleName;
      }
      isNonterminal() {
        return true;
      }
      isLexical() {
        return isLexical(this.ctorName);
      }
      isSyntactic() {
        return isSyntactic(this.ctorName);
      }
    };
    var IterationNode = class extends Node {
      constructor(children, childOffsets, matchLength, isOptional) {
        super(matchLength);
        this.children = children;
        this.childOffsets = childOffsets;
        this.optional = isOptional;
      }
      get ctorName() {
        return "_iter";
      }
      isIteration() {
        return true;
      }
      isOptional() {
        return this.optional;
      }
    };
    PExpr.prototype.eval = abstract("eval");
    any.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      const cp = inputStream.nextCodePoint();
      if (cp !== void 0) {
        state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);
        return true;
      } else {
        state.processFailure(origPos, this);
        return false;
      }
    };
    end.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      if (inputStream.atEnd()) {
        state.pushBinding(new TerminalNode(0), origPos);
        return true;
      } else {
        state.processFailure(origPos, this);
        return false;
      }
    };
    Terminal.prototype.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      if (!inputStream.matchString(this.obj)) {
        state.processFailure(origPos, this);
        return false;
      } else {
        state.pushBinding(new TerminalNode(this.obj.length), origPos);
        return true;
      }
    };
    Range.prototype.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();
      if (cp !== void 0 && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {
        state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);
        return true;
      } else {
        state.processFailure(origPos, this);
        return false;
      }
    };
    Param.prototype.eval = function(state) {
      return state.eval(state.currentApplication().args[this.index]);
    };
    Lex.prototype.eval = function(state) {
      state.enterLexifiedContext();
      const ans = state.eval(this.expr);
      state.exitLexifiedContext();
      return ans;
    };
    Alt.prototype.eval = function(state) {
      for (let idx = 0; idx < this.terms.length; idx++) {
        if (state.eval(this.terms[idx])) {
          return true;
        }
      }
      return false;
    };
    Seq.prototype.eval = function(state) {
      for (let idx = 0; idx < this.factors.length; idx++) {
        const factor = this.factors[idx];
        if (!state.eval(factor)) {
          return false;
        }
      }
      return true;
    };
    Iter.prototype.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      const arity = this.getArity();
      const cols = [];
      const colOffsets = [];
      while (cols.length < arity) {
        cols.push([]);
        colOffsets.push([]);
      }
      let numMatches = 0;
      let prevPos = origPos;
      let idx;
      while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
        if (inputStream.pos === prevPos) {
          throw kleeneExprHasNullableOperand(this, state._applicationStack);
        }
        prevPos = inputStream.pos;
        numMatches++;
        const row = state._bindings.splice(state._bindings.length - arity, arity);
        const rowOffsets = state._bindingOffsets.splice(
          state._bindingOffsets.length - arity,
          arity
        );
        for (idx = 0; idx < row.length; idx++) {
          cols[idx].push(row[idx]);
          colOffsets[idx].push(rowOffsets[idx]);
        }
      }
      if (numMatches < this.minNumMatches) {
        return false;
      }
      let offset = state.posToOffset(origPos);
      let matchLength = 0;
      if (numMatches > 0) {
        const lastCol = cols[arity - 1];
        const lastColOffsets = colOffsets[arity - 1];
        const endOffset = lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
        offset = colOffsets[0][0];
        matchLength = endOffset - offset;
      }
      const isOptional = this instanceof Opt;
      for (idx = 0; idx < cols.length; idx++) {
        state._bindings.push(
          new IterationNode(cols[idx], colOffsets[idx], matchLength, isOptional)
        );
        state._bindingOffsets.push(offset);
      }
      return true;
    };
    Not.prototype.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      state.pushFailuresInfo();
      const ans = state.eval(this.expr);
      state.popFailuresInfo();
      if (ans) {
        state.processFailure(origPos, this);
        return false;
      }
      inputStream.pos = origPos;
      return true;
    };
    Lookahead.prototype.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      if (state.eval(this.expr)) {
        inputStream.pos = origPos;
        return true;
      } else {
        return false;
      }
    };
    Apply.prototype.eval = function(state) {
      const caller = state.currentApplication();
      const actuals = caller ? caller.args : [];
      const app = this.substituteParams(actuals);
      const posInfo = state.getCurrentPosInfo();
      if (posInfo.isActive(app)) {
        return app.handleCycle(state);
      }
      const memoKey = app.toMemoKey();
      const memoRec = posInfo.memo[memoKey];
      if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
        if (state.hasNecessaryInfo(memoRec)) {
          return state.useMemoizedResult(state.inputStream.pos, memoRec);
        }
        delete posInfo.memo[memoKey];
      }
      return app.reallyEval(state);
    };
    Apply.prototype.handleCycle = function(state) {
      const posInfo = state.getCurrentPosInfo();
      const { currentLeftRecursion } = posInfo;
      const memoKey = this.toMemoKey();
      let memoRec = posInfo.memo[memoKey];
      if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
        memoRec.updateInvolvedApplicationMemoKeys();
      } else if (!memoRec) {
        memoRec = posInfo.memoize(memoKey, {
          matchLength: 0,
          examinedLength: 0,
          value: false,
          rightmostFailureOffset: -1
        });
        posInfo.startLeftRecursion(this, memoRec);
      }
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    };
    Apply.prototype.reallyEval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      const origPosInfo = state.getCurrentPosInfo();
      const ruleInfo = state.grammar.rules[this.ruleName];
      const { body } = ruleInfo;
      const { description } = ruleInfo;
      state.enterApplication(origPosInfo, this);
      if (description) {
        state.pushFailuresInfo();
      }
      const origInputStreamExaminedLength = inputStream.examinedLength;
      inputStream.examinedLength = 0;
      let value = this.evalOnce(body, state);
      const currentLR = origPosInfo.currentLeftRecursion;
      const memoKey = this.toMemoKey();
      const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
      let memoRec;
      if (state.doNotMemoize) {
        state.doNotMemoize = false;
      } else if (isHeadOfLeftRecursion) {
        value = this.growSeedResult(body, state, origPos, currentLR, value);
        origPosInfo.endLeftRecursion();
        memoRec = currentLR;
        memoRec.examinedLength = inputStream.examinedLength - origPos;
        memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
        origPosInfo.memoize(memoKey, memoRec);
      } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
        memoRec = origPosInfo.memoize(memoKey, {
          matchLength: inputStream.pos - origPos,
          examinedLength: inputStream.examinedLength - origPos,
          value,
          failuresAtRightmostPosition: state.cloneRecordedFailures(),
          rightmostFailureOffset: state._getRightmostFailureOffset()
        });
      }
      const succeeded = !!value;
      if (description) {
        state.popFailuresInfo();
        if (!succeeded) {
          state.processFailure(origPos, this);
        }
        if (memoRec) {
          memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
        }
      }
      if (state.isTracing() && memoRec) {
        const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
        if (isHeadOfLeftRecursion) {
          assert2(entry.terminatingLREntry != null || !succeeded);
          entry.isHeadOfLeftRecursion = true;
        }
        memoRec.traceEntry = entry;
      }
      inputStream.examinedLength = Math.max(
        inputStream.examinedLength,
        origInputStreamExaminedLength
      );
      state.exitApplication(origPosInfo, value);
      return succeeded;
    };
    Apply.prototype.evalOnce = function(expr, state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      if (state.eval(expr)) {
        const arity = expr.getArity();
        const bindings = state._bindings.splice(state._bindings.length - arity, arity);
        const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
        const matchLength = inputStream.pos - origPos;
        return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);
      } else {
        return false;
      }
    };
    Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
      if (!newValue) {
        return false;
      }
      const { inputStream } = state;
      while (true) {
        lrMemoRec.matchLength = inputStream.pos - origPos;
        lrMemoRec.value = newValue;
        lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
        if (state.isTracing()) {
          const seedTrace = state.trace[state.trace.length - 1];
          lrMemoRec.traceEntry = new Trace(
            state.input,
            origPos,
            inputStream.pos,
            this,
            true,
            [newValue],
            [seedTrace.clone()]
          );
        }
        inputStream.pos = origPos;
        newValue = this.evalOnce(body, state);
        if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
          break;
        }
        if (state.isTracing()) {
          state.trace.splice(-2, 1);
        }
      }
      if (state.isTracing()) {
        lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
      }
      inputStream.pos = origPos + lrMemoRec.matchLength;
      return lrMemoRec.value;
    };
    UnicodeChar.prototype.eval = function(state) {
      const { inputStream } = state;
      const origPos = inputStream.pos;
      const ch = inputStream.next();
      if (ch && this.pattern.test(ch)) {
        state.pushBinding(new TerminalNode(ch.length), origPos);
        return true;
      } else {
        state.processFailure(origPos, this);
        return false;
      }
    };
    PExpr.prototype.getArity = abstract("getArity");
    any.getArity = end.getArity = Terminal.prototype.getArity = Range.prototype.getArity = Param.prototype.getArity = Apply.prototype.getArity = UnicodeChar.prototype.getArity = function() {
      return 1;
    };
    Alt.prototype.getArity = function() {
      return this.terms.length === 0 ? 0 : this.terms[0].getArity();
    };
    Seq.prototype.getArity = function() {
      let arity = 0;
      for (let idx = 0; idx < this.factors.length; idx++) {
        arity += this.factors[idx].getArity();
      }
      return arity;
    };
    Iter.prototype.getArity = function() {
      return this.expr.getArity();
    };
    Not.prototype.getArity = function() {
      return 0;
    };
    Lookahead.prototype.getArity = Lex.prototype.getArity = function() {
      return this.expr.getArity();
    };
    function getMetaInfo(expr, grammarInterval) {
      const metaInfo = {};
      if (expr.source && grammarInterval) {
        const adjusted = expr.source.relativeTo(grammarInterval);
        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }
      return metaInfo;
    }
    PExpr.prototype.outputRecipe = abstract("outputRecipe");
    any.outputRecipe = function(formals, grammarInterval) {
      return ["any", getMetaInfo(this, grammarInterval)];
    };
    end.outputRecipe = function(formals, grammarInterval) {
      return ["end", getMetaInfo(this, grammarInterval)];
    };
    Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
      return ["terminal", getMetaInfo(this, grammarInterval), this.obj];
    };
    Range.prototype.outputRecipe = function(formals, grammarInterval) {
      return ["range", getMetaInfo(this, grammarInterval), this.from, this.to];
    };
    Param.prototype.outputRecipe = function(formals, grammarInterval) {
      return ["param", getMetaInfo(this, grammarInterval), this.index];
    };
    Alt.prototype.outputRecipe = function(formals, grammarInterval) {
      return ["alt", getMetaInfo(this, grammarInterval)].concat(
        this.terms.map((term) => term.outputRecipe(formals, grammarInterval))
      );
    };
    Extend.prototype.outputRecipe = function(formals, grammarInterval) {
      const extension = this.terms[0];
      return extension.outputRecipe(formals, grammarInterval);
    };
    Splice.prototype.outputRecipe = function(formals, grammarInterval) {
      const beforeTerms = this.terms.slice(0, this.expansionPos);
      const afterTerms = this.terms.slice(this.expansionPos + 1);
      return [
        "splice",
        getMetaInfo(this, grammarInterval),
        beforeTerms.map((term) => term.outputRecipe(formals, grammarInterval)),
        afterTerms.map((term) => term.outputRecipe(formals, grammarInterval))
      ];
    };
    Seq.prototype.outputRecipe = function(formals, grammarInterval) {
      return ["seq", getMetaInfo(this, grammarInterval)].concat(
        this.factors.map((factor) => factor.outputRecipe(formals, grammarInterval))
      );
    };
    Star.prototype.outputRecipe = Plus.prototype.outputRecipe = Opt.prototype.outputRecipe = Not.prototype.outputRecipe = Lookahead.prototype.outputRecipe = Lex.prototype.outputRecipe = function(formals, grammarInterval) {
      return [
        this.constructor.name.toLowerCase(),
        getMetaInfo(this, grammarInterval),
        this.expr.outputRecipe(formals, grammarInterval)
      ];
    };
    Apply.prototype.outputRecipe = function(formals, grammarInterval) {
      return [
        "app",
        getMetaInfo(this, grammarInterval),
        this.ruleName,
        this.args.map((arg) => arg.outputRecipe(formals, grammarInterval))
      ];
    };
    UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
      return ["unicodeChar", getMetaInfo(this, grammarInterval), this.category];
    };
    PExpr.prototype.introduceParams = abstract("introduceParams");
    any.introduceParams = end.introduceParams = Terminal.prototype.introduceParams = Range.prototype.introduceParams = Param.prototype.introduceParams = UnicodeChar.prototype.introduceParams = function(formals) {
      return this;
    };
    Alt.prototype.introduceParams = function(formals) {
      this.terms.forEach((term, idx, terms) => {
        terms[idx] = term.introduceParams(formals);
      });
      return this;
    };
    Seq.prototype.introduceParams = function(formals) {
      this.factors.forEach((factor, idx, factors) => {
        factors[idx] = factor.introduceParams(formals);
      });
      return this;
    };
    Iter.prototype.introduceParams = Not.prototype.introduceParams = Lookahead.prototype.introduceParams = Lex.prototype.introduceParams = function(formals) {
      this.expr = this.expr.introduceParams(formals);
      return this;
    };
    Apply.prototype.introduceParams = function(formals) {
      const index = formals.indexOf(this.ruleName);
      if (index >= 0) {
        if (this.args.length > 0) {
          throw new Error("Parameterized rules cannot be passed as arguments to another rule.");
        }
        return new Param(index).withSource(this.source);
      } else {
        this.args.forEach((arg, idx, args) => {
          args[idx] = arg.introduceParams(formals);
        });
        return this;
      }
    };
    PExpr.prototype.isNullable = function(grammar2) {
      return this._isNullable(grammar2, /* @__PURE__ */ Object.create(null));
    };
    PExpr.prototype._isNullable = abstract("_isNullable");
    any._isNullable = Range.prototype._isNullable = Param.prototype._isNullable = Plus.prototype._isNullable = UnicodeChar.prototype._isNullable = function(grammar2, memo) {
      return false;
    };
    end._isNullable = function(grammar2, memo) {
      return true;
    };
    Terminal.prototype._isNullable = function(grammar2, memo) {
      if (typeof this.obj === "string") {
        return this.obj === "";
      } else {
        return false;
      }
    };
    Alt.prototype._isNullable = function(grammar2, memo) {
      return this.terms.length === 0 || this.terms.some((term) => term._isNullable(grammar2, memo));
    };
    Seq.prototype._isNullable = function(grammar2, memo) {
      return this.factors.every((factor) => factor._isNullable(grammar2, memo));
    };
    Star.prototype._isNullable = Opt.prototype._isNullable = Not.prototype._isNullable = Lookahead.prototype._isNullable = function(grammar2, memo) {
      return true;
    };
    Lex.prototype._isNullable = function(grammar2, memo) {
      return this.expr._isNullable(grammar2, memo);
    };
    Apply.prototype._isNullable = function(grammar2, memo) {
      const key = this.toMemoKey();
      if (!Object.prototype.hasOwnProperty.call(memo, key)) {
        const { body } = grammar2.rules[this.ruleName];
        const inlined = body.substituteParams(this.args);
        memo[key] = false;
        memo[key] = inlined._isNullable(grammar2, memo);
      }
      return memo[key];
    };
    PExpr.prototype.substituteParams = abstract("substituteParams");
    any.substituteParams = end.substituteParams = Terminal.prototype.substituteParams = Range.prototype.substituteParams = UnicodeChar.prototype.substituteParams = function(actuals) {
      return this;
    };
    Param.prototype.substituteParams = function(actuals) {
      return checkNotNull(actuals[this.index]);
    };
    Alt.prototype.substituteParams = function(actuals) {
      return new Alt(this.terms.map((term) => term.substituteParams(actuals)));
    };
    Seq.prototype.substituteParams = function(actuals) {
      return new Seq(this.factors.map((factor) => factor.substituteParams(actuals)));
    };
    Iter.prototype.substituteParams = Not.prototype.substituteParams = Lookahead.prototype.substituteParams = Lex.prototype.substituteParams = function(actuals) {
      return new this.constructor(this.expr.substituteParams(actuals));
    };
    Apply.prototype.substituteParams = function(actuals) {
      if (this.args.length === 0) {
        return this;
      } else {
        const args = this.args.map((arg) => arg.substituteParams(actuals));
        return new Apply(this.ruleName, args);
      }
    };
    function isRestrictedJSIdentifier(str2) {
      return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str2);
    }
    function resolveDuplicatedNames(argumentNameList) {
      const count = /* @__PURE__ */ Object.create(null);
      argumentNameList.forEach((argName) => {
        count[argName] = (count[argName] || 0) + 1;
      });
      Object.keys(count).forEach((dupArgName) => {
        if (count[dupArgName] <= 1) {
          return;
        }
        let subscript = 1;
        argumentNameList.forEach((argName, idx) => {
          if (argName === dupArgName) {
            argumentNameList[idx] = argName + "_" + subscript++;
          }
        });
      });
    }
    PExpr.prototype.toArgumentNameList = abstract("toArgumentNameList");
    any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return ["any"];
    };
    end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return ["end"];
    };
    Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      if (typeof this.obj === "string" && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
        return ["_" + this.obj];
      } else {
        return ["$" + firstArgIndex];
      }
    };
    Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      let argName = this.from + "_to_" + this.to;
      if (!isRestrictedJSIdentifier(argName)) {
        argName = "_" + argName;
      }
      if (!isRestrictedJSIdentifier(argName)) {
        argName = "$" + firstArgIndex;
      }
      return [argName];
    };
    Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      const termArgNameLists = this.terms.map(
        (term) => term.toArgumentNameList(firstArgIndex, true)
      );
      const argumentNameList = [];
      const numArgs = termArgNameLists[0].length;
      for (let colIdx = 0; colIdx < numArgs; colIdx++) {
        const col = [];
        for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
          col.push(termArgNameLists[rowIdx][colIdx]);
        }
        const uniqueNames = copyWithoutDuplicates(col);
        argumentNameList.push(uniqueNames.join("_or_"));
      }
      if (!noDupCheck) {
        resolveDuplicatedNames(argumentNameList);
      }
      return argumentNameList;
    };
    Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      let argumentNameList = [];
      this.factors.forEach((factor) => {
        const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
        argumentNameList = argumentNameList.concat(factorArgumentNameList);
        firstArgIndex += factorArgumentNameList.length;
      });
      if (!noDupCheck) {
        resolveDuplicatedNames(argumentNameList);
      }
      return argumentNameList;
    };
    Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(
        (exprArgumentString) => exprArgumentString[exprArgumentString.length - 1] === "s" ? exprArgumentString + "es" : exprArgumentString + "s"
      );
      if (!noDupCheck) {
        resolveDuplicatedNames(argumentNameList);
      }
      return argumentNameList;
    };
    Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map((argName) => {
        return "opt" + argName[0].toUpperCase() + argName.slice(1);
      });
    };
    Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return [];
    };
    Lookahead.prototype.toArgumentNameList = Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
    };
    Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return [this.ruleName];
    };
    UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return ["$" + firstArgIndex];
    };
    Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
      return ["param" + this.index];
    };
    PExpr.prototype.toDisplayString = abstract("toDisplayString");
    Alt.prototype.toDisplayString = Seq.prototype.toDisplayString = function() {
      if (this.source) {
        return this.source.trimmed().contents;
      }
      return "[" + this.constructor.name + "]";
    };
    any.toDisplayString = end.toDisplayString = Iter.prototype.toDisplayString = Not.prototype.toDisplayString = Lookahead.prototype.toDisplayString = Lex.prototype.toDisplayString = Terminal.prototype.toDisplayString = Range.prototype.toDisplayString = Param.prototype.toDisplayString = function() {
      return this.toString();
    };
    Apply.prototype.toDisplayString = function() {
      if (this.args.length > 0) {
        const ps = this.args.map((arg) => arg.toDisplayString());
        return this.ruleName + "<" + ps.join(",") + ">";
      } else {
        return this.ruleName;
      }
    };
    UnicodeChar.prototype.toDisplayString = function() {
      return "Unicode [" + this.category + "] character";
    };
    function isValidType(type2) {
      return type2 === "description" || type2 === "string" || type2 === "code";
    }
    var Failure = class _Failure {
      constructor(pexpr, text, type2) {
        if (!isValidType(type2)) {
          throw new Error("invalid Failure type: " + type2);
        }
        this.pexpr = pexpr;
        this.text = text;
        this.type = type2;
        this.fluffy = false;
      }
      getPExpr() {
        return this.pexpr;
      }
      getText() {
        return this.text;
      }
      getType() {
        return this.type;
      }
      isDescription() {
        return this.type === "description";
      }
      isStringTerminal() {
        return this.type === "string";
      }
      isCode() {
        return this.type === "code";
      }
      isFluffy() {
        return this.fluffy;
      }
      makeFluffy() {
        this.fluffy = true;
      }
      clearFluffy() {
        this.fluffy = false;
      }
      subsumes(that) {
        return this.getText() === that.getText() && this.type === that.type && (!this.isFluffy() || this.isFluffy() && that.isFluffy());
      }
      toString() {
        return this.type === "string" ? JSON.stringify(this.getText()) : this.getText();
      }
      clone() {
        const failure = new _Failure(this.pexpr, this.text, this.type);
        if (this.isFluffy()) {
          failure.makeFluffy();
        }
        return failure;
      }
      toKey() {
        return this.toString() + "#" + this.type;
      }
    };
    PExpr.prototype.toFailure = abstract("toFailure");
    any.toFailure = function(grammar2) {
      return new Failure(this, "any object", "description");
    };
    end.toFailure = function(grammar2) {
      return new Failure(this, "end of input", "description");
    };
    Terminal.prototype.toFailure = function(grammar2) {
      return new Failure(this, this.obj, "string");
    };
    Range.prototype.toFailure = function(grammar2) {
      return new Failure(this, JSON.stringify(this.from) + ".." + JSON.stringify(this.to), "code");
    };
    Not.prototype.toFailure = function(grammar2) {
      const description = this.expr === any ? "nothing" : "not " + this.expr.toFailure(grammar2);
      return new Failure(this, description, "description");
    };
    Lookahead.prototype.toFailure = function(grammar2) {
      return this.expr.toFailure(grammar2);
    };
    Apply.prototype.toFailure = function(grammar2) {
      let { description } = grammar2.rules[this.ruleName];
      if (!description) {
        const article = /^[aeiouAEIOU]/.test(this.ruleName) ? "an" : "a";
        description = article + " " + this.ruleName;
      }
      return new Failure(this, description, "description");
    };
    UnicodeChar.prototype.toFailure = function(grammar2) {
      return new Failure(this, "a Unicode [" + this.category + "] character", "description");
    };
    Alt.prototype.toFailure = function(grammar2) {
      const fs5 = this.terms.map((t) => t.toFailure(grammar2));
      const description = "(" + fs5.join(" or ") + ")";
      return new Failure(this, description, "description");
    };
    Seq.prototype.toFailure = function(grammar2) {
      const fs5 = this.factors.map((f) => f.toFailure(grammar2));
      const description = "(" + fs5.join(" ") + ")";
      return new Failure(this, description, "description");
    };
    Iter.prototype.toFailure = function(grammar2) {
      const description = "(" + this.expr.toFailure(grammar2) + this.operator + ")";
      return new Failure(this, description, "description");
    };
    PExpr.prototype.toString = abstract("toString");
    any.toString = function() {
      return "any";
    };
    end.toString = function() {
      return "end";
    };
    Terminal.prototype.toString = function() {
      return JSON.stringify(this.obj);
    };
    Range.prototype.toString = function() {
      return JSON.stringify(this.from) + ".." + JSON.stringify(this.to);
    };
    Param.prototype.toString = function() {
      return "$" + this.index;
    };
    Lex.prototype.toString = function() {
      return "#(" + this.expr.toString() + ")";
    };
    Alt.prototype.toString = function() {
      return this.terms.length === 1 ? this.terms[0].toString() : "(" + this.terms.map((term) => term.toString()).join(" | ") + ")";
    };
    Seq.prototype.toString = function() {
      return this.factors.length === 1 ? this.factors[0].toString() : "(" + this.factors.map((factor) => factor.toString()).join(" ") + ")";
    };
    Iter.prototype.toString = function() {
      return this.expr + this.operator;
    };
    Not.prototype.toString = function() {
      return "~" + this.expr;
    };
    Lookahead.prototype.toString = function() {
      return "&" + this.expr;
    };
    Apply.prototype.toString = function() {
      if (this.args.length > 0) {
        const ps = this.args.map((arg) => arg.toString());
        return this.ruleName + "<" + ps.join(",") + ">";
      } else {
        return this.ruleName;
      }
    };
    UnicodeChar.prototype.toString = function() {
      return "\\p{" + this.category + "}";
    };
    var CaseInsensitiveTerminal = class _CaseInsensitiveTerminal extends PExpr {
      constructor(param) {
        super();
        this.obj = param;
      }
      _getString(state) {
        const terminal = state.currentApplication().args[this.obj.index];
        assert2(terminal instanceof Terminal, "expected a Terminal expression");
        return terminal.obj;
      }
      // Implementation of the PExpr API
      allowsSkippingPrecedingSpace() {
        return true;
      }
      eval(state) {
        const { inputStream } = state;
        const origPos = inputStream.pos;
        const matchStr = this._getString(state);
        if (!inputStream.matchString(matchStr, true)) {
          state.processFailure(origPos, this);
          return false;
        } else {
          state.pushBinding(new TerminalNode(matchStr.length), origPos);
          return true;
        }
      }
      getArity() {
        return 1;
      }
      substituteParams(actuals) {
        return new _CaseInsensitiveTerminal(this.obj.substituteParams(actuals));
      }
      toDisplayString() {
        return this.obj.toDisplayString() + " (case-insensitive)";
      }
      toFailure(grammar2) {
        return new Failure(
          this,
          this.obj.toFailure(grammar2) + " (case-insensitive)",
          "description"
        );
      }
      _isNullable(grammar2, memo) {
        return this.obj._isNullable(grammar2, memo);
      }
    };
    var pexprs = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      CaseInsensitiveTerminal,
      PExpr,
      any,
      end,
      Terminal,
      Range,
      Param,
      Alt,
      Extend,
      Splice,
      Seq,
      Iter,
      Star,
      Plus,
      Opt,
      Not,
      Lookahead,
      Lex,
      Apply,
      UnicodeChar
    });
    var builtInApplySyntacticBody;
    awaitBuiltInRules((builtInRules) => {
      builtInApplySyntacticBody = builtInRules.rules.applySyntactic.body;
    });
    var applySpaces = new Apply("spaces");
    var MatchState = class {
      constructor(matcher, startExpr, optPositionToRecordFailures) {
        this.matcher = matcher;
        this.startExpr = startExpr;
        this.grammar = matcher.grammar;
        this.input = matcher.getInput();
        this.inputStream = new InputStream(this.input);
        this.memoTable = matcher._memoTable;
        this.userData = void 0;
        this.doNotMemoize = false;
        this._bindings = [];
        this._bindingOffsets = [];
        this._applicationStack = [];
        this._posStack = [0];
        this.inLexifiedContextStack = [false];
        this.rightmostFailurePosition = -1;
        this._rightmostFailurePositionStack = [];
        this._recordedFailuresStack = [];
        if (optPositionToRecordFailures !== void 0) {
          this.positionToRecordFailures = optPositionToRecordFailures;
          this.recordedFailures = /* @__PURE__ */ Object.create(null);
        }
      }
      posToOffset(pos) {
        return pos - this._posStack[this._posStack.length - 1];
      }
      enterApplication(posInfo, app) {
        this._posStack.push(this.inputStream.pos);
        this._applicationStack.push(app);
        this.inLexifiedContextStack.push(false);
        posInfo.enter(app);
        this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
        this.rightmostFailurePosition = -1;
      }
      exitApplication(posInfo, optNode) {
        const origPos = this._posStack.pop();
        this._applicationStack.pop();
        this.inLexifiedContextStack.pop();
        posInfo.exit();
        this.rightmostFailurePosition = Math.max(
          this.rightmostFailurePosition,
          this._rightmostFailurePositionStack.pop()
        );
        if (optNode) {
          this.pushBinding(optNode, origPos);
        }
      }
      enterLexifiedContext() {
        this.inLexifiedContextStack.push(true);
      }
      exitLexifiedContext() {
        this.inLexifiedContextStack.pop();
      }
      currentApplication() {
        return this._applicationStack[this._applicationStack.length - 1];
      }
      inSyntacticContext() {
        const currentApplication = this.currentApplication();
        if (currentApplication) {
          return currentApplication.isSyntactic() && !this.inLexifiedContext();
        } else {
          return this.startExpr.factors[0].isSyntactic();
        }
      }
      inLexifiedContext() {
        return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
      }
      skipSpaces() {
        this.pushFailuresInfo();
        this.eval(applySpaces);
        this.popBinding();
        this.popFailuresInfo();
        return this.inputStream.pos;
      }
      skipSpacesIfInSyntacticContext() {
        return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;
      }
      maybeSkipSpacesBefore(expr) {
        if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
          return this.skipSpacesIfInSyntacticContext();
        } else {
          return this.inputStream.pos;
        }
      }
      pushBinding(node, origPos) {
        this._bindings.push(node);
        this._bindingOffsets.push(this.posToOffset(origPos));
      }
      popBinding() {
        this._bindings.pop();
        this._bindingOffsets.pop();
      }
      numBindings() {
        return this._bindings.length;
      }
      truncateBindings(newLength) {
        while (this._bindings.length > newLength) {
          this.popBinding();
        }
      }
      getCurrentPosInfo() {
        return this.getPosInfo(this.inputStream.pos);
      }
      getPosInfo(pos) {
        let posInfo = this.memoTable[pos];
        if (!posInfo) {
          posInfo = this.memoTable[pos] = new PosInfo();
        }
        return posInfo;
      }
      processFailure(pos, expr) {
        this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);
        if (this.recordedFailures && pos === this.positionToRecordFailures) {
          const app = this.currentApplication();
          if (app) {
            expr = expr.substituteParams(app.args);
          }
          this.recordFailure(expr.toFailure(this.grammar), false);
        }
      }
      recordFailure(failure, shouldCloneIfNew) {
        const key = failure.toKey();
        if (!this.recordedFailures[key]) {
          this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
        } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {
          this.recordedFailures[key].clearFluffy();
        }
      }
      recordFailures(failures, shouldCloneIfNew) {
        Object.keys(failures).forEach((key) => {
          this.recordFailure(failures[key], shouldCloneIfNew);
        });
      }
      cloneRecordedFailures() {
        if (!this.recordedFailures) {
          return void 0;
        }
        const ans = /* @__PURE__ */ Object.create(null);
        Object.keys(this.recordedFailures).forEach((key) => {
          ans[key] = this.recordedFailures[key].clone();
        });
        return ans;
      }
      getRightmostFailurePosition() {
        return this.rightmostFailurePosition;
      }
      _getRightmostFailureOffset() {
        return this.rightmostFailurePosition >= 0 ? this.posToOffset(this.rightmostFailurePosition) : -1;
      }
      // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
      getMemoizedTraceEntry(pos, expr) {
        const posInfo = this.memoTable[pos];
        if (posInfo && expr instanceof Apply) {
          const memoRec = posInfo.memo[expr.toMemoKey()];
          if (memoRec && memoRec.traceEntry) {
            const entry = memoRec.traceEntry.cloneWithExpr(expr);
            entry.isMemoized = true;
            return entry;
          }
        }
        return null;
      }
      // Returns a new trace entry, with the currently active trace array as its children.
      getTraceEntry(pos, expr, succeeded, bindings) {
        if (expr instanceof Apply) {
          const app = this.currentApplication();
          const actuals = app ? app.args : [];
          expr = expr.substituteParams(actuals);
        }
        return this.getMemoizedTraceEntry(pos, expr) || new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
      }
      isTracing() {
        return !!this.trace;
      }
      hasNecessaryInfo(memoRec) {
        if (this.trace && !memoRec.traceEntry) {
          return false;
        }
        if (this.recordedFailures && this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
          return !!memoRec.failuresAtRightmostPosition;
        }
        return true;
      }
      useMemoizedResult(origPos, memoRec) {
        if (this.trace) {
          this.trace.push(memoRec.traceEntry);
        }
        const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
        this.rightmostFailurePosition = Math.max(
          this.rightmostFailurePosition,
          memoRecRightmostFailurePosition
        );
        if (this.recordedFailures && this.positionToRecordFailures === memoRecRightmostFailurePosition && memoRec.failuresAtRightmostPosition) {
          this.recordFailures(memoRec.failuresAtRightmostPosition, true);
        }
        this.inputStream.examinedLength = Math.max(
          this.inputStream.examinedLength,
          memoRec.examinedLength + origPos
        );
        if (memoRec.value) {
          this.inputStream.pos += memoRec.matchLength;
          this.pushBinding(memoRec.value, origPos);
          return true;
        }
        return false;
      }
      // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
      // will have `expr.getArity()` more elements than before, and the input stream's position may
      // have increased. On failure, `bindings` and position will be unchanged.
      eval(expr) {
        const { inputStream } = this;
        const origNumBindings = this._bindings.length;
        const origUserData = this.userData;
        let origRecordedFailures;
        if (this.recordedFailures) {
          origRecordedFailures = this.recordedFailures;
          this.recordedFailures = /* @__PURE__ */ Object.create(null);
        }
        const origPos = inputStream.pos;
        const memoPos = this.maybeSkipSpacesBefore(expr);
        let origTrace;
        if (this.trace) {
          origTrace = this.trace;
          this.trace = [];
        }
        const ans = expr.eval(this);
        if (this.trace) {
          const bindings = this._bindings.slice(origNumBindings);
          const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
          traceEntry.isImplicitSpaces = expr === applySpaces;
          traceEntry.isRootNode = expr === this.startExpr;
          origTrace.push(traceEntry);
          this.trace = origTrace;
        }
        if (ans) {
          if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
            Object.keys(this.recordedFailures).forEach((key) => {
              this.recordedFailures[key].makeFluffy();
            });
          }
        } else {
          inputStream.pos = origPos;
          this.truncateBindings(origNumBindings);
          this.userData = origUserData;
        }
        if (this.recordedFailures) {
          this.recordFailures(origRecordedFailures, false);
        }
        if (expr === builtInApplySyntacticBody) {
          this.skipSpaces();
        }
        return ans;
      }
      getMatchResult() {
        this.grammar._setUpMatchState(this);
        this.eval(this.startExpr);
        let rightmostFailures;
        if (this.recordedFailures) {
          rightmostFailures = Object.keys(this.recordedFailures).map(
            (key) => this.recordedFailures[key]
          );
        }
        const cst = this._bindings[0];
        if (cst) {
          cst.grammar = this.grammar;
        }
        return new MatchResult(
          this.matcher,
          this.input,
          this.startExpr,
          cst,
          this._bindingOffsets[0],
          this.rightmostFailurePosition,
          rightmostFailures
        );
      }
      getTrace() {
        this.trace = [];
        const matchResult = this.getMatchResult();
        const rootTrace = this.trace[this.trace.length - 1];
        rootTrace.result = matchResult;
        return rootTrace;
      }
      pushFailuresInfo() {
        this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
        this._recordedFailuresStack.push(this.recordedFailures);
      }
      popFailuresInfo() {
        this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
        this.recordedFailures = this._recordedFailuresStack.pop();
      }
    };
    var Matcher = class {
      constructor(grammar2) {
        this.grammar = grammar2;
        this._memoTable = [];
        this._input = "";
        this._isMemoTableStale = false;
      }
      _resetMemoTable() {
        this._memoTable = [];
        this._isMemoTableStale = false;
      }
      getInput() {
        return this._input;
      }
      setInput(str2) {
        if (this._input !== str2) {
          this.replaceInputRange(0, this._input.length, str2);
        }
        return this;
      }
      replaceInputRange(startIdx, endIdx, str2) {
        const prevInput = this._input;
        const memoTable = this._memoTable;
        if (startIdx < 0 || startIdx > prevInput.length || endIdx < 0 || endIdx > prevInput.length || startIdx > endIdx) {
          throw new Error("Invalid indices: " + startIdx + " and " + endIdx);
        }
        this._input = prevInput.slice(0, startIdx) + str2 + prevInput.slice(endIdx);
        if (this._input !== prevInput && memoTable.length > 0) {
          this._isMemoTableStale = true;
        }
        const restOfMemoTable = memoTable.slice(endIdx);
        memoTable.length = startIdx;
        for (let idx = 0; idx < str2.length; idx++) {
          memoTable.push(void 0);
        }
        for (const posInfo of restOfMemoTable) {
          memoTable.push(posInfo);
        }
        for (let pos = 0; pos < startIdx; pos++) {
          const posInfo = memoTable[pos];
          if (posInfo) {
            posInfo.clearObsoleteEntries(pos, startIdx);
          }
        }
        return this;
      }
      match(optStartApplicationStr, options = { incremental: true }) {
        return this._match(this._getStartExpr(optStartApplicationStr), {
          incremental: options.incremental,
          tracing: false
        });
      }
      trace(optStartApplicationStr, options = { incremental: true }) {
        return this._match(this._getStartExpr(optStartApplicationStr), {
          incremental: options.incremental,
          tracing: true
        });
      }
      _match(startExpr, options = {}) {
        const opts = {
          tracing: false,
          incremental: true,
          positionToRecordFailures: void 0,
          ...options
        };
        if (!opts.incremental) {
          this._resetMemoTable();
        } else if (this._isMemoTableStale && !this.grammar.supportsIncrementalParsing) {
          throw grammarDoesNotSupportIncrementalParsing(this.grammar);
        }
        const state = new MatchState(this, startExpr, opts.positionToRecordFailures);
        return opts.tracing ? state.getTrace() : state.getMatchResult();
      }
      /*
        Returns the starting expression for this Matcher's associated grammar. If
        `optStartApplicationStr` is specified, it is a string expressing a rule application in the
        grammar. If not specified, the grammar's default start rule will be used.
      */
      _getStartExpr(optStartApplicationStr) {
        const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
        if (!applicationStr) {
          throw new Error("Missing start rule argument -- the grammar has no default start rule.");
        }
        const startApp = this.grammar.parseApplication(applicationStr);
        return new Seq([startApp, end]);
      }
    };
    var globalActionStack = [];
    var hasOwnProperty = (x, prop) => Object.prototype.hasOwnProperty.call(x, prop);
    var Wrapper = class {
      constructor(node, sourceInterval, baseInterval) {
        this._node = node;
        this.source = sourceInterval;
        this._baseInterval = baseInterval;
        if (node.isNonterminal()) {
          assert2(sourceInterval === baseInterval);
        }
        this._childWrappers = [];
      }
      _forgetMemoizedResultFor(attributeName) {
        delete this._node[this._semantics.attributeKeys[attributeName]];
        this.children.forEach((child) => {
          child._forgetMemoizedResultFor(attributeName);
        });
      }
      // Returns the wrapper of the specified child node. Child wrappers are created lazily and
      // cached in the parent wrapper's `_childWrappers` instance variable.
      child(idx) {
        if (!(0 <= idx && idx < this._node.numChildren())) {
          return void 0;
        }
        let childWrapper = this._childWrappers[idx];
        if (!childWrapper) {
          const childNode = this._node.childAt(idx);
          const offset = this._node.childOffsets[idx];
          const source = this._baseInterval.subInterval(offset, childNode.matchLength);
          const base = childNode.isNonterminal() ? source : this._baseInterval;
          childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
        }
        return childWrapper;
      }
      // Returns an array containing the wrappers of all of the children of the node associated
      // with this wrapper.
      _children() {
        for (let idx = 0; idx < this._node.numChildren(); idx++) {
          this.child(idx);
        }
        return this._childWrappers;
      }
      // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
      // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
      isIteration() {
        return this._node.isIteration();
      }
      // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
      // otherwise.
      isTerminal() {
        return this._node.isTerminal();
      }
      // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
      // otherwise.
      isNonterminal() {
        return this._node.isNonterminal();
      }
      // Returns `true` if the CST node associated with this wrapper is a nonterminal node
      // corresponding to a syntactic rule, `false` otherwise.
      isSyntactic() {
        return this.isNonterminal() && this._node.isSyntactic();
      }
      // Returns `true` if the CST node associated with this wrapper is a nonterminal node
      // corresponding to a lexical rule, `false` otherwise.
      isLexical() {
        return this.isNonterminal() && this._node.isLexical();
      }
      // Returns `true` if the CST node associated with this wrapper is an iterator node
      // having either one or no child (? operator), `false` otherwise.
      // Otherwise, throws an exception.
      isOptional() {
        return this._node.isOptional();
      }
      // Create a new _iter wrapper in the same semantics as this wrapper.
      iteration(optChildWrappers) {
        const childWrappers = optChildWrappers || [];
        const childNodes = childWrappers.map((c) => c._node);
        const iter = new IterationNode(childNodes, [], -1, false);
        const wrapper = this._semantics.wrap(iter, null, null);
        wrapper._childWrappers = childWrappers;
        return wrapper;
      }
      // Returns an array containing the children of this CST node.
      get children() {
        return this._children();
      }
      // Returns the name of grammar rule that created this CST node.
      get ctorName() {
        return this._node.ctorName;
      }
      // Returns the number of children of this CST node.
      get numChildren() {
        return this._node.numChildren();
      }
      // Returns the contents of the input stream consumed by this CST node.
      get sourceString() {
        return this.source.contents;
      }
    };
    var Semantics = class _Semantics {
      constructor(grammar2, superSemantics) {
        const self = this;
        this.grammar = grammar2;
        this.checkedActionDicts = false;
        this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
          constructor(node, sourceInterval, baseInterval) {
            super(node, sourceInterval, baseInterval);
            self.checkActionDictsIfHaventAlready();
            this._semantics = self;
          }
          toString() {
            return "[semantics wrapper for " + self.grammar.name + "]";
          }
        };
        this.super = superSemantics;
        if (superSemantics) {
          if (!(grammar2.equals(this.super.grammar) || grammar2._inheritsFrom(this.super.grammar))) {
            throw new Error(
              "Cannot extend a semantics for grammar '" + this.super.grammar.name + "' for use with grammar '" + grammar2.name + "' (not a sub-grammar)"
            );
          }
          this.operations = Object.create(this.super.operations);
          this.attributes = Object.create(this.super.attributes);
          this.attributeKeys = /* @__PURE__ */ Object.create(null);
          for (const attributeName in this.attributes) {
            Object.defineProperty(this.attributeKeys, attributeName, {
              value: uniqueId(attributeName)
            });
          }
        } else {
          this.operations = /* @__PURE__ */ Object.create(null);
          this.attributes = /* @__PURE__ */ Object.create(null);
          this.attributeKeys = /* @__PURE__ */ Object.create(null);
        }
      }
      toString() {
        return "[semantics for " + this.grammar.name + "]";
      }
      checkActionDictsIfHaventAlready() {
        if (!this.checkedActionDicts) {
          this.checkActionDicts();
          this.checkedActionDicts = true;
        }
      }
      // Checks that the action dictionaries for all operations and attributes in this semantics,
      // including the ones that were inherited from the super-semantics, agree with the grammar.
      // Throws an exception if one or more of them doesn't.
      checkActionDicts() {
        let name;
        for (name in this.operations) {
          this.operations[name].checkActionDict(this.grammar);
        }
        for (name in this.attributes) {
          this.attributes[name].checkActionDict(this.grammar);
        }
      }
      toRecipe(semanticsOnly) {
        function hasSuperSemantics(s) {
          return s.super !== _Semantics.BuiltInSemantics._getSemantics();
        }
        let str2 = "(function(g) {\n";
        if (hasSuperSemantics(this)) {
          str2 += "  var semantics = " + this.super.toRecipe(true) + "(g";
          const superSemanticsGrammar = this.super.grammar;
          let relatedGrammar = this.grammar;
          while (relatedGrammar !== superSemanticsGrammar) {
            str2 += ".superGrammar";
            relatedGrammar = relatedGrammar.superGrammar;
          }
          str2 += ");\n";
          str2 += "  return g.extendSemantics(semantics)";
        } else {
          str2 += "  return g.createSemantics()";
        }
        ["Operation", "Attribute"].forEach((type2) => {
          const semanticOperations = this[type2.toLowerCase() + "s"];
          Object.keys(semanticOperations).forEach((name) => {
            const { actionDict, formals, builtInDefault } = semanticOperations[name];
            let signature = name;
            if (formals.length > 0) {
              signature += "(" + formals.join(", ") + ")";
            }
            let method;
            if (hasSuperSemantics(this) && this.super[type2.toLowerCase() + "s"][name]) {
              method = "extend" + type2;
            } else {
              method = "add" + type2;
            }
            str2 += "\n    ." + method + "(" + JSON.stringify(signature) + ", {";
            const srcArray = [];
            Object.keys(actionDict).forEach((actionName) => {
              if (actionDict[actionName] !== builtInDefault) {
                let source = actionDict[actionName].toString().trim();
                source = source.replace(/^.*\(/, "function(");
                srcArray.push("\n      " + JSON.stringify(actionName) + ": " + source);
              }
            });
            str2 += srcArray.join(",") + "\n    })";
          });
        });
        str2 += ";\n  })";
        if (!semanticsOnly) {
          str2 = "(function() {\n  var grammar = this.fromRecipe(" + this.grammar.toRecipe() + ");\n  var semantics = " + str2 + "(grammar);\n  return semantics;\n});\n";
        }
        return str2;
      }
      addOperationOrAttribute(type2, signature, actionDict) {
        const typePlural = type2 + "s";
        const parsedNameAndFormalArgs = parseSignature(signature, type2);
        const { name } = parsedNameAndFormalArgs;
        const { formals } = parsedNameAndFormalArgs;
        this.assertNewName(name, type2);
        const builtInDefault = newDefaultAction(type2, name, doIt);
        const realActionDict = { _default: builtInDefault };
        Object.keys(actionDict).forEach((name2) => {
          realActionDict[name2] = actionDict[name2];
        });
        const entry = type2 === "operation" ? new Operation(name, formals, realActionDict, builtInDefault) : new Attribute(name, realActionDict, builtInDefault);
        entry.checkActionDict(this.grammar);
        this[typePlural][name] = entry;
        function doIt(...args) {
          const thisThing = this._semantics[typePlural][name];
          if (arguments.length !== thisThing.formals.length) {
            throw new Error(
              "Invalid number of arguments passed to " + name + " " + type2 + " (expected " + thisThing.formals.length + ", got " + arguments.length + ")"
            );
          }
          const argsObj = /* @__PURE__ */ Object.create(null);
          for (const [idx, val] of Object.entries(args)) {
            const formal = thisThing.formals[idx];
            argsObj[formal] = val;
          }
          const oldArgs = this.args;
          this.args = argsObj;
          const ans = thisThing.execute(this._semantics, this);
          this.args = oldArgs;
          return ans;
        }
        if (type2 === "operation") {
          this.Wrapper.prototype[name] = doIt;
          this.Wrapper.prototype[name].toString = function() {
            return "[" + name + " operation]";
          };
        } else {
          Object.defineProperty(this.Wrapper.prototype, name, {
            get: doIt,
            configurable: true
            // So the property can be deleted.
          });
          Object.defineProperty(this.attributeKeys, name, {
            value: uniqueId(name)
          });
        }
      }
      extendOperationOrAttribute(type2, name, actionDict) {
        const typePlural = type2 + "s";
        parseSignature(name, "attribute");
        if (!(this.super && name in this.super[typePlural])) {
          throw new Error(
            "Cannot extend " + type2 + " '" + name + "': did not inherit an " + type2 + " with that name"
          );
        }
        if (hasOwnProperty(this[typePlural], name)) {
          throw new Error("Cannot extend " + type2 + " '" + name + "' again");
        }
        const inheritedFormals = this[typePlural][name].formals;
        const inheritedActionDict = this[typePlural][name].actionDict;
        const newActionDict = Object.create(inheritedActionDict);
        Object.keys(actionDict).forEach((name2) => {
          newActionDict[name2] = actionDict[name2];
        });
        this[typePlural][name] = type2 === "operation" ? new Operation(name, inheritedFormals, newActionDict) : new Attribute(name, newActionDict);
        this[typePlural][name].checkActionDict(this.grammar);
      }
      assertNewName(name, type2) {
        if (hasOwnProperty(Wrapper.prototype, name)) {
          throw new Error("Cannot add " + type2 + " '" + name + "': that's a reserved name");
        }
        if (name in this.operations) {
          throw new Error(
            "Cannot add " + type2 + " '" + name + "': an operation with that name already exists"
          );
        }
        if (name in this.attributes) {
          throw new Error(
            "Cannot add " + type2 + " '" + name + "': an attribute with that name already exists"
          );
        }
      }
      // Returns a wrapper for the given CST `node` in this semantics.
      // If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?
      wrap(node, source, optBaseInterval) {
        const baseInterval = optBaseInterval || source;
        return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
      }
    };
    function parseSignature(signature, type2) {
      if (!Semantics.prototypeGrammar) {
        assert2(signature.indexOf("(") === -1);
        return {
          name: signature,
          formals: []
        };
      }
      const r = Semantics.prototypeGrammar.match(
        signature,
        type2 === "operation" ? "OperationSignature" : "AttributeSignature"
      );
      if (r.failed()) {
        throw new Error(r.message);
      }
      return Semantics.prototypeGrammarSemantics(r).parse();
    }
    function newDefaultAction(type2, name, doIt) {
      return function(...children) {
        const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
        const args = thisThing.formals.map((formal) => this.args[formal]);
        if (!this.isIteration() && children.length === 1) {
          return doIt.apply(children[0], args);
        } else {
          throw missingSemanticAction(this.ctorName, name, type2, globalActionStack);
        }
      };
    }
    Semantics.createSemantics = function(grammar2, optSuperSemantics) {
      const s = new Semantics(
        grammar2,
        optSuperSemantics !== void 0 ? optSuperSemantics : Semantics.BuiltInSemantics._getSemantics()
      );
      const proxy = function ASemantics(matchResult) {
        if (!(matchResult instanceof MatchResult)) {
          throw new TypeError(
            "Semantics expected a MatchResult, but got " + unexpectedObjToString(matchResult)
          );
        }
        if (matchResult.failed()) {
          throw new TypeError("cannot apply Semantics to " + matchResult.toString());
        }
        const cst = matchResult._cst;
        if (cst.grammar !== grammar2) {
          throw new Error(
            "Cannot use a MatchResult from grammar '" + cst.grammar.name + "' with a semantics for '" + grammar2.name + "'"
          );
        }
        const inputStream = new InputStream(matchResult.input);
        return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
      };
      proxy.addOperation = function(signature, actionDict) {
        s.addOperationOrAttribute("operation", signature, actionDict);
        return proxy;
      };
      proxy.extendOperation = function(name, actionDict) {
        s.extendOperationOrAttribute("operation", name, actionDict);
        return proxy;
      };
      proxy.addAttribute = function(name, actionDict) {
        s.addOperationOrAttribute("attribute", name, actionDict);
        return proxy;
      };
      proxy.extendAttribute = function(name, actionDict) {
        s.extendOperationOrAttribute("attribute", name, actionDict);
        return proxy;
      };
      proxy._getActionDict = function(operationOrAttributeName) {
        const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
        if (!action) {
          throw new Error(
            '"' + operationOrAttributeName + '" is not a valid operation or attribute name in this semantics for "' + grammar2.name + '"'
          );
        }
        return action.actionDict;
      };
      proxy._remove = function(operationOrAttributeName) {
        let semantic;
        if (operationOrAttributeName in s.operations) {
          semantic = s.operations[operationOrAttributeName];
          delete s.operations[operationOrAttributeName];
        } else if (operationOrAttributeName in s.attributes) {
          semantic = s.attributes[operationOrAttributeName];
          delete s.attributes[operationOrAttributeName];
        }
        delete s.Wrapper.prototype[operationOrAttributeName];
        return semantic;
      };
      proxy.getOperationNames = function() {
        return Object.keys(s.operations);
      };
      proxy.getAttributeNames = function() {
        return Object.keys(s.attributes);
      };
      proxy.getGrammar = function() {
        return s.grammar;
      };
      proxy.toRecipe = function(semanticsOnly) {
        return s.toRecipe(semanticsOnly);
      };
      proxy.toString = s.toString.bind(s);
      proxy._getSemantics = function() {
        return s;
      };
      return proxy;
    };
    var Operation = class {
      constructor(name, formals, actionDict, builtInDefault) {
        this.name = name;
        this.formals = formals;
        this.actionDict = actionDict;
        this.builtInDefault = builtInDefault;
      }
      checkActionDict(grammar2) {
        grammar2._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
      }
      // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
      // given Semantics instance.
      execute(semantics, nodeWrapper) {
        try {
          const { ctorName } = nodeWrapper._node;
          let actionFn = this.actionDict[ctorName];
          if (actionFn) {
            globalActionStack.push([this, ctorName]);
            return actionFn.apply(nodeWrapper, nodeWrapper._children());
          }
          if (nodeWrapper.isNonterminal()) {
            actionFn = this.actionDict._nonterminal;
            if (actionFn) {
              globalActionStack.push([this, "_nonterminal", ctorName]);
              return actionFn.apply(nodeWrapper, nodeWrapper._children());
            }
          }
          globalActionStack.push([this, "default action", ctorName]);
          return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());
        } finally {
          globalActionStack.pop();
        }
      }
    };
    Operation.prototype.typeName = "operation";
    var Attribute = class extends Operation {
      constructor(name, actionDict, builtInDefault) {
        super(name, [], actionDict, builtInDefault);
      }
      execute(semantics, nodeWrapper) {
        const node = nodeWrapper._node;
        const key = semantics.attributeKeys[this.name];
        if (!hasOwnProperty(node, key)) {
          node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
        }
        return node[key];
      }
    };
    Attribute.prototype.typeName = "attribute";
    var SPECIAL_ACTION_NAMES = ["_iter", "_terminal", "_nonterminal", "_default"];
    function getSortedRuleValues(grammar2) {
      return Object.keys(grammar2.rules).sort().map((name) => grammar2.rules[name]);
    }
    var jsonToJS = (str2) => str2.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    var ohmGrammar$1;
    var buildGrammar$1;
    var Grammar = class _Grammar {
      constructor(name, superGrammar, rules, optDefaultStartRule) {
        this.name = name;
        this.superGrammar = superGrammar;
        this.rules = rules;
        if (optDefaultStartRule) {
          if (!(optDefaultStartRule in rules)) {
            throw new Error(
              "Invalid start rule: '" + optDefaultStartRule + "' is not a rule in grammar '" + name + "'"
            );
          }
          this.defaultStartRule = optDefaultStartRule;
        }
        this._matchStateInitializer = void 0;
        this.supportsIncrementalParsing = true;
      }
      matcher() {
        return new Matcher(this);
      }
      // Return true if the grammar is a built-in grammar, otherwise false.
      // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
      isBuiltIn() {
        return this === _Grammar.ProtoBuiltInRules || this === _Grammar.BuiltInRules;
      }
      equals(g) {
        if (this === g) {
          return true;
        }
        if (g == null || this.name !== g.name || this.defaultStartRule !== g.defaultStartRule || !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))) {
          return false;
        }
        const myRules = getSortedRuleValues(this);
        const otherRules = getSortedRuleValues(g);
        return myRules.length === otherRules.length && myRules.every((rule, i) => {
          return rule.description === otherRules[i].description && rule.formals.join(",") === otherRules[i].formals.join(",") && rule.body.toString() === otherRules[i].body.toString();
        });
      }
      match(input, optStartApplication) {
        const m = this.matcher();
        m.replaceInputRange(0, 0, input);
        return m.match(optStartApplication);
      }
      trace(input, optStartApplication) {
        const m = this.matcher();
        m.replaceInputRange(0, 0, input);
        return m.trace(optStartApplication);
      }
      createSemantics() {
        return Semantics.createSemantics(this);
      }
      extendSemantics(superSemantics) {
        return Semantics.createSemantics(this, superSemantics._getSemantics());
      }
      // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
      // a function of the correct arity. If not, throw an exception.
      _checkTopDownActionDict(what, name, actionDict) {
        const problems = [];
        for (const k in actionDict) {
          const v = actionDict[k];
          const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k);
          if (!isSpecialAction && !(k in this.rules)) {
            problems.push(`'${k}' is not a valid semantic action for '${this.name}'`);
            continue;
          }
          if (typeof v !== "function") {
            problems.push(`'${k}' must be a function in an action dictionary for '${this.name}'`);
            continue;
          }
          const actual = v.length;
          const expected = this._topDownActionArity(k);
          if (actual !== expected) {
            let details;
            if (k === "_iter" || k === "_nonterminal") {
              details = `it should use a rest parameter, e.g. \`${k}(...children) {}\`. NOTE: this is new in Ohm v16 \u2014 see https://ohmjs.org/d/ati for details.`;
            } else {
              details = `expected ${expected}, got ${actual}`;
            }
            problems.push(`Semantic action '${k}' has the wrong arity: ${details}`);
          }
        }
        if (problems.length > 0) {
          const prettyProblems = problems.map((problem) => "- " + problem);
          const error = new Error(
            [
              `Found errors in the action dictionary of the '${name}' ${what}:`,
              ...prettyProblems
            ].join("\n")
          );
          error.problems = problems;
          throw error;
        }
      }
      // Return the expected arity for a semantic action named `actionName`, which
      // is either a rule name or a special action name like '_nonterminal'.
      _topDownActionArity(actionName) {
        return SPECIAL_ACTION_NAMES.includes(actionName) ? 0 : this.rules[actionName].body.getArity();
      }
      _inheritsFrom(grammar2) {
        let g = this.superGrammar;
        while (g) {
          if (g.equals(grammar2, true)) {
            return true;
          }
          g = g.superGrammar;
        }
        return false;
      }
      toRecipe(superGrammarExpr = void 0) {
        const metaInfo = {};
        if (this.source) {
          metaInfo.source = this.source.contents;
        }
        let startRule = null;
        if (this.defaultStartRule) {
          startRule = this.defaultStartRule;
        }
        const rules = {};
        Object.keys(this.rules).forEach((ruleName) => {
          const ruleInfo = this.rules[ruleName];
          const { body } = ruleInfo;
          const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];
          let operation;
          if (isDefinition) {
            operation = "define";
          } else {
            operation = body instanceof Extend ? "extend" : "override";
          }
          const metaInfo2 = {};
          if (ruleInfo.source && this.source) {
            const adjusted = ruleInfo.source.relativeTo(this.source);
            metaInfo2.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
          }
          const description = isDefinition ? ruleInfo.description : null;
          const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);
          rules[ruleName] = [
            operation,
            // "define"/"extend"/"override"
            metaInfo2,
            description,
            ruleInfo.formals,
            bodyRecipe
          ];
        });
        let superGrammarOutput = "null";
        if (superGrammarExpr) {
          superGrammarOutput = superGrammarExpr;
        } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
          superGrammarOutput = this.superGrammar.toRecipe();
        }
        const recipeElements = [
          ...["grammar", metaInfo, this.name].map(JSON.stringify),
          superGrammarOutput,
          ...[startRule, rules].map(JSON.stringify)
        ];
        return jsonToJS(`[${recipeElements.join(",")}]`);
      }
      // TODO: Come up with better names for these methods.
      // TODO: Write the analog of these methods for inherited attributes.
      toOperationActionDictionaryTemplate() {
        return this._toOperationOrAttributeActionDictionaryTemplate();
      }
      toAttributeActionDictionaryTemplate() {
        return this._toOperationOrAttributeActionDictionaryTemplate();
      }
      _toOperationOrAttributeActionDictionaryTemplate() {
        const sb = new StringBuffer();
        sb.append("{");
        let first = true;
        for (const ruleName in this.rules) {
          const { body } = this.rules[ruleName];
          if (first) {
            first = false;
          } else {
            sb.append(",");
          }
          sb.append("\n");
          sb.append("  ");
          this.addSemanticActionTemplate(ruleName, body, sb);
        }
        sb.append("\n}");
        return sb.contents();
      }
      addSemanticActionTemplate(ruleName, body, sb) {
        sb.append(ruleName);
        sb.append(": function(");
        const arity = this._topDownActionArity(ruleName);
        sb.append(repeat2("_", arity).join(", "));
        sb.append(") {\n");
        sb.append("  }");
      }
      // Parse a string which expresses a rule application in this grammar, and return the
      // resulting Apply node.
      parseApplication(str2) {
        let app;
        if (str2.indexOf("<") === -1) {
          app = new Apply(str2);
        } else {
          const cst = ohmGrammar$1.match(str2, "Base_application");
          app = buildGrammar$1(cst, {});
        }
        if (!(app.ruleName in this.rules)) {
          throw undeclaredRule(app.ruleName, this.name);
        }
        const { formals } = this.rules[app.ruleName];
        if (formals.length !== app.args.length) {
          const { source } = this.rules[app.ruleName];
          throw wrongNumberOfParameters(
            app.ruleName,
            formals.length,
            app.args.length,
            source
          );
        }
        return app;
      }
      _setUpMatchState(state) {
        if (this._matchStateInitializer) {
          this._matchStateInitializer(state);
        }
      }
    };
    Grammar.ProtoBuiltInRules = new Grammar(
      "ProtoBuiltInRules",
      // name
      void 0,
      // supergrammar
      {
        any: {
          body: any,
          formals: [],
          description: "any character",
          primitive: true
        },
        end: {
          body: end,
          formals: [],
          description: "end of input",
          primitive: true
        },
        caseInsensitive: {
          body: new CaseInsensitiveTerminal(new Param(0)),
          formals: ["str"],
          primitive: true
        },
        lower: {
          body: new UnicodeChar("Ll"),
          formals: [],
          description: "a lowercase letter",
          primitive: true
        },
        upper: {
          body: new UnicodeChar("Lu"),
          formals: [],
          description: "an uppercase letter",
          primitive: true
        },
        // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
        unicodeLtmo: {
          body: new UnicodeChar("Ltmo"),
          formals: [],
          description: "a Unicode character in Lt, Lm, or Lo",
          primitive: true
        },
        // These rules are not truly primitive (they could be written in userland) but are defined
        // here for bootstrapping purposes.
        spaces: {
          body: new Star(new Apply("space")),
          formals: []
        },
        space: {
          body: new Range("\0", " "),
          formals: [],
          description: "a space"
        }
      }
    );
    Grammar.initApplicationParser = function(grammar2, builderFn) {
      ohmGrammar$1 = grammar2;
      buildGrammar$1 = builderFn;
    };
    var GrammarDecl = class {
      constructor(name) {
        this.name = name;
      }
      // Helpers
      sourceInterval(startIdx, endIdx) {
        return this.source.subInterval(startIdx, endIdx - startIdx);
      }
      ensureSuperGrammar() {
        if (!this.superGrammar) {
          this.withSuperGrammar(
            // TODO: The conditional expression below is an ugly hack. It's kind of ok because
            // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
            // we should try to find a better way to do this.
            this.name === "BuiltInRules" ? Grammar.ProtoBuiltInRules : Grammar.BuiltInRules
          );
        }
        return this.superGrammar;
      }
      ensureSuperGrammarRuleForOverriding(name, source) {
        const ruleInfo = this.ensureSuperGrammar().rules[name];
        if (!ruleInfo) {
          throw cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
        }
        return ruleInfo;
      }
      installOverriddenOrExtendedRule(name, formals, body, source) {
        const duplicateParameterNames$1 = getDuplicates(formals);
        if (duplicateParameterNames$1.length > 0) {
          throw duplicateParameterNames(name, duplicateParameterNames$1, source);
        }
        const ruleInfo = this.ensureSuperGrammar().rules[name];
        const expectedFormals = ruleInfo.formals;
        const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
        if (formals.length !== expectedNumFormals) {
          throw wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
        }
        return this.install(name, formals, body, ruleInfo.description, source);
      }
      install(name, formals, body, description, source, primitive = false) {
        this.rules[name] = {
          body: body.introduceParams(formals),
          formals,
          description,
          source,
          primitive
        };
        return this;
      }
      // Stuff that you should only do once
      withSuperGrammar(superGrammar) {
        if (this.superGrammar) {
          throw new Error("the super grammar of a GrammarDecl cannot be set more than once");
        }
        this.superGrammar = superGrammar;
        this.rules = Object.create(superGrammar.rules);
        if (!superGrammar.isBuiltIn()) {
          this.defaultStartRule = superGrammar.defaultStartRule;
        }
        return this;
      }
      withDefaultStartRule(ruleName) {
        this.defaultStartRule = ruleName;
        return this;
      }
      withSource(source) {
        this.source = new InputStream(source).interval(0, source.length);
        return this;
      }
      // Creates a Grammar instance, and if it passes the sanity checks, returns it.
      build() {
        const grammar2 = new Grammar(
          this.name,
          this.ensureSuperGrammar(),
          this.rules,
          this.defaultStartRule
        );
        grammar2._matchStateInitializer = grammar2.superGrammar._matchStateInitializer;
        grammar2.supportsIncrementalParsing = grammar2.superGrammar.supportsIncrementalParsing;
        const grammarErrors = [];
        let grammarHasInvalidApplications = false;
        Object.keys(grammar2.rules).forEach((ruleName) => {
          const { body } = grammar2.rules[ruleName];
          try {
            body.assertChoicesHaveUniformArity(ruleName);
          } catch (e) {
            grammarErrors.push(e);
          }
          try {
            body.assertAllApplicationsAreValid(ruleName, grammar2);
          } catch (e) {
            grammarErrors.push(e);
            grammarHasInvalidApplications = true;
          }
        });
        if (!grammarHasInvalidApplications) {
          Object.keys(grammar2.rules).forEach((ruleName) => {
            const { body } = grammar2.rules[ruleName];
            try {
              body.assertIteratedExprsAreNotNullable(grammar2, []);
            } catch (e) {
              grammarErrors.push(e);
            }
          });
        }
        if (grammarErrors.length > 0) {
          throwErrors(grammarErrors);
        }
        if (this.source) {
          grammar2.source = this.source;
        }
        return grammar2;
      }
      // Rule declarations
      define(name, formals, body, description, source, primitive) {
        this.ensureSuperGrammar();
        if (this.superGrammar.rules[name]) {
          throw duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
        } else if (this.rules[name]) {
          throw duplicateRuleDeclaration(name, this.name, this.name, source);
        }
        const duplicateParameterNames$1 = getDuplicates(formals);
        if (duplicateParameterNames$1.length > 0) {
          throw duplicateParameterNames(name, duplicateParameterNames$1, source);
        }
        return this.install(name, formals, body, description, source, primitive);
      }
      override(name, formals, body, descIgnored, source) {
        this.ensureSuperGrammarRuleForOverriding(name, source);
        this.installOverriddenOrExtendedRule(name, formals, body, source);
        return this;
      }
      extend(name, formals, fragment, descIgnored, source) {
        const ruleInfo = this.ensureSuperGrammar().rules[name];
        if (!ruleInfo) {
          throw cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
        }
        const body = new Extend(this.superGrammar, name, fragment);
        body.source = fragment.source;
        this.installOverriddenOrExtendedRule(name, formals, body, source);
        return this;
      }
    };
    var Builder = class {
      constructor() {
        this.currentDecl = null;
        this.currentRuleName = null;
      }
      newGrammar(name) {
        return new GrammarDecl(name);
      }
      grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
        const gDecl = new GrammarDecl(name);
        if (superGrammar) {
          gDecl.withSuperGrammar(
            superGrammar instanceof Grammar ? superGrammar : this.fromRecipe(superGrammar)
          );
        }
        if (defaultStartRule) {
          gDecl.withDefaultStartRule(defaultStartRule);
        }
        if (metaInfo && metaInfo.source) {
          gDecl.withSource(metaInfo.source);
        }
        this.currentDecl = gDecl;
        Object.keys(rules).forEach((ruleName) => {
          this.currentRuleName = ruleName;
          const ruleRecipe = rules[ruleName];
          const action = ruleRecipe[0];
          const metaInfo2 = ruleRecipe[1];
          const description = ruleRecipe[2];
          const formals = ruleRecipe[3];
          const body = this.fromRecipe(ruleRecipe[4]);
          let source;
          if (gDecl.source && metaInfo2 && metaInfo2.sourceInterval) {
            source = gDecl.source.subInterval(
              metaInfo2.sourceInterval[0],
              metaInfo2.sourceInterval[1] - metaInfo2.sourceInterval[0]
            );
          }
          gDecl[action](ruleName, formals, body, description, source);
        });
        this.currentRuleName = this.currentDecl = null;
        return gDecl.build();
      }
      terminal(x) {
        return new Terminal(x);
      }
      range(from, to) {
        return new Range(from, to);
      }
      param(index) {
        return new Param(index);
      }
      alt(...termArgs) {
        let terms = [];
        for (let arg of termArgs) {
          if (!(arg instanceof PExpr)) {
            arg = this.fromRecipe(arg);
          }
          if (arg instanceof Alt) {
            terms = terms.concat(arg.terms);
          } else {
            terms.push(arg);
          }
        }
        return terms.length === 1 ? terms[0] : new Alt(terms);
      }
      seq(...factorArgs) {
        let factors = [];
        for (let arg of factorArgs) {
          if (!(arg instanceof PExpr)) {
            arg = this.fromRecipe(arg);
          }
          if (arg instanceof Seq) {
            factors = factors.concat(arg.factors);
          } else {
            factors.push(arg);
          }
        }
        return factors.length === 1 ? factors[0] : new Seq(factors);
      }
      star(expr) {
        if (!(expr instanceof PExpr)) {
          expr = this.fromRecipe(expr);
        }
        return new Star(expr);
      }
      plus(expr) {
        if (!(expr instanceof PExpr)) {
          expr = this.fromRecipe(expr);
        }
        return new Plus(expr);
      }
      opt(expr) {
        if (!(expr instanceof PExpr)) {
          expr = this.fromRecipe(expr);
        }
        return new Opt(expr);
      }
      not(expr) {
        if (!(expr instanceof PExpr)) {
          expr = this.fromRecipe(expr);
        }
        return new Not(expr);
      }
      lookahead(expr) {
        if (!(expr instanceof PExpr)) {
          expr = this.fromRecipe(expr);
        }
        return new Lookahead(expr);
      }
      lex(expr) {
        if (!(expr instanceof PExpr)) {
          expr = this.fromRecipe(expr);
        }
        return new Lex(expr);
      }
      app(ruleName, optParams) {
        if (optParams && optParams.length > 0) {
          optParams = optParams.map(function(param) {
            return param instanceof PExpr ? param : this.fromRecipe(param);
          }, this);
        }
        return new Apply(ruleName, optParams);
      }
      // Note that unlike other methods in this class, this method cannot be used as a
      // convenience constructor. It only works with recipes, because it relies on
      // `this.currentDecl` and `this.currentRuleName` being set.
      splice(beforeTerms, afterTerms) {
        return new Splice(
          this.currentDecl.superGrammar,
          this.currentRuleName,
          beforeTerms.map((term) => this.fromRecipe(term)),
          afterTerms.map((term) => this.fromRecipe(term))
        );
      }
      fromRecipe(recipe) {
        const args = recipe[0] === "grammar" ? recipe.slice(1) : recipe.slice(2);
        const result = this[recipe[0]](...args);
        const metaInfo = recipe[1];
        if (metaInfo) {
          if (metaInfo.sourceInterval && this.currentDecl) {
            result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));
          }
        }
        return result;
      }
    };
    function makeRecipe(recipe) {
      if (typeof recipe === "function") {
        return recipe.call(new Builder());
      } else {
        if (typeof recipe === "string") {
          recipe = JSON.parse(recipe);
        }
        return new Builder().fromRecipe(recipe);
      }
    }
    var BuiltInRules = makeRecipe(["grammar", { "source": 'BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = "0".."9"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | "a".."f"\n    | "A".."F"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n  // Allows a syntactic rule application within a lexical context.\n  applySyntactic<app> = app\n}' }, "BuiltInRules", null, null, { "alnum": ["define", { "sourceInterval": [18, 78] }, "an alpha-numeric character", [], ["alt", { "sourceInterval": [60, 78] }, ["app", { "sourceInterval": [60, 66] }, "letter", []], ["app", { "sourceInterval": [73, 78] }, "digit", []]]], "letter": ["define", { "sourceInterval": [82, 142] }, "a letter", [], ["alt", { "sourceInterval": [107, 142] }, ["app", { "sourceInterval": [107, 112] }, "lower", []], ["app", { "sourceInterval": [119, 124] }, "upper", []], ["app", { "sourceInterval": [131, 142] }, "unicodeLtmo", []]]], "digit": ["define", { "sourceInterval": [146, 177] }, "a digit", [], ["range", { "sourceInterval": [169, 177] }, "0", "9"]], "hexDigit": ["define", { "sourceInterval": [181, 254] }, "a hexadecimal digit", [], ["alt", { "sourceInterval": [219, 254] }, ["app", { "sourceInterval": [219, 224] }, "digit", []], ["range", { "sourceInterval": [231, 239] }, "a", "f"], ["range", { "sourceInterval": [246, 254] }, "A", "F"]]], "ListOf": ["define", { "sourceInterval": [258, 336] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [282, 336] }, ["app", { "sourceInterval": [282, 307] }, "NonemptyListOf", [["param", { "sourceInterval": [297, 301] }, 0], ["param", { "sourceInterval": [303, 306] }, 1]]], ["app", { "sourceInterval": [314, 336] }, "EmptyListOf", [["param", { "sourceInterval": [326, 330] }, 0], ["param", { "sourceInterval": [332, 335] }, 1]]]]], "NonemptyListOf": ["define", { "sourceInterval": [340, 388] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [372, 388] }, ["param", { "sourceInterval": [372, 376] }, 0], ["star", { "sourceInterval": [377, 388] }, ["seq", { "sourceInterval": [378, 386] }, ["param", { "sourceInterval": [378, 381] }, 1], ["param", { "sourceInterval": [382, 386] }, 0]]]]], "EmptyListOf": ["define", { "sourceInterval": [392, 434] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [438, 438] }]], "listOf": ["define", { "sourceInterval": [438, 516] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [462, 516] }, ["app", { "sourceInterval": [462, 487] }, "nonemptyListOf", [["param", { "sourceInterval": [477, 481] }, 0], ["param", { "sourceInterval": [483, 486] }, 1]]], ["app", { "sourceInterval": [494, 516] }, "emptyListOf", [["param", { "sourceInterval": [506, 510] }, 0], ["param", { "sourceInterval": [512, 515] }, 1]]]]], "nonemptyListOf": ["define", { "sourceInterval": [520, 568] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [552, 568] }, ["param", { "sourceInterval": [552, 556] }, 0], ["star", { "sourceInterval": [557, 568] }, ["seq", { "sourceInterval": [558, 566] }, ["param", { "sourceInterval": [558, 561] }, 1], ["param", { "sourceInterval": [562, 566] }, 0]]]]], "emptyListOf": ["define", { "sourceInterval": [572, 682] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [685, 685] }]], "applySyntactic": ["define", { "sourceInterval": [685, 710] }, null, ["app"], ["param", { "sourceInterval": [707, 710] }, 0]] }]);
    Grammar.BuiltInRules = BuiltInRules;
    announceBuiltInRules(Grammar.BuiltInRules);
    var ohmGrammar = makeRecipe(["grammar", { "source": `Ohm {

  Grammars
    = Grammar*

  Grammar
    = ident SuperGrammar? "{" Rule* "}"

  SuperGrammar
    = "<:" ident

  Rule
    = ident Formals? ruleDescr? "="  RuleBody  -- define
    | ident Formals?            ":=" OverrideRuleBody  -- override
    | ident Formals?            "+=" RuleBody  -- extend

  RuleBody
    = "|"? NonemptyListOf<TopLevelTerm, "|">

  TopLevelTerm
    = Seq caseName  -- inline
    | Seq

  OverrideRuleBody
    = "|"? NonemptyListOf<OverrideTopLevelTerm, "|">

  OverrideTopLevelTerm
    = "..."  -- superSplice
    | TopLevelTerm

  Formals
    = "<" ListOf<ident, ","> ">"

  Params
    = "<" ListOf<Seq, ","> ">"

  Alt
    = NonemptyListOf<Seq, "|">

  Seq
    = Iter*

  Iter
    = Pred "*"  -- star
    | Pred "+"  -- plus
    | Pred "?"  -- opt
    | Pred

  Pred
    = "~" Lex  -- not
    | "&" Lex  -- lookahead
    | Lex

  Lex
    = "#" Base  -- lex
    | Base

  Base
    = ident Params? ~(ruleDescr? "=" | ":=" | "+=")  -- application
    | oneCharTerminal ".." oneCharTerminal           -- range
    | terminal                                       -- terminal
    | "(" Alt ")"                                    -- paren

  ruleDescr  (a rule description)
    = "(" ruleDescrText ")"

  ruleDescrText
    = (~")" any)*

  caseName
    = "--" (~"\\n" space)* name (~"\\n" space)* ("\\n" | &"}")

  name  (a name)
    = nameFirst nameRest*

  nameFirst
    = "_"
    | letter

  nameRest
    = "_"
    | alnum

  ident  (an identifier)
    = name

  terminal
    = "\\"" terminalChar* "\\""

  oneCharTerminal
    = "\\"" terminalChar "\\""

  terminalChar
    = escapeChar
      | ~"\\\\" ~"\\"" ~"\\n" "\\u{0}".."\\u{10FFFF}"

  escapeChar  (an escape sequence)
    = "\\\\\\\\"                                     -- backslash
    | "\\\\\\""                                     -- doubleQuote
    | "\\\\\\'"                                     -- singleQuote
    | "\\\\b"                                      -- backspace
    | "\\\\n"                                      -- lineFeed
    | "\\\\r"                                      -- carriageReturn
    | "\\\\t"                                      -- tab
    | "\\\\u{" hexDigit hexDigit? hexDigit?
             hexDigit? hexDigit? hexDigit? "}"   -- unicodeCodePoint
    | "\\\\u" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape
    | "\\\\x" hexDigit hexDigit                    -- hexEscape

  space
   += comment

  comment
    = "//" (~"\\n" any)* &("\\n" | end)  -- singleLine
    | "/*" (~"*/" any)* "*/"  -- multiLine

  tokens = token*

  token = caseName | comment | ident | operator | punctuation | terminal | any

  operator = "<:" | "=" | ":=" | "+=" | "*" | "+" | "?" | "~" | "&"

  punctuation = "<" | ">" | "," | "--"
}` }, "Ohm", null, "Grammars", { "Grammars": ["define", { "sourceInterval": [9, 32] }, null, [], ["star", { "sourceInterval": [24, 32] }, ["app", { "sourceInterval": [24, 31] }, "Grammar", []]]], "Grammar": ["define", { "sourceInterval": [36, 83] }, null, [], ["seq", { "sourceInterval": [50, 83] }, ["app", { "sourceInterval": [50, 55] }, "ident", []], ["opt", { "sourceInterval": [56, 69] }, ["app", { "sourceInterval": [56, 68] }, "SuperGrammar", []]], ["terminal", { "sourceInterval": [70, 73] }, "{"], ["star", { "sourceInterval": [74, 79] }, ["app", { "sourceInterval": [74, 78] }, "Rule", []]], ["terminal", { "sourceInterval": [80, 83] }, "}"]]], "SuperGrammar": ["define", { "sourceInterval": [87, 116] }, null, [], ["seq", { "sourceInterval": [106, 116] }, ["terminal", { "sourceInterval": [106, 110] }, "<:"], ["app", { "sourceInterval": [111, 116] }, "ident", []]]], "Rule_define": ["define", { "sourceInterval": [131, 181] }, null, [], ["seq", { "sourceInterval": [131, 170] }, ["app", { "sourceInterval": [131, 136] }, "ident", []], ["opt", { "sourceInterval": [137, 145] }, ["app", { "sourceInterval": [137, 144] }, "Formals", []]], ["opt", { "sourceInterval": [146, 156] }, ["app", { "sourceInterval": [146, 155] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [157, 160] }, "="], ["app", { "sourceInterval": [162, 170] }, "RuleBody", []]]], "Rule_override": ["define", { "sourceInterval": [188, 248] }, null, [], ["seq", { "sourceInterval": [188, 235] }, ["app", { "sourceInterval": [188, 193] }, "ident", []], ["opt", { "sourceInterval": [194, 202] }, ["app", { "sourceInterval": [194, 201] }, "Formals", []]], ["terminal", { "sourceInterval": [214, 218] }, ":="], ["app", { "sourceInterval": [219, 235] }, "OverrideRuleBody", []]]], "Rule_extend": ["define", { "sourceInterval": [255, 305] }, null, [], ["seq", { "sourceInterval": [255, 294] }, ["app", { "sourceInterval": [255, 260] }, "ident", []], ["opt", { "sourceInterval": [261, 269] }, ["app", { "sourceInterval": [261, 268] }, "Formals", []]], ["terminal", { "sourceInterval": [281, 285] }, "+="], ["app", { "sourceInterval": [286, 294] }, "RuleBody", []]]], "Rule": ["define", { "sourceInterval": [120, 305] }, null, [], ["alt", { "sourceInterval": [131, 305] }, ["app", { "sourceInterval": [131, 170] }, "Rule_define", []], ["app", { "sourceInterval": [188, 235] }, "Rule_override", []], ["app", { "sourceInterval": [255, 294] }, "Rule_extend", []]]], "RuleBody": ["define", { "sourceInterval": [309, 362] }, null, [], ["seq", { "sourceInterval": [324, 362] }, ["opt", { "sourceInterval": [324, 328] }, ["terminal", { "sourceInterval": [324, 327] }, "|"]], ["app", { "sourceInterval": [329, 362] }, "NonemptyListOf", [["app", { "sourceInterval": [344, 356] }, "TopLevelTerm", []], ["terminal", { "sourceInterval": [358, 361] }, "|"]]]]], "TopLevelTerm_inline": ["define", { "sourceInterval": [385, 408] }, null, [], ["seq", { "sourceInterval": [385, 397] }, ["app", { "sourceInterval": [385, 388] }, "Seq", []], ["app", { "sourceInterval": [389, 397] }, "caseName", []]]], "TopLevelTerm": ["define", { "sourceInterval": [366, 418] }, null, [], ["alt", { "sourceInterval": [385, 418] }, ["app", { "sourceInterval": [385, 397] }, "TopLevelTerm_inline", []], ["app", { "sourceInterval": [415, 418] }, "Seq", []]]], "OverrideRuleBody": ["define", { "sourceInterval": [422, 491] }, null, [], ["seq", { "sourceInterval": [445, 491] }, ["opt", { "sourceInterval": [445, 449] }, ["terminal", { "sourceInterval": [445, 448] }, "|"]], ["app", { "sourceInterval": [450, 491] }, "NonemptyListOf", [["app", { "sourceInterval": [465, 485] }, "OverrideTopLevelTerm", []], ["terminal", { "sourceInterval": [487, 490] }, "|"]]]]], "OverrideTopLevelTerm_superSplice": ["define", { "sourceInterval": [522, 543] }, null, [], ["terminal", { "sourceInterval": [522, 527] }, "..."]], "OverrideTopLevelTerm": ["define", { "sourceInterval": [495, 562] }, null, [], ["alt", { "sourceInterval": [522, 562] }, ["app", { "sourceInterval": [522, 527] }, "OverrideTopLevelTerm_superSplice", []], ["app", { "sourceInterval": [550, 562] }, "TopLevelTerm", []]]], "Formals": ["define", { "sourceInterval": [566, 606] }, null, [], ["seq", { "sourceInterval": [580, 606] }, ["terminal", { "sourceInterval": [580, 583] }, "<"], ["app", { "sourceInterval": [584, 602] }, "ListOf", [["app", { "sourceInterval": [591, 596] }, "ident", []], ["terminal", { "sourceInterval": [598, 601] }, ","]]], ["terminal", { "sourceInterval": [603, 606] }, ">"]]], "Params": ["define", { "sourceInterval": [610, 647] }, null, [], ["seq", { "sourceInterval": [623, 647] }, ["terminal", { "sourceInterval": [623, 626] }, "<"], ["app", { "sourceInterval": [627, 643] }, "ListOf", [["app", { "sourceInterval": [634, 637] }, "Seq", []], ["terminal", { "sourceInterval": [639, 642] }, ","]]], ["terminal", { "sourceInterval": [644, 647] }, ">"]]], "Alt": ["define", { "sourceInterval": [651, 685] }, null, [], ["app", { "sourceInterval": [661, 685] }, "NonemptyListOf", [["app", { "sourceInterval": [676, 679] }, "Seq", []], ["terminal", { "sourceInterval": [681, 684] }, "|"]]]], "Seq": ["define", { "sourceInterval": [689, 704] }, null, [], ["star", { "sourceInterval": [699, 704] }, ["app", { "sourceInterval": [699, 703] }, "Iter", []]]], "Iter_star": ["define", { "sourceInterval": [719, 736] }, null, [], ["seq", { "sourceInterval": [719, 727] }, ["app", { "sourceInterval": [719, 723] }, "Pred", []], ["terminal", { "sourceInterval": [724, 727] }, "*"]]], "Iter_plus": ["define", { "sourceInterval": [743, 760] }, null, [], ["seq", { "sourceInterval": [743, 751] }, ["app", { "sourceInterval": [743, 747] }, "Pred", []], ["terminal", { "sourceInterval": [748, 751] }, "+"]]], "Iter_opt": ["define", { "sourceInterval": [767, 783] }, null, [], ["seq", { "sourceInterval": [767, 775] }, ["app", { "sourceInterval": [767, 771] }, "Pred", []], ["terminal", { "sourceInterval": [772, 775] }, "?"]]], "Iter": ["define", { "sourceInterval": [708, 794] }, null, [], ["alt", { "sourceInterval": [719, 794] }, ["app", { "sourceInterval": [719, 727] }, "Iter_star", []], ["app", { "sourceInterval": [743, 751] }, "Iter_plus", []], ["app", { "sourceInterval": [767, 775] }, "Iter_opt", []], ["app", { "sourceInterval": [790, 794] }, "Pred", []]]], "Pred_not": ["define", { "sourceInterval": [809, 824] }, null, [], ["seq", { "sourceInterval": [809, 816] }, ["terminal", { "sourceInterval": [809, 812] }, "~"], ["app", { "sourceInterval": [813, 816] }, "Lex", []]]], "Pred_lookahead": ["define", { "sourceInterval": [831, 852] }, null, [], ["seq", { "sourceInterval": [831, 838] }, ["terminal", { "sourceInterval": [831, 834] }, "&"], ["app", { "sourceInterval": [835, 838] }, "Lex", []]]], "Pred": ["define", { "sourceInterval": [798, 862] }, null, [], ["alt", { "sourceInterval": [809, 862] }, ["app", { "sourceInterval": [809, 816] }, "Pred_not", []], ["app", { "sourceInterval": [831, 838] }, "Pred_lookahead", []], ["app", { "sourceInterval": [859, 862] }, "Lex", []]]], "Lex_lex": ["define", { "sourceInterval": [876, 892] }, null, [], ["seq", { "sourceInterval": [876, 884] }, ["terminal", { "sourceInterval": [876, 879] }, "#"], ["app", { "sourceInterval": [880, 884] }, "Base", []]]], "Lex": ["define", { "sourceInterval": [866, 903] }, null, [], ["alt", { "sourceInterval": [876, 903] }, ["app", { "sourceInterval": [876, 884] }, "Lex_lex", []], ["app", { "sourceInterval": [899, 903] }, "Base", []]]], "Base_application": ["define", { "sourceInterval": [918, 979] }, null, [], ["seq", { "sourceInterval": [918, 963] }, ["app", { "sourceInterval": [918, 923] }, "ident", []], ["opt", { "sourceInterval": [924, 931] }, ["app", { "sourceInterval": [924, 930] }, "Params", []]], ["not", { "sourceInterval": [932, 963] }, ["alt", { "sourceInterval": [934, 962] }, ["seq", { "sourceInterval": [934, 948] }, ["opt", { "sourceInterval": [934, 944] }, ["app", { "sourceInterval": [934, 943] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [945, 948] }, "="]], ["terminal", { "sourceInterval": [951, 955] }, ":="], ["terminal", { "sourceInterval": [958, 962] }, "+="]]]]], "Base_range": ["define", { "sourceInterval": [986, 1041] }, null, [], ["seq", { "sourceInterval": [986, 1022] }, ["app", { "sourceInterval": [986, 1001] }, "oneCharTerminal", []], ["terminal", { "sourceInterval": [1002, 1006] }, ".."], ["app", { "sourceInterval": [1007, 1022] }, "oneCharTerminal", []]]], "Base_terminal": ["define", { "sourceInterval": [1048, 1106] }, null, [], ["app", { "sourceInterval": [1048, 1056] }, "terminal", []]], "Base_paren": ["define", { "sourceInterval": [1113, 1168] }, null, [], ["seq", { "sourceInterval": [1113, 1124] }, ["terminal", { "sourceInterval": [1113, 1116] }, "("], ["app", { "sourceInterval": [1117, 1120] }, "Alt", []], ["terminal", { "sourceInterval": [1121, 1124] }, ")"]]], "Base": ["define", { "sourceInterval": [907, 1168] }, null, [], ["alt", { "sourceInterval": [918, 1168] }, ["app", { "sourceInterval": [918, 963] }, "Base_application", []], ["app", { "sourceInterval": [986, 1022] }, "Base_range", []], ["app", { "sourceInterval": [1048, 1056] }, "Base_terminal", []], ["app", { "sourceInterval": [1113, 1124] }, "Base_paren", []]]], "ruleDescr": ["define", { "sourceInterval": [1172, 1231] }, "a rule description", [], ["seq", { "sourceInterval": [1210, 1231] }, ["terminal", { "sourceInterval": [1210, 1213] }, "("], ["app", { "sourceInterval": [1214, 1227] }, "ruleDescrText", []], ["terminal", { "sourceInterval": [1228, 1231] }, ")"]]], "ruleDescrText": ["define", { "sourceInterval": [1235, 1266] }, null, [], ["star", { "sourceInterval": [1255, 1266] }, ["seq", { "sourceInterval": [1256, 1264] }, ["not", { "sourceInterval": [1256, 1260] }, ["terminal", { "sourceInterval": [1257, 1260] }, ")"]], ["app", { "sourceInterval": [1261, 1264] }, "any", []]]]], "caseName": ["define", { "sourceInterval": [1270, 1338] }, null, [], ["seq", { "sourceInterval": [1285, 1338] }, ["terminal", { "sourceInterval": [1285, 1289] }, "--"], ["star", { "sourceInterval": [1290, 1304] }, ["seq", { "sourceInterval": [1291, 1302] }, ["not", { "sourceInterval": [1291, 1296] }, ["terminal", { "sourceInterval": [1292, 1296] }, "\n"]], ["app", { "sourceInterval": [1297, 1302] }, "space", []]]], ["app", { "sourceInterval": [1305, 1309] }, "name", []], ["star", { "sourceInterval": [1310, 1324] }, ["seq", { "sourceInterval": [1311, 1322] }, ["not", { "sourceInterval": [1311, 1316] }, ["terminal", { "sourceInterval": [1312, 1316] }, "\n"]], ["app", { "sourceInterval": [1317, 1322] }, "space", []]]], ["alt", { "sourceInterval": [1326, 1337] }, ["terminal", { "sourceInterval": [1326, 1330] }, "\n"], ["lookahead", { "sourceInterval": [1333, 1337] }, ["terminal", { "sourceInterval": [1334, 1337] }, "}"]]]]], "name": ["define", { "sourceInterval": [1342, 1382] }, "a name", [], ["seq", { "sourceInterval": [1363, 1382] }, ["app", { "sourceInterval": [1363, 1372] }, "nameFirst", []], ["star", { "sourceInterval": [1373, 1382] }, ["app", { "sourceInterval": [1373, 1381] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [1386, 1418] }, null, [], ["alt", { "sourceInterval": [1402, 1418] }, ["terminal", { "sourceInterval": [1402, 1405] }, "_"], ["app", { "sourceInterval": [1412, 1418] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [1422, 1452] }, null, [], ["alt", { "sourceInterval": [1437, 1452] }, ["terminal", { "sourceInterval": [1437, 1440] }, "_"], ["app", { "sourceInterval": [1447, 1452] }, "alnum", []]]], "ident": ["define", { "sourceInterval": [1456, 1489] }, "an identifier", [], ["app", { "sourceInterval": [1485, 1489] }, "name", []]], "terminal": ["define", { "sourceInterval": [1493, 1531] }, null, [], ["seq", { "sourceInterval": [1508, 1531] }, ["terminal", { "sourceInterval": [1508, 1512] }, '"'], ["star", { "sourceInterval": [1513, 1526] }, ["app", { "sourceInterval": [1513, 1525] }, "terminalChar", []]], ["terminal", { "sourceInterval": [1527, 1531] }, '"']]], "oneCharTerminal": ["define", { "sourceInterval": [1535, 1579] }, null, [], ["seq", { "sourceInterval": [1557, 1579] }, ["terminal", { "sourceInterval": [1557, 1561] }, '"'], ["app", { "sourceInterval": [1562, 1574] }, "terminalChar", []], ["terminal", { "sourceInterval": [1575, 1579] }, '"']]], "terminalChar": ["define", { "sourceInterval": [1583, 1660] }, null, [], ["alt", { "sourceInterval": [1602, 1660] }, ["app", { "sourceInterval": [1602, 1612] }, "escapeChar", []], ["seq", { "sourceInterval": [1621, 1660] }, ["not", { "sourceInterval": [1621, 1626] }, ["terminal", { "sourceInterval": [1622, 1626] }, "\\"]], ["not", { "sourceInterval": [1627, 1632] }, ["terminal", { "sourceInterval": [1628, 1632] }, '"']], ["not", { "sourceInterval": [1633, 1638] }, ["terminal", { "sourceInterval": [1634, 1638] }, "\n"]], ["range", { "sourceInterval": [1639, 1660] }, "\0", "\u{10FFFF}"]]]], "escapeChar_backslash": ["define", { "sourceInterval": [1703, 1758] }, null, [], ["terminal", { "sourceInterval": [1703, 1709] }, "\\\\"]], "escapeChar_doubleQuote": ["define", { "sourceInterval": [1765, 1822] }, null, [], ["terminal", { "sourceInterval": [1765, 1771] }, '\\"']], "escapeChar_singleQuote": ["define", { "sourceInterval": [1829, 1886] }, null, [], ["terminal", { "sourceInterval": [1829, 1835] }, "\\'"]], "escapeChar_backspace": ["define", { "sourceInterval": [1893, 1948] }, null, [], ["terminal", { "sourceInterval": [1893, 1898] }, "\\b"]], "escapeChar_lineFeed": ["define", { "sourceInterval": [1955, 2009] }, null, [], ["terminal", { "sourceInterval": [1955, 1960] }, "\\n"]], "escapeChar_carriageReturn": ["define", { "sourceInterval": [2016, 2076] }, null, [], ["terminal", { "sourceInterval": [2016, 2021] }, "\\r"]], "escapeChar_tab": ["define", { "sourceInterval": [2083, 2132] }, null, [], ["terminal", { "sourceInterval": [2083, 2088] }, "\\t"]], "escapeChar_unicodeCodePoint": ["define", { "sourceInterval": [2139, 2243] }, null, [], ["seq", { "sourceInterval": [2139, 2221] }, ["terminal", { "sourceInterval": [2139, 2145] }, "\\u{"], ["app", { "sourceInterval": [2146, 2154] }, "hexDigit", []], ["opt", { "sourceInterval": [2155, 2164] }, ["app", { "sourceInterval": [2155, 2163] }, "hexDigit", []]], ["opt", { "sourceInterval": [2165, 2174] }, ["app", { "sourceInterval": [2165, 2173] }, "hexDigit", []]], ["opt", { "sourceInterval": [2188, 2197] }, ["app", { "sourceInterval": [2188, 2196] }, "hexDigit", []]], ["opt", { "sourceInterval": [2198, 2207] }, ["app", { "sourceInterval": [2198, 2206] }, "hexDigit", []]], ["opt", { "sourceInterval": [2208, 2217] }, ["app", { "sourceInterval": [2208, 2216] }, "hexDigit", []]], ["terminal", { "sourceInterval": [2218, 2221] }, "}"]]], "escapeChar_unicodeEscape": ["define", { "sourceInterval": [2250, 2309] }, null, [], ["seq", { "sourceInterval": [2250, 2291] }, ["terminal", { "sourceInterval": [2250, 2255] }, "\\u"], ["app", { "sourceInterval": [2256, 2264] }, "hexDigit", []], ["app", { "sourceInterval": [2265, 2273] }, "hexDigit", []], ["app", { "sourceInterval": [2274, 2282] }, "hexDigit", []], ["app", { "sourceInterval": [2283, 2291] }, "hexDigit", []]]], "escapeChar_hexEscape": ["define", { "sourceInterval": [2316, 2371] }, null, [], ["seq", { "sourceInterval": [2316, 2339] }, ["terminal", { "sourceInterval": [2316, 2321] }, "\\x"], ["app", { "sourceInterval": [2322, 2330] }, "hexDigit", []], ["app", { "sourceInterval": [2331, 2339] }, "hexDigit", []]]], "escapeChar": ["define", { "sourceInterval": [1664, 2371] }, "an escape sequence", [], ["alt", { "sourceInterval": [1703, 2371] }, ["app", { "sourceInterval": [1703, 1709] }, "escapeChar_backslash", []], ["app", { "sourceInterval": [1765, 1771] }, "escapeChar_doubleQuote", []], ["app", { "sourceInterval": [1829, 1835] }, "escapeChar_singleQuote", []], ["app", { "sourceInterval": [1893, 1898] }, "escapeChar_backspace", []], ["app", { "sourceInterval": [1955, 1960] }, "escapeChar_lineFeed", []], ["app", { "sourceInterval": [2016, 2021] }, "escapeChar_carriageReturn", []], ["app", { "sourceInterval": [2083, 2088] }, "escapeChar_tab", []], ["app", { "sourceInterval": [2139, 2221] }, "escapeChar_unicodeCodePoint", []], ["app", { "sourceInterval": [2250, 2291] }, "escapeChar_unicodeEscape", []], ["app", { "sourceInterval": [2316, 2339] }, "escapeChar_hexEscape", []]]], "space": ["extend", { "sourceInterval": [2375, 2394] }, null, [], ["app", { "sourceInterval": [2387, 2394] }, "comment", []]], "comment_singleLine": ["define", { "sourceInterval": [2412, 2458] }, null, [], ["seq", { "sourceInterval": [2412, 2443] }, ["terminal", { "sourceInterval": [2412, 2416] }, "//"], ["star", { "sourceInterval": [2417, 2429] }, ["seq", { "sourceInterval": [2418, 2427] }, ["not", { "sourceInterval": [2418, 2423] }, ["terminal", { "sourceInterval": [2419, 2423] }, "\n"]], ["app", { "sourceInterval": [2424, 2427] }, "any", []]]], ["lookahead", { "sourceInterval": [2430, 2443] }, ["alt", { "sourceInterval": [2432, 2442] }, ["terminal", { "sourceInterval": [2432, 2436] }, "\n"], ["app", { "sourceInterval": [2439, 2442] }, "end", []]]]]], "comment_multiLine": ["define", { "sourceInterval": [2465, 2501] }, null, [], ["seq", { "sourceInterval": [2465, 2487] }, ["terminal", { "sourceInterval": [2465, 2469] }, "/*"], ["star", { "sourceInterval": [2470, 2482] }, ["seq", { "sourceInterval": [2471, 2480] }, ["not", { "sourceInterval": [2471, 2476] }, ["terminal", { "sourceInterval": [2472, 2476] }, "*/"]], ["app", { "sourceInterval": [2477, 2480] }, "any", []]]], ["terminal", { "sourceInterval": [2483, 2487] }, "*/"]]], "comment": ["define", { "sourceInterval": [2398, 2501] }, null, [], ["alt", { "sourceInterval": [2412, 2501] }, ["app", { "sourceInterval": [2412, 2443] }, "comment_singleLine", []], ["app", { "sourceInterval": [2465, 2487] }, "comment_multiLine", []]]], "tokens": ["define", { "sourceInterval": [2505, 2520] }, null, [], ["star", { "sourceInterval": [2514, 2520] }, ["app", { "sourceInterval": [2514, 2519] }, "token", []]]], "token": ["define", { "sourceInterval": [2524, 2600] }, null, [], ["alt", { "sourceInterval": [2532, 2600] }, ["app", { "sourceInterval": [2532, 2540] }, "caseName", []], ["app", { "sourceInterval": [2543, 2550] }, "comment", []], ["app", { "sourceInterval": [2553, 2558] }, "ident", []], ["app", { "sourceInterval": [2561, 2569] }, "operator", []], ["app", { "sourceInterval": [2572, 2583] }, "punctuation", []], ["app", { "sourceInterval": [2586, 2594] }, "terminal", []], ["app", { "sourceInterval": [2597, 2600] }, "any", []]]], "operator": ["define", { "sourceInterval": [2604, 2669] }, null, [], ["alt", { "sourceInterval": [2615, 2669] }, ["terminal", { "sourceInterval": [2615, 2619] }, "<:"], ["terminal", { "sourceInterval": [2622, 2625] }, "="], ["terminal", { "sourceInterval": [2628, 2632] }, ":="], ["terminal", { "sourceInterval": [2635, 2639] }, "+="], ["terminal", { "sourceInterval": [2642, 2645] }, "*"], ["terminal", { "sourceInterval": [2648, 2651] }, "+"], ["terminal", { "sourceInterval": [2654, 2657] }, "?"], ["terminal", { "sourceInterval": [2660, 2663] }, "~"], ["terminal", { "sourceInterval": [2666, 2669] }, "&"]]], "punctuation": ["define", { "sourceInterval": [2673, 2709] }, null, [], ["alt", { "sourceInterval": [2687, 2709] }, ["terminal", { "sourceInterval": [2687, 2690] }, "<"], ["terminal", { "sourceInterval": [2693, 2696] }, ">"], ["terminal", { "sourceInterval": [2699, 2702] }, ","], ["terminal", { "sourceInterval": [2705, 2709] }, "--"]]] }]);
    var superSplicePlaceholder = Object.create(PExpr.prototype);
    function namespaceHas(ns, name) {
      for (const prop in ns) {
        if (prop === name)
          return true;
      }
      return false;
    }
    function buildGrammar(match2, namespace, optOhmGrammarForTesting) {
      const builder = new Builder();
      let decl;
      let currentRuleName;
      let currentRuleFormals;
      let overriding = false;
      const metaGrammar = optOhmGrammarForTesting || ohmGrammar;
      const helpers = metaGrammar.createSemantics().addOperation("visit", {
        Grammars(grammarIter) {
          return grammarIter.children.map((c) => c.visit());
        },
        Grammar(id, s, _open, rules, _close) {
          const grammarName = id.visit();
          decl = builder.newGrammar(grammarName);
          s.child(0) && s.child(0).visit();
          rules.children.map((c) => c.visit());
          const g = decl.build();
          g.source = this.source.trimmed();
          if (namespaceHas(namespace, grammarName)) {
            throw duplicateGrammarDeclaration(g);
          }
          namespace[grammarName] = g;
          return g;
        },
        SuperGrammar(_, n) {
          const superGrammarName = n.visit();
          if (superGrammarName === "null") {
            decl.withSuperGrammar(null);
          } else {
            if (!namespace || !namespaceHas(namespace, superGrammarName)) {
              throw undeclaredGrammar(superGrammarName, namespace, n.source);
            }
            decl.withSuperGrammar(namespace[superGrammarName]);
          }
        },
        Rule_define(n, fs5, d, _, b) {
          currentRuleName = n.visit();
          currentRuleFormals = fs5.children.map((c) => c.visit())[0] || [];
          if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
            decl.withDefaultStartRule(currentRuleName);
          }
          const body = b.visit();
          const description = d.children.map((c) => c.visit())[0];
          const source = this.source.trimmed();
          return decl.define(currentRuleName, currentRuleFormals, body, description, source);
        },
        Rule_override(n, fs5, _, b) {
          currentRuleName = n.visit();
          currentRuleFormals = fs5.children.map((c) => c.visit())[0] || [];
          const source = this.source.trimmed();
          decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);
          overriding = true;
          const body = b.visit();
          overriding = false;
          return decl.override(currentRuleName, currentRuleFormals, body, null, source);
        },
        Rule_extend(n, fs5, _, b) {
          currentRuleName = n.visit();
          currentRuleFormals = fs5.children.map((c) => c.visit())[0] || [];
          const body = b.visit();
          const source = this.source.trimmed();
          return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
        },
        RuleBody(_, terms) {
          return builder.alt(...terms.visit()).withSource(this.source);
        },
        OverrideRuleBody(_, terms) {
          const args = terms.visit();
          const expansionPos = args.indexOf(superSplicePlaceholder);
          if (expansionPos >= 0) {
            const beforeTerms = args.slice(0, expansionPos);
            const afterTerms = args.slice(expansionPos + 1);
            afterTerms.forEach((t) => {
              if (t === superSplicePlaceholder)
                throw multipleSuperSplices(t);
            });
            return new Splice(
              decl.superGrammar,
              currentRuleName,
              beforeTerms,
              afterTerms
            ).withSource(this.source);
          } else {
            return builder.alt(...args).withSource(this.source);
          }
        },
        Formals(opointy, fs5, cpointy) {
          return fs5.visit();
        },
        Params(opointy, ps, cpointy) {
          return ps.visit();
        },
        Alt(seqs) {
          return builder.alt(...seqs.visit()).withSource(this.source);
        },
        TopLevelTerm_inline(b, n) {
          const inlineRuleName = currentRuleName + "_" + n.visit();
          const body = b.visit();
          const source = this.source.trimmed();
          const isNewRuleDeclaration = !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
          if (overriding && !isNewRuleDeclaration) {
            decl.override(inlineRuleName, currentRuleFormals, body, null, source);
          } else {
            decl.define(inlineRuleName, currentRuleFormals, body, null, source);
          }
          const params = currentRuleFormals.map((formal) => builder.app(formal));
          return builder.app(inlineRuleName, params).withSource(body.source);
        },
        OverrideTopLevelTerm_superSplice(_) {
          return superSplicePlaceholder;
        },
        Seq(expr) {
          return builder.seq(...expr.children.map((c) => c.visit())).withSource(this.source);
        },
        Iter_star(x, _) {
          return builder.star(x.visit()).withSource(this.source);
        },
        Iter_plus(x, _) {
          return builder.plus(x.visit()).withSource(this.source);
        },
        Iter_opt(x, _) {
          return builder.opt(x.visit()).withSource(this.source);
        },
        Pred_not(_, x) {
          return builder.not(x.visit()).withSource(this.source);
        },
        Pred_lookahead(_, x) {
          return builder.lookahead(x.visit()).withSource(this.source);
        },
        Lex_lex(_, x) {
          return builder.lex(x.visit()).withSource(this.source);
        },
        Base_application(rule, ps) {
          const params = ps.children.map((c) => c.visit())[0] || [];
          return builder.app(rule.visit(), params).withSource(this.source);
        },
        Base_range(from, _, to) {
          return builder.range(from.visit(), to.visit()).withSource(this.source);
        },
        Base_terminal(expr) {
          return builder.terminal(expr.visit()).withSource(this.source);
        },
        Base_paren(open, x, close) {
          return x.visit();
        },
        ruleDescr(open, t, close) {
          return t.visit();
        },
        ruleDescrText(_) {
          return this.sourceString.trim();
        },
        caseName(_, space1, n, space2, end2) {
          return n.visit();
        },
        name(first, rest) {
          return this.sourceString;
        },
        nameFirst(expr) {
        },
        nameRest(expr) {
        },
        terminal(open, cs, close) {
          return cs.children.map((c) => c.visit()).join("");
        },
        oneCharTerminal(open, c, close) {
          return c.visit();
        },
        escapeChar(c) {
          try {
            return unescapeCodePoint(this.sourceString);
          } catch (err) {
            if (err instanceof RangeError && err.message.startsWith("Invalid code point ")) {
              throw invalidCodePoint(c);
            }
            throw err;
          }
        },
        NonemptyListOf(x, _, xs) {
          return [x.visit()].concat(xs.children.map((c) => c.visit()));
        },
        EmptyListOf() {
          return [];
        },
        _terminal() {
          return this.sourceString;
        }
      });
      return helpers(match2).visit();
    }
    var operationsAndAttributesGrammar = makeRecipe(["grammar", { "source": 'OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = "(" ListOf<name, ","> ")"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = "_"\n    | letter\n\n  nameRest\n    = "_"\n    | alnum\n\n}' }, "OperationsAndAttributes", null, "AttributeSignature", { "AttributeSignature": ["define", { "sourceInterval": [29, 58] }, null, [], ["app", { "sourceInterval": [54, 58] }, "name", []]], "OperationSignature": ["define", { "sourceInterval": [62, 100] }, null, [], ["seq", { "sourceInterval": [87, 100] }, ["app", { "sourceInterval": [87, 91] }, "name", []], ["opt", { "sourceInterval": [92, 100] }, ["app", { "sourceInterval": [92, 99] }, "Formals", []]]]], "Formals": ["define", { "sourceInterval": [104, 143] }, null, [], ["seq", { "sourceInterval": [118, 143] }, ["terminal", { "sourceInterval": [118, 121] }, "("], ["app", { "sourceInterval": [122, 139] }, "ListOf", [["app", { "sourceInterval": [129, 133] }, "name", []], ["terminal", { "sourceInterval": [135, 138] }, ","]]], ["terminal", { "sourceInterval": [140, 143] }, ")"]]], "name": ["define", { "sourceInterval": [147, 187] }, "a name", [], ["seq", { "sourceInterval": [168, 187] }, ["app", { "sourceInterval": [168, 177] }, "nameFirst", []], ["star", { "sourceInterval": [178, 187] }, ["app", { "sourceInterval": [178, 186] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [191, 223] }, null, [], ["alt", { "sourceInterval": [207, 223] }, ["terminal", { "sourceInterval": [207, 210] }, "_"], ["app", { "sourceInterval": [217, 223] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [227, 257] }, null, [], ["alt", { "sourceInterval": [242, 257] }, ["terminal", { "sourceInterval": [242, 245] }, "_"], ["app", { "sourceInterval": [252, 257] }, "alnum", []]]] }]);
    initBuiltInSemantics(Grammar.BuiltInRules);
    initPrototypeParser(operationsAndAttributesGrammar);
    function initBuiltInSemantics(builtInRules) {
      const actions = {
        empty() {
          return this.iteration();
        },
        nonEmpty(first, _, rest) {
          return this.iteration([first].concat(rest.children));
        },
        self(..._children) {
          return this;
        }
      };
      Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules, null).addOperation(
        "asIteration",
        {
          emptyListOf: actions.empty,
          nonemptyListOf: actions.nonEmpty,
          EmptyListOf: actions.empty,
          NonemptyListOf: actions.nonEmpty,
          _iter: actions.self
        }
      );
    }
    function initPrototypeParser(grammar2) {
      Semantics.prototypeGrammarSemantics = grammar2.createSemantics().addOperation("parse", {
        AttributeSignature(name) {
          return {
            name: name.parse(),
            formals: []
          };
        },
        OperationSignature(name, optFormals) {
          return {
            name: name.parse(),
            formals: optFormals.children.map((c) => c.parse())[0] || []
          };
        },
        Formals(oparen, fs5, cparen) {
          return fs5.asIteration().children.map((c) => c.parse());
        },
        name(first, rest) {
          return this.sourceString;
        }
      });
      Semantics.prototypeGrammar = grammar2;
    }
    function findIndentation(input) {
      let pos = 0;
      const stack = [0];
      const topOfStack = () => stack[stack.length - 1];
      const result = {};
      const regex = /( *).*(?:$|\r?\n|\r)/g;
      let match2;
      while ((match2 = regex.exec(input)) != null) {
        const [line, indent] = match2;
        if (line.length === 0)
          break;
        const indentSize = indent.length;
        const prevSize = topOfStack();
        const indentPos = pos + indentSize;
        if (indentSize > prevSize) {
          stack.push(indentSize);
          result[indentPos] = 1;
        } else if (indentSize < prevSize) {
          const prevLength = stack.length;
          while (topOfStack() !== indentSize) {
            stack.pop();
          }
          result[indentPos] = -1 * (prevLength - stack.length);
        }
        pos += line.length;
      }
      if (stack.length > 1) {
        result[pos] = 1 - stack.length;
      }
      return result;
    }
    var INDENT_DESCRIPTION = "an indented block";
    var DEDENT_DESCRIPTION = "a dedent";
    var INVALID_CODE_POINT = 1114111 + 1;
    var InputStreamWithIndentation = class extends InputStream {
      constructor(state) {
        super(state.input);
        this.state = state;
      }
      _indentationAt(pos) {
        return this.state.userData[pos] || 0;
      }
      atEnd() {
        return super.atEnd() && this._indentationAt(this.pos) === 0;
      }
      next() {
        if (this._indentationAt(this.pos) !== 0) {
          this.examinedLength = Math.max(this.examinedLength, this.pos);
          return void 0;
        }
        return super.next();
      }
      nextCharCode() {
        if (this._indentationAt(this.pos) !== 0) {
          this.examinedLength = Math.max(this.examinedLength, this.pos);
          return INVALID_CODE_POINT;
        }
        return super.nextCharCode();
      }
      nextCodePoint() {
        if (this._indentationAt(this.pos) !== 0) {
          this.examinedLength = Math.max(this.examinedLength, this.pos);
          return INVALID_CODE_POINT;
        }
        return super.nextCodePoint();
      }
    };
    var Indentation = class extends PExpr {
      constructor(isIndent = true) {
        super();
        this.isIndent = isIndent;
      }
      allowsSkippingPrecedingSpace() {
        return true;
      }
      eval(state) {
        const { inputStream } = state;
        const pseudoTokens = state.userData;
        state.doNotMemoize = true;
        const origPos = inputStream.pos;
        const sign = this.isIndent ? 1 : -1;
        const count = (pseudoTokens[origPos] || 0) * sign;
        if (count > 0) {
          state.userData = Object.create(pseudoTokens);
          state.userData[origPos] -= sign;
          state.pushBinding(new TerminalNode(0), origPos);
          return true;
        } else {
          state.processFailure(origPos, this);
          return false;
        }
      }
      getArity() {
        return 1;
      }
      _assertAllApplicationsAreValid(ruleName, grammar2) {
      }
      _isNullable(grammar2, memo) {
        return false;
      }
      assertChoicesHaveUniformArity(ruleName) {
      }
      assertIteratedExprsAreNotNullable(grammar2) {
      }
      introduceParams(formals) {
        return this;
      }
      substituteParams(actuals) {
        return this;
      }
      toString() {
        return this.isIndent ? "indent" : "dedent";
      }
      toDisplayString() {
        return this.toString();
      }
      toFailure(grammar2) {
        const description = this.isIndent ? INDENT_DESCRIPTION : DEDENT_DESCRIPTION;
        return new Failure(this, description, "description");
      }
    };
    var applyIndent = new Apply("indent");
    var applyDedent = new Apply("dedent");
    var newAnyBody = new Splice(BuiltInRules, "any", [applyIndent, applyDedent], []);
    var IndentationSensitive = new Builder().newGrammar("IndentationSensitive").withSuperGrammar(BuiltInRules).define("indent", [], new Indentation(true), INDENT_DESCRIPTION, void 0, true).define("dedent", [], new Indentation(false), DEDENT_DESCRIPTION, void 0, true).extend("any", [], newAnyBody, "any character", void 0).build();
    Object.assign(IndentationSensitive, {
      _matchStateInitializer(state) {
        state.userData = findIndentation(state.input);
        state.inputStream = new InputStreamWithIndentation(state);
      },
      supportsIncrementalParsing: false
    });
    var version2 = "17.2.1";
    Grammar.initApplicationParser(ohmGrammar, buildGrammar);
    var isBuffer = (obj) => !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    function compileAndLoad(source, namespace) {
      const m = ohmGrammar.match(source, "Grammars");
      if (m.failed()) {
        throw grammarSyntaxError(m);
      }
      return buildGrammar(m, namespace);
    }
    function grammar(source, optNamespace) {
      const ns = grammars(source, optNamespace);
      const grammarNames = Object.keys(ns);
      if (grammarNames.length === 0) {
        throw new Error("Missing grammar definition");
      } else if (grammarNames.length > 1) {
        const secondGrammar = ns[grammarNames[1]];
        const interval = secondGrammar.source;
        throw new Error(
          getLineAndColumnMessage(interval.sourceString, interval.startIdx) + "Found more than one grammar definition -- use ohm.grammars() instead."
        );
      }
      return ns[grammarNames[0]];
    }
    function grammars(source, optNamespace) {
      const ns = Object.create(optNamespace || {});
      if (typeof source !== "string") {
        if (isBuffer(source)) {
          source = source.toString();
        } else {
          throw new TypeError(
            "Expected string as first argument, got " + unexpectedObjToString(source)
          );
        }
      }
      compileAndLoad(source, ns);
      return ns;
    }
    exports.ExperimentalIndentationSensitive = IndentationSensitive;
    exports._buildGrammar = buildGrammar;
    exports.grammar = grammar;
    exports.grammars = grammars;
    exports.makeRecipe = makeRecipe;
    exports.ohmGrammar = ohmGrammar;
    exports.pexprs = pexprs;
    exports.version = version2;
  }
});

// ../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/pep-508.ohm-bundle.js
var require_pep_508_ohm_bundle = __commonJS({
  "../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/pep-508.ohm-bundle.js"(exports, module2) {
    "use strict";
    var { makeRecipe } = require_ohm();
    var result = makeRecipe(["grammar", { "source": `PEP508 {
    // Grammar adapted from https://peps.python.org/pep-0508/#complete-grammar
    // (naming retained, just reordered and camelCased)
    File = ListOf<Line, "\\n">
    Line = Req? comment?
    Req = UrlReq | NameReq | RequirementsReq | ConstraintsReq

    NameReq = Name Extras? VersionSpec QuotedMarker?
    UrlReq  = Name Extras? UrlSpec (space QuotedMarker)?
    Extras  = "[" ListOf<identifier, ","> "]"
    Name    = identifier
    identifier    = alnum identifierEnd*
    identifierEnd = alnum -- single
                  | (("-" | "_" | "." )* alnum) -- multi

    // Requirements based on other requirements files (not in PEP 508, but supported by pip)
    RequirementsReq = "-r" filePath
    ConstraintsReq  = "-c" filePath
    filePath        = (~("\\n" | "#") any)+

    UrlSpec      = "@" uriReference
    uriReference = uri | relativeRef
    uri          = scheme ":" hierPart? ("?" query )? ("#" fragment)?
    hierPart     = ("//" authority pathAbempty) -- abempty
                 | pathAbsolute -- absolute
                 | pathRootless -- rootless
    absoluteUri  = scheme ":" hierPart? ("?" query )?
    relativeRef  = relativePart? ("?" query )? ("#" fragment )?
    relativePart = "//" authority pathAbempty -- abempty
                 | pathAbsolute -- absolute
                 | pathNoscheme -- noscheme
    scheme       = letter (alnum | "+" | "-" | ".")*
    authority    = (userinfo "@" )? host (":" port )?
    userinfo     = (unreserved | pctEncoded | subDelims | ":")*
    host         = ipLiteral | ipv4Address | regName
    port         = digit*
    ipLiteral    = "[" (ipv6Address | ipvFuture) "]"
    ipvFuture    = "v" hexdig+ "." (unreserved | subDelims | ":")+
    ipv6Address  = (hexdig | ":" | ".")+ // dumbed down a lot, mostly due to lack of quantifier support in Ohm
    ipv4Address  = decOctet "." decOctet "." decOctet "." decOctet
    nz           = ~"0" digit
    decOctet     = digit -- zeroToNine
                 | nz digit -- tenToNinetyNine
                 | "1" digit digit -- oneHundredToOneNinetyNine
                 | "2" ("0" | "1" | "2" | "3" | "4") digit -- twoHundredToTwoFortyNine
                 | "25" ("0" | "1" | "2" | "3" | "4" | "5") -- twoFiftyToTwoFiftyFive
    regName      = (unreserved | pctEncoded | subDelims)*
    path         = pathAbempty // begins with "/" or is empty
                 | pathAbsolute // begins with "/" but not "//"
                 | pathNoscheme // begins with a non-colon segment
                 | pathRootless // begins with a segment
    pathAbempty  = ("/" segment)*
    pathAbsolute = "/" (segmentNz ("/" segment)* )?
    pathNoscheme = segmentNzNc ("/" segment)*
    pathRootless = segmentNz ("/" segment)*
    segment      = pchar*
    segmentNz    = pchar+
    segmentNzNc  = (unreserved | pctEncoded | subDelims | "@")+ // non-zero-length segment without any colon ":"
    pchar        = unreserved | pctEncoded | subDelims | ":" | "@"
    query        = (pchar | "/" | "?")*
    fragment     = (pchar | "/" | "?")*
    pctEncoded   = "%" hexdig
    unreserved   = alnum | "-" | "." | "_" | "~"
    reserved     = genDelims | subDelims
    genDelims    = ":" | "/" | "?" | "#" | "(" | ")?" | "@"
    subDelims    = "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "="
    hexdig       = digit | "a" | "A" | "b" | "B" | "c" | "C" | "d" | "D" | "e" | "E" | "f" | "F"

    // Environment markers
    QuotedMarker  = ";" Marker
    Marker        = MarkerOr
    MarkerOr      = MarkerAnd "or" MarkerAnd -- node
                  | MarkerAnd -- leaf
    MarkerAnd     = MarkerExpr "and" MarkerExpr -- node
                  | MarkerExpr -- leaf
    MarkerExpr    = MarkerVar markerOp MarkerVar -- leaf
                  | "(" Marker ")" -- node
    MarkerVar     = envVar | pythonStr
    markerOp      = versionCmp -- versionCmp
                  | "in" -- in
                  | ("not" space+ "in") -- notIn
    pythonStr     = "'" (pythonStrChar | "\\"")* "'"
                  | "\\"" (pythonStrChar | "'")* "\\""
    pythonStrChar = space | alnum | "(" | ")" | "." | "{" | "}" | "-" | "_" | "*" | "#" | ":" | ";" | "," | "/" | "?"
                  | "[" | "]" | "!" | "~" | "\`" | "@" | "$" | "%" | "^" | "&" | "=" | "+" | "|" | "<" | ">"
    envVar        = "python_version" | "python_full_version" | "os_name" | "sys_platform" | "platform_release"
                  | "platform_system" | "platform_version" | "platform_machine" | "platform_python_implementation"
                  | "implementation_name" | "implementation_version" | "extra" // ONLY when defined by a containing layer

    // Version specifiers, defined in PEP 440 (https://peps.python.org/pep-0440/)
    VersionSpec   = "(" VersionMany ")" -- parenthesized
                  | VersionMany -- direct
    VersionMany   = ListOf<VersionOne, ",">
    VersionOne    = versionCmp version
    versionCmp    = "<=" | "<" | "!=" | "==" | ">=" | ">" | "~=" | "==="
    version       = (alnum | "-" | "_" | "." | "*" | "+" | "!" )+

    comment = "#" (~"\\n" any)*

    space := " " | "\\t" // Overriding Ohm's definition of whitespace to kick out newlines and other Unicode whitespace

    // Loose grammar for parsing unfinished requirements - focused on extracting the name, extras, and version spec
    LooseFile         = ListOf<LooseLine, "\\n">
    LooseLine         = LooseReq comment?
    LooseReq          = LooseNonNameReq | LooseNameReq
    LooseNameReq      = Name LooseExtras? LooseVersionSpec LooseQuotedMarker?
    LooseNonNameReq   = (~(~(Name "@") Name) looseAnything) // Non-name req can start with Name only if followed by "@"
    LooseExtras       = "[" ListOf<identifier, ","> ","* "]"?
    LooseQuotedMarker = ";" looseAnything
    LooseVersionSpec  = "(" LooseVersionMany ")"? -- parenthesized
                      | LooseVersionMany -- direct
    LooseVersionMany  = ListOf<LooseVersionOne, ","> ","*
    LooseVersionOne   = looseVersionCmp looseVersion?
    looseVersionCmp   = ("<" | "=" | "!" | ">" | "~")+
    looseVersion      = (alnum | "-" | "_" | "." | "*" | "+" | "!" )+
    looseAnything     = (~("\\n" | "#") any)* // Any non-comment line content
}` }, "PEP508", null, "File", { "File": ["define", { "sourceInterval": [148, 173] }, null, [], ["app", { "sourceInterval": [155, 173] }, "ListOf", [["app", { "sourceInterval": [162, 166] }, "Line", []], ["terminal", { "sourceInterval": [168, 172] }, "\n"]]]], "Line": ["define", { "sourceInterval": [178, 198] }, null, [], ["seq", { "sourceInterval": [185, 198] }, ["opt", { "sourceInterval": [185, 189] }, ["app", { "sourceInterval": [185, 188] }, "Req", []]], ["opt", { "sourceInterval": [190, 198] }, ["app", { "sourceInterval": [190, 197] }, "comment", []]]]], "Req": ["define", { "sourceInterval": [203, 260] }, null, [], ["alt", { "sourceInterval": [209, 260] }, ["app", { "sourceInterval": [209, 215] }, "UrlReq", []], ["app", { "sourceInterval": [218, 225] }, "NameReq", []], ["app", { "sourceInterval": [228, 243] }, "RequirementsReq", []], ["app", { "sourceInterval": [246, 260] }, "ConstraintsReq", []]]], "NameReq": ["define", { "sourceInterval": [266, 314] }, null, [], ["seq", { "sourceInterval": [276, 314] }, ["app", { "sourceInterval": [276, 280] }, "Name", []], ["opt", { "sourceInterval": [281, 288] }, ["app", { "sourceInterval": [281, 287] }, "Extras", []]], ["app", { "sourceInterval": [289, 300] }, "VersionSpec", []], ["opt", { "sourceInterval": [301, 314] }, ["app", { "sourceInterval": [301, 313] }, "QuotedMarker", []]]]], "UrlReq": ["define", { "sourceInterval": [319, 371] }, null, [], ["seq", { "sourceInterval": [329, 371] }, ["app", { "sourceInterval": [329, 333] }, "Name", []], ["opt", { "sourceInterval": [334, 341] }, ["app", { "sourceInterval": [334, 340] }, "Extras", []]], ["app", { "sourceInterval": [342, 349] }, "UrlSpec", []], ["opt", { "sourceInterval": [350, 371] }, ["seq", { "sourceInterval": [351, 369] }, ["app", { "sourceInterval": [351, 356] }, "space", []], ["app", { "sourceInterval": [357, 369] }, "QuotedMarker", []]]]]], "Extras": ["define", { "sourceInterval": [376, 417] }, null, [], ["seq", { "sourceInterval": [386, 417] }, ["terminal", { "sourceInterval": [386, 389] }, "["], ["app", { "sourceInterval": [390, 413] }, "ListOf", [["app", { "sourceInterval": [397, 407] }, "identifier", []], ["terminal", { "sourceInterval": [409, 412] }, ","]]], ["terminal", { "sourceInterval": [414, 417] }, "]"]]], "Name": ["define", { "sourceInterval": [422, 442] }, null, [], ["app", { "sourceInterval": [432, 442] }, "identifier", []]], "identifier": ["define", { "sourceInterval": [447, 483] }, null, [], ["seq", { "sourceInterval": [463, 483] }, ["app", { "sourceInterval": [463, 468] }, "alnum", []], ["star", { "sourceInterval": [469, 483] }, ["app", { "sourceInterval": [469, 482] }, "identifierEnd", []]]]], "identifierEnd_single": ["define", { "sourceInterval": [504, 519] }, null, [], ["app", { "sourceInterval": [504, 509] }, "alnum", []]], "identifierEnd_multi": ["define", { "sourceInterval": [540, 576] }, null, [], ["seq", { "sourceInterval": [540, 567] }, ["star", { "sourceInterval": [541, 560] }, ["alt", { "sourceInterval": [542, 557] }, ["terminal", { "sourceInterval": [542, 545] }, "-"], ["terminal", { "sourceInterval": [548, 551] }, "_"], ["terminal", { "sourceInterval": [554, 557] }, "."]]], ["app", { "sourceInterval": [561, 566] }, "alnum", []]]], "identifierEnd": ["define", { "sourceInterval": [488, 576] }, null, [], ["alt", { "sourceInterval": [504, 576] }, ["app", { "sourceInterval": [504, 509] }, "identifierEnd_single", []], ["app", { "sourceInterval": [540, 567] }, "identifierEnd_multi", []]]], "RequirementsReq": ["define", { "sourceInterval": [675, 706] }, null, [], ["seq", { "sourceInterval": [693, 706] }, ["terminal", { "sourceInterval": [693, 697] }, "-r"], ["app", { "sourceInterval": [698, 706] }, "filePath", []]]], "ConstraintsReq": ["define", { "sourceInterval": [711, 742] }, null, [], ["seq", { "sourceInterval": [729, 742] }, ["terminal", { "sourceInterval": [729, 733] }, "-c"], ["app", { "sourceInterval": [734, 742] }, "filePath", []]]], "filePath": ["define", { "sourceInterval": [747, 785] }, null, [], ["plus", { "sourceInterval": [765, 785] }, ["seq", { "sourceInterval": [766, 783] }, ["not", { "sourceInterval": [766, 779] }, ["alt", { "sourceInterval": [768, 778] }, ["terminal", { "sourceInterval": [768, 772] }, "\n"], ["terminal", { "sourceInterval": [775, 778] }, "#"]]], ["app", { "sourceInterval": [780, 783] }, "any", []]]]], "UrlSpec": ["define", { "sourceInterval": [791, 822] }, null, [], ["seq", { "sourceInterval": [806, 822] }, ["terminal", { "sourceInterval": [806, 809] }, "@"], ["app", { "sourceInterval": [810, 822] }, "uriReference", []]]], "uriReference": ["define", { "sourceInterval": [827, 859] }, null, [], ["alt", { "sourceInterval": [842, 859] }, ["app", { "sourceInterval": [842, 845] }, "uri", []], ["app", { "sourceInterval": [848, 859] }, "relativeRef", []]]], "uri": ["define", { "sourceInterval": [864, 929] }, null, [], ["seq", { "sourceInterval": [879, 929] }, ["app", { "sourceInterval": [879, 885] }, "scheme", []], ["terminal", { "sourceInterval": [886, 889] }, ":"], ["opt", { "sourceInterval": [890, 899] }, ["app", { "sourceInterval": [890, 898] }, "hierPart", []]], ["opt", { "sourceInterval": [900, 913] }, ["seq", { "sourceInterval": [901, 910] }, ["terminal", { "sourceInterval": [901, 904] }, "?"], ["app", { "sourceInterval": [905, 910] }, "query", []]]], ["opt", { "sourceInterval": [914, 929] }, ["seq", { "sourceInterval": [915, 927] }, ["terminal", { "sourceInterval": [915, 918] }, "#"], ["app", { "sourceInterval": [919, 927] }, "fragment", []]]]]], "hierPart_abempty": ["define", { "sourceInterval": [949, 988] }, null, [], ["seq", { "sourceInterval": [949, 977] }, ["terminal", { "sourceInterval": [950, 954] }, "//"], ["app", { "sourceInterval": [955, 964] }, "authority", []], ["app", { "sourceInterval": [965, 976] }, "pathAbempty", []]]], "hierPart_absolute": ["define", { "sourceInterval": [1008, 1032] }, null, [], ["app", { "sourceInterval": [1008, 1020] }, "pathAbsolute", []]], "hierPart_rootless": ["define", { "sourceInterval": [1052, 1076] }, null, [], ["app", { "sourceInterval": [1052, 1064] }, "pathRootless", []]], "hierPart": ["define", { "sourceInterval": [934, 1076] }, null, [], ["alt", { "sourceInterval": [949, 1076] }, ["app", { "sourceInterval": [949, 977] }, "hierPart_abempty", []], ["app", { "sourceInterval": [1008, 1020] }, "hierPart_absolute", []], ["app", { "sourceInterval": [1052, 1064] }, "hierPart_rootless", []]]], "absoluteUri": ["define", { "sourceInterval": [1081, 1130] }, null, [], ["seq", { "sourceInterval": [1096, 1130] }, ["app", { "sourceInterval": [1096, 1102] }, "scheme", []], ["terminal", { "sourceInterval": [1103, 1106] }, ":"], ["opt", { "sourceInterval": [1107, 1116] }, ["app", { "sourceInterval": [1107, 1115] }, "hierPart", []]], ["opt", { "sourceInterval": [1117, 1130] }, ["seq", { "sourceInterval": [1118, 1127] }, ["terminal", { "sourceInterval": [1118, 1121] }, "?"], ["app", { "sourceInterval": [1122, 1127] }, "query", []]]]]], "relativeRef": ["define", { "sourceInterval": [1135, 1194] }, null, [], ["seq", { "sourceInterval": [1150, 1194] }, ["opt", { "sourceInterval": [1150, 1163] }, ["app", { "sourceInterval": [1150, 1162] }, "relativePart", []]], ["opt", { "sourceInterval": [1164, 1177] }, ["seq", { "sourceInterval": [1165, 1174] }, ["terminal", { "sourceInterval": [1165, 1168] }, "?"], ["app", { "sourceInterval": [1169, 1174] }, "query", []]]], ["opt", { "sourceInterval": [1178, 1194] }, ["seq", { "sourceInterval": [1179, 1191] }, ["terminal", { "sourceInterval": [1179, 1182] }, "#"], ["app", { "sourceInterval": [1183, 1191] }, "fragment", []]]]]], "relativePart_abempty": ["define", { "sourceInterval": [1214, 1251] }, null, [], ["seq", { "sourceInterval": [1214, 1240] }, ["terminal", { "sourceInterval": [1214, 1218] }, "//"], ["app", { "sourceInterval": [1219, 1228] }, "authority", []], ["app", { "sourceInterval": [1229, 1240] }, "pathAbempty", []]]], "relativePart_absolute": ["define", { "sourceInterval": [1271, 1295] }, null, [], ["app", { "sourceInterval": [1271, 1283] }, "pathAbsolute", []]], "relativePart_noscheme": ["define", { "sourceInterval": [1315, 1339] }, null, [], ["app", { "sourceInterval": [1315, 1327] }, "pathNoscheme", []]], "relativePart": ["define", { "sourceInterval": [1199, 1339] }, null, [], ["alt", { "sourceInterval": [1214, 1339] }, ["app", { "sourceInterval": [1214, 1240] }, "relativePart_abempty", []], ["app", { "sourceInterval": [1271, 1283] }, "relativePart_absolute", []], ["app", { "sourceInterval": [1315, 1327] }, "relativePart_noscheme", []]]], "scheme": ["define", { "sourceInterval": [1344, 1392] }, null, [], ["seq", { "sourceInterval": [1359, 1392] }, ["app", { "sourceInterval": [1359, 1365] }, "letter", []], ["star", { "sourceInterval": [1366, 1392] }, ["alt", { "sourceInterval": [1367, 1390] }, ["app", { "sourceInterval": [1367, 1372] }, "alnum", []], ["terminal", { "sourceInterval": [1375, 1378] }, "+"], ["terminal", { "sourceInterval": [1381, 1384] }, "-"], ["terminal", { "sourceInterval": [1387, 1390] }, "."]]]]], "authority": ["define", { "sourceInterval": [1397, 1446] }, null, [], ["seq", { "sourceInterval": [1412, 1446] }, ["opt", { "sourceInterval": [1412, 1428] }, ["seq", { "sourceInterval": [1413, 1425] }, ["app", { "sourceInterval": [1413, 1421] }, "userinfo", []], ["terminal", { "sourceInterval": [1422, 1425] }, "@"]]], ["app", { "sourceInterval": [1429, 1433] }, "host", []], ["opt", { "sourceInterval": [1434, 1446] }, ["seq", { "sourceInterval": [1435, 1443] }, ["terminal", { "sourceInterval": [1435, 1438] }, ":"], ["app", { "sourceInterval": [1439, 1443] }, "port", []]]]]], "userinfo": ["define", { "sourceInterval": [1451, 1510] }, null, [], ["star", { "sourceInterval": [1466, 1510] }, ["alt", { "sourceInterval": [1467, 1508] }, ["app", { "sourceInterval": [1467, 1477] }, "unreserved", []], ["app", { "sourceInterval": [1480, 1490] }, "pctEncoded", []], ["app", { "sourceInterval": [1493, 1502] }, "subDelims", []], ["terminal", { "sourceInterval": [1505, 1508] }, ":"]]]], "host": ["define", { "sourceInterval": [1515, 1563] }, null, [], ["alt", { "sourceInterval": [1530, 1563] }, ["app", { "sourceInterval": [1530, 1539] }, "ipLiteral", []], ["app", { "sourceInterval": [1542, 1553] }, "ipv4Address", []], ["app", { "sourceInterval": [1556, 1563] }, "regName", []]]], "port": ["define", { "sourceInterval": [1568, 1589] }, null, [], ["star", { "sourceInterval": [1583, 1589] }, ["app", { "sourceInterval": [1583, 1588] }, "digit", []]]], "ipLiteral": ["define", { "sourceInterval": [1594, 1642] }, null, [], ["seq", { "sourceInterval": [1609, 1642] }, ["terminal", { "sourceInterval": [1609, 1612] }, "["], ["alt", { "sourceInterval": [1614, 1637] }, ["app", { "sourceInterval": [1614, 1625] }, "ipv6Address", []], ["app", { "sourceInterval": [1628, 1637] }, "ipvFuture", []]], ["terminal", { "sourceInterval": [1639, 1642] }, "]"]]], "ipvFuture": ["define", { "sourceInterval": [1647, 1709] }, null, [], ["seq", { "sourceInterval": [1662, 1709] }, ["terminal", { "sourceInterval": [1662, 1665] }, "v"], ["plus", { "sourceInterval": [1666, 1673] }, ["app", { "sourceInterval": [1666, 1672] }, "hexdig", []]], ["terminal", { "sourceInterval": [1674, 1677] }, "."], ["plus", { "sourceInterval": [1678, 1709] }, ["alt", { "sourceInterval": [1679, 1707] }, ["app", { "sourceInterval": [1679, 1689] }, "unreserved", []], ["app", { "sourceInterval": [1692, 1701] }, "subDelims", []], ["terminal", { "sourceInterval": [1704, 1707] }, ":"]]]]], "ipv6Address": ["define", { "sourceInterval": [1714, 1750] }, null, [], ["plus", { "sourceInterval": [1729, 1750] }, ["alt", { "sourceInterval": [1730, 1748] }, ["app", { "sourceInterval": [1730, 1736] }, "hexdig", []], ["terminal", { "sourceInterval": [1739, 1742] }, ":"], ["terminal", { "sourceInterval": [1745, 1748] }, "."]]]], "ipv4Address": ["define", { "sourceInterval": [1825, 1887] }, null, [], ["seq", { "sourceInterval": [1840, 1887] }, ["app", { "sourceInterval": [1840, 1848] }, "decOctet", []], ["terminal", { "sourceInterval": [1849, 1852] }, "."], ["app", { "sourceInterval": [1853, 1861] }, "decOctet", []], ["terminal", { "sourceInterval": [1862, 1865] }, "."], ["app", { "sourceInterval": [1866, 1874] }, "decOctet", []], ["terminal", { "sourceInterval": [1875, 1878] }, "."], ["app", { "sourceInterval": [1879, 1887] }, "decOctet", []]]], "nz": ["define", { "sourceInterval": [1892, 1917] }, null, [], ["seq", { "sourceInterval": [1907, 1917] }, ["not", { "sourceInterval": [1907, 1911] }, ["terminal", { "sourceInterval": [1908, 1911] }, "0"]], ["app", { "sourceInterval": [1912, 1917] }, "digit", []]]], "decOctet_zeroToNine": ["define", { "sourceInterval": [1937, 1956] }, null, [], ["app", { "sourceInterval": [1937, 1942] }, "digit", []]], "decOctet_tenToNinetyNine": ["define", { "sourceInterval": [1976, 2003] }, null, [], ["seq", { "sourceInterval": [1976, 1984] }, ["app", { "sourceInterval": [1976, 1978] }, "nz", []], ["app", { "sourceInterval": [1979, 1984] }, "digit", []]]], "decOctet_oneHundredToOneNinetyNine": ["define", { "sourceInterval": [2023, 2067] }, null, [], ["seq", { "sourceInterval": [2023, 2038] }, ["terminal", { "sourceInterval": [2023, 2026] }, "1"], ["app", { "sourceInterval": [2027, 2032] }, "digit", []], ["app", { "sourceInterval": [2033, 2038] }, "digit", []]]], "decOctet_twoHundredToTwoFortyNine": ["define", { "sourceInterval": [2087, 2154] }, null, [], ["seq", { "sourceInterval": [2087, 2126] }, ["terminal", { "sourceInterval": [2087, 2090] }, "2"], ["alt", { "sourceInterval": [2092, 2119] }, ["terminal", { "sourceInterval": [2092, 2095] }, "0"], ["terminal", { "sourceInterval": [2098, 2101] }, "1"], ["terminal", { "sourceInterval": [2104, 2107] }, "2"], ["terminal", { "sourceInterval": [2110, 2113] }, "3"], ["terminal", { "sourceInterval": [2116, 2119] }, "4"]], ["app", { "sourceInterval": [2121, 2126] }, "digit", []]]], "decOctet_twoFiftyToTwoFiftyFive": ["define", { "sourceInterval": [2174, 2240] }, null, [], ["seq", { "sourceInterval": [2174, 2214] }, ["terminal", { "sourceInterval": [2174, 2178] }, "25"], ["alt", { "sourceInterval": [2180, 2213] }, ["terminal", { "sourceInterval": [2180, 2183] }, "0"], ["terminal", { "sourceInterval": [2186, 2189] }, "1"], ["terminal", { "sourceInterval": [2192, 2195] }, "2"], ["terminal", { "sourceInterval": [2198, 2201] }, "3"], ["terminal", { "sourceInterval": [2204, 2207] }, "4"], ["terminal", { "sourceInterval": [2210, 2213] }, "5"]]]], "decOctet": ["define", { "sourceInterval": [1922, 2240] }, null, [], ["alt", { "sourceInterval": [1937, 2240] }, ["app", { "sourceInterval": [1937, 1942] }, "decOctet_zeroToNine", []], ["app", { "sourceInterval": [1976, 1984] }, "decOctet_tenToNinetyNine", []], ["app", { "sourceInterval": [2023, 2038] }, "decOctet_oneHundredToOneNinetyNine", []], ["app", { "sourceInterval": [2087, 2126] }, "decOctet_twoHundredToTwoFortyNine", []], ["app", { "sourceInterval": [2174, 2214] }, "decOctet_twoFiftyToTwoFiftyFive", []]]], "regName": ["define", { "sourceInterval": [2245, 2298] }, null, [], ["star", { "sourceInterval": [2260, 2298] }, ["alt", { "sourceInterval": [2261, 2296] }, ["app", { "sourceInterval": [2261, 2271] }, "unreserved", []], ["app", { "sourceInterval": [2274, 2284] }, "pctEncoded", []], ["app", { "sourceInterval": [2287, 2296] }, "subDelims", []]]]], "path": ["define", { "sourceInterval": [2303, 2523] }, null, [], ["alt", { "sourceInterval": [2318, 2523] }, ["app", { "sourceInterval": [2318, 2329] }, "pathAbempty", []], ["app", { "sourceInterval": [2380, 2392] }, "pathAbsolute", []], ["app", { "sourceInterval": [2444, 2456] }, "pathNoscheme", []], ["app", { "sourceInterval": [2511, 2523] }, "pathRootless", []]]], "pathAbempty": ["define", { "sourceInterval": [2553, 2582] }, null, [], ["star", { "sourceInterval": [2568, 2582] }, ["seq", { "sourceInterval": [2569, 2580] }, ["terminal", { "sourceInterval": [2569, 2572] }, "/"], ["app", { "sourceInterval": [2573, 2580] }, "segment", []]]]], "pathAbsolute": ["define", { "sourceInterval": [2587, 2634] }, null, [], ["seq", { "sourceInterval": [2602, 2634] }, ["terminal", { "sourceInterval": [2602, 2605] }, "/"], ["opt", { "sourceInterval": [2606, 2634] }, ["seq", { "sourceInterval": [2607, 2631] }, ["app", { "sourceInterval": [2607, 2616] }, "segmentNz", []], ["star", { "sourceInterval": [2617, 2631] }, ["seq", { "sourceInterval": [2618, 2629] }, ["terminal", { "sourceInterval": [2618, 2621] }, "/"], ["app", { "sourceInterval": [2622, 2629] }, "segment", []]]]]]]], "pathNoscheme": ["define", { "sourceInterval": [2639, 2680] }, null, [], ["seq", { "sourceInterval": [2654, 2680] }, ["app", { "sourceInterval": [2654, 2665] }, "segmentNzNc", []], ["star", { "sourceInterval": [2666, 2680] }, ["seq", { "sourceInterval": [2667, 2678] }, ["terminal", { "sourceInterval": [2667, 2670] }, "/"], ["app", { "sourceInterval": [2671, 2678] }, "segment", []]]]]], "pathRootless": ["define", { "sourceInterval": [2685, 2724] }, null, [], ["seq", { "sourceInterval": [2700, 2724] }, ["app", { "sourceInterval": [2700, 2709] }, "segmentNz", []], ["star", { "sourceInterval": [2710, 2724] }, ["seq", { "sourceInterval": [2711, 2722] }, ["terminal", { "sourceInterval": [2711, 2714] }, "/"], ["app", { "sourceInterval": [2715, 2722] }, "segment", []]]]]], "segment": ["define", { "sourceInterval": [2729, 2750] }, null, [], ["star", { "sourceInterval": [2744, 2750] }, ["app", { "sourceInterval": [2744, 2749] }, "pchar", []]]], "segmentNz": ["define", { "sourceInterval": [2755, 2776] }, null, [], ["plus", { "sourceInterval": [2770, 2776] }, ["app", { "sourceInterval": [2770, 2775] }, "pchar", []]]], "segmentNzNc": ["define", { "sourceInterval": [2781, 2840] }, null, [], ["plus", { "sourceInterval": [2796, 2840] }, ["alt", { "sourceInterval": [2797, 2838] }, ["app", { "sourceInterval": [2797, 2807] }, "unreserved", []], ["app", { "sourceInterval": [2810, 2820] }, "pctEncoded", []], ["app", { "sourceInterval": [2823, 2832] }, "subDelims", []], ["terminal", { "sourceInterval": [2835, 2838] }, "@"]]]], "pchar": ["define", { "sourceInterval": [2894, 2956] }, null, [], ["alt", { "sourceInterval": [2909, 2956] }, ["app", { "sourceInterval": [2909, 2919] }, "unreserved", []], ["app", { "sourceInterval": [2922, 2932] }, "pctEncoded", []], ["app", { "sourceInterval": [2935, 2944] }, "subDelims", []], ["terminal", { "sourceInterval": [2947, 2950] }, ":"], ["terminal", { "sourceInterval": [2953, 2956] }, "@"]]], "query": ["define", { "sourceInterval": [2961, 2996] }, null, [], ["star", { "sourceInterval": [2976, 2996] }, ["alt", { "sourceInterval": [2977, 2994] }, ["app", { "sourceInterval": [2977, 2982] }, "pchar", []], ["terminal", { "sourceInterval": [2985, 2988] }, "/"], ["terminal", { "sourceInterval": [2991, 2994] }, "?"]]]], "fragment": ["define", { "sourceInterval": [3001, 3036] }, null, [], ["star", { "sourceInterval": [3016, 3036] }, ["alt", { "sourceInterval": [3017, 3034] }, ["app", { "sourceInterval": [3017, 3022] }, "pchar", []], ["terminal", { "sourceInterval": [3025, 3028] }, "/"], ["terminal", { "sourceInterval": [3031, 3034] }, "?"]]]], "pctEncoded": ["define", { "sourceInterval": [3041, 3066] }, null, [], ["seq", { "sourceInterval": [3056, 3066] }, ["terminal", { "sourceInterval": [3056, 3059] }, "%"], ["app", { "sourceInterval": [3060, 3066] }, "hexdig", []]]], "unreserved": ["define", { "sourceInterval": [3071, 3115] }, null, [], ["alt", { "sourceInterval": [3086, 3115] }, ["app", { "sourceInterval": [3086, 3091] }, "alnum", []], ["terminal", { "sourceInterval": [3094, 3097] }, "-"], ["terminal", { "sourceInterval": [3100, 3103] }, "."], ["terminal", { "sourceInterval": [3106, 3109] }, "_"], ["terminal", { "sourceInterval": [3112, 3115] }, "~"]]], "reserved": ["define", { "sourceInterval": [3120, 3156] }, null, [], ["alt", { "sourceInterval": [3135, 3156] }, ["app", { "sourceInterval": [3135, 3144] }, "genDelims", []], ["app", { "sourceInterval": [3147, 3156] }, "subDelims", []]]], "genDelims": ["define", { "sourceInterval": [3161, 3216] }, null, [], ["alt", { "sourceInterval": [3176, 3216] }, ["terminal", { "sourceInterval": [3176, 3179] }, ":"], ["terminal", { "sourceInterval": [3182, 3185] }, "/"], ["terminal", { "sourceInterval": [3188, 3191] }, "?"], ["terminal", { "sourceInterval": [3194, 3197] }, "#"], ["terminal", { "sourceInterval": [3200, 3203] }, "("], ["terminal", { "sourceInterval": [3206, 3210] }, ")?"], ["terminal", { "sourceInterval": [3213, 3216] }, "@"]]], "subDelims": ["define", { "sourceInterval": [3221, 3299] }, null, [], ["alt", { "sourceInterval": [3236, 3299] }, ["terminal", { "sourceInterval": [3236, 3239] }, "!"], ["terminal", { "sourceInterval": [3242, 3245] }, "$"], ["terminal", { "sourceInterval": [3248, 3251] }, "&"], ["terminal", { "sourceInterval": [3254, 3257] }, "'"], ["terminal", { "sourceInterval": [3260, 3263] }, "("], ["terminal", { "sourceInterval": [3266, 3269] }, ")"], ["terminal", { "sourceInterval": [3272, 3275] }, "*"], ["terminal", { "sourceInterval": [3278, 3281] }, "+"], ["terminal", { "sourceInterval": [3284, 3287] }, ","], ["terminal", { "sourceInterval": [3290, 3293] }, ";"], ["terminal", { "sourceInterval": [3296, 3299] }, "="]]], "hexdig": ["define", { "sourceInterval": [3304, 3396] }, null, [], ["alt", { "sourceInterval": [3319, 3396] }, ["app", { "sourceInterval": [3319, 3324] }, "digit", []], ["terminal", { "sourceInterval": [3327, 3330] }, "a"], ["terminal", { "sourceInterval": [3333, 3336] }, "A"], ["terminal", { "sourceInterval": [3339, 3342] }, "b"], ["terminal", { "sourceInterval": [3345, 3348] }, "B"], ["terminal", { "sourceInterval": [3351, 3354] }, "c"], ["terminal", { "sourceInterval": [3357, 3360] }, "C"], ["terminal", { "sourceInterval": [3363, 3366] }, "d"], ["terminal", { "sourceInterval": [3369, 3372] }, "D"], ["terminal", { "sourceInterval": [3375, 3378] }, "e"], ["terminal", { "sourceInterval": [3381, 3384] }, "E"], ["terminal", { "sourceInterval": [3387, 3390] }, "f"], ["terminal", { "sourceInterval": [3393, 3396] }, "F"]]], "QuotedMarker": ["define", { "sourceInterval": [3429, 3455] }, null, [], ["seq", { "sourceInterval": [3445, 3455] }, ["terminal", { "sourceInterval": [3445, 3448] }, ";"], ["app", { "sourceInterval": [3449, 3455] }, "Marker", []]]], "Marker": ["define", { "sourceInterval": [3460, 3484] }, null, [], ["app", { "sourceInterval": [3476, 3484] }, "MarkerOr", []]], "MarkerOr_node": ["define", { "sourceInterval": [3505, 3537] }, null, [], ["seq", { "sourceInterval": [3505, 3529] }, ["app", { "sourceInterval": [3505, 3514] }, "MarkerAnd", []], ["terminal", { "sourceInterval": [3515, 3519] }, "or"], ["app", { "sourceInterval": [3520, 3529] }, "MarkerAnd", []]]], "MarkerOr_leaf": ["define", { "sourceInterval": [3558, 3575] }, null, [], ["app", { "sourceInterval": [3558, 3567] }, "MarkerAnd", []]], "MarkerOr": ["define", { "sourceInterval": [3489, 3575] }, null, [], ["alt", { "sourceInterval": [3505, 3575] }, ["app", { "sourceInterval": [3505, 3529] }, "MarkerOr_node", []], ["app", { "sourceInterval": [3558, 3567] }, "MarkerOr_leaf", []]]], "MarkerAnd_node": ["define", { "sourceInterval": [3596, 3631] }, null, [], ["seq", { "sourceInterval": [3596, 3623] }, ["app", { "sourceInterval": [3596, 3606] }, "MarkerExpr", []], ["terminal", { "sourceInterval": [3607, 3612] }, "and"], ["app", { "sourceInterval": [3613, 3623] }, "MarkerExpr", []]]], "MarkerAnd_leaf": ["define", { "sourceInterval": [3652, 3670] }, null, [], ["app", { "sourceInterval": [3652, 3662] }, "MarkerExpr", []]], "MarkerAnd": ["define", { "sourceInterval": [3580, 3670] }, null, [], ["alt", { "sourceInterval": [3596, 3670] }, ["app", { "sourceInterval": [3596, 3623] }, "MarkerAnd_node", []], ["app", { "sourceInterval": [3652, 3662] }, "MarkerAnd_leaf", []]]], "MarkerExpr_leaf": ["define", { "sourceInterval": [3691, 3727] }, null, [], ["seq", { "sourceInterval": [3691, 3719] }, ["app", { "sourceInterval": [3691, 3700] }, "MarkerVar", []], ["app", { "sourceInterval": [3701, 3709] }, "markerOp", []], ["app", { "sourceInterval": [3710, 3719] }, "MarkerVar", []]]], "MarkerExpr_node": ["define", { "sourceInterval": [3748, 3770] }, null, [], ["seq", { "sourceInterval": [3748, 3762] }, ["terminal", { "sourceInterval": [3748, 3751] }, "("], ["app", { "sourceInterval": [3752, 3758] }, "Marker", []], ["terminal", { "sourceInterval": [3759, 3762] }, ")"]]], "MarkerExpr": ["define", { "sourceInterval": [3675, 3770] }, null, [], ["alt", { "sourceInterval": [3691, 3770] }, ["app", { "sourceInterval": [3691, 3719] }, "MarkerExpr_leaf", []], ["app", { "sourceInterval": [3748, 3762] }, "MarkerExpr_node", []]]], "MarkerVar": ["define", { "sourceInterval": [3775, 3809] }, null, [], ["alt", { "sourceInterval": [3791, 3809] }, ["app", { "sourceInterval": [3791, 3797] }, "envVar", []], ["app", { "sourceInterval": [3800, 3809] }, "pythonStr", []]]], "markerOp_versionCmp": ["define", { "sourceInterval": [3830, 3854] }, null, [], ["app", { "sourceInterval": [3830, 3840] }, "versionCmp", []]], "markerOp_in": ["define", { "sourceInterval": [3875, 3885] }, null, [], ["terminal", { "sourceInterval": [3875, 3879] }, "in"]], "markerOp_notIn": ["define", { "sourceInterval": [3906, 3934] }, null, [], ["seq", { "sourceInterval": [3906, 3925] }, ["terminal", { "sourceInterval": [3907, 3912] }, "not"], ["plus", { "sourceInterval": [3913, 3919] }, ["app", { "sourceInterval": [3913, 3918] }, "space", []]], ["terminal", { "sourceInterval": [3920, 3924] }, "in"]]], "markerOp": ["define", { "sourceInterval": [3814, 3934] }, null, [], ["alt", { "sourceInterval": [3830, 3934] }, ["app", { "sourceInterval": [3830, 3840] }, "markerOp_versionCmp", []], ["app", { "sourceInterval": [3875, 3879] }, "markerOp_in", []], ["app", { "sourceInterval": [3906, 3925] }, "markerOp_notIn", []]]], "pythonStr": ["define", { "sourceInterval": [3939, 4039] }, null, [], ["alt", { "sourceInterval": [3955, 4039] }, ["seq", { "sourceInterval": [3955, 3986] }, ["terminal", { "sourceInterval": [3955, 3958] }, "'"], ["star", { "sourceInterval": [3959, 3982] }, ["alt", { "sourceInterval": [3960, 3980] }, ["app", { "sourceInterval": [3960, 3973] }, "pythonStrChar", []], ["terminal", { "sourceInterval": [3976, 3980] }, '"']]], ["terminal", { "sourceInterval": [3983, 3986] }, "'"]], ["seq", { "sourceInterval": [4007, 4039] }, ["terminal", { "sourceInterval": [4007, 4011] }, '"'], ["star", { "sourceInterval": [4012, 4034] }, ["alt", { "sourceInterval": [4013, 4032] }, ["app", { "sourceInterval": [4013, 4026] }, "pythonStrChar", []], ["terminal", { "sourceInterval": [4029, 4032] }, "'"]]], ["terminal", { "sourceInterval": [4035, 4039] }, '"']]]], "pythonStrChar": ["define", { "sourceInterval": [4044, 4265] }, null, [], ["alt", { "sourceInterval": [4060, 4265] }, ["app", { "sourceInterval": [4060, 4065] }, "space", []], ["app", { "sourceInterval": [4068, 4073] }, "alnum", []], ["terminal", { "sourceInterval": [4076, 4079] }, "("], ["terminal", { "sourceInterval": [4082, 4085] }, ")"], ["terminal", { "sourceInterval": [4088, 4091] }, "."], ["terminal", { "sourceInterval": [4094, 4097] }, "{"], ["terminal", { "sourceInterval": [4100, 4103] }, "}"], ["terminal", { "sourceInterval": [4106, 4109] }, "-"], ["terminal", { "sourceInterval": [4112, 4115] }, "_"], ["terminal", { "sourceInterval": [4118, 4121] }, "*"], ["terminal", { "sourceInterval": [4124, 4127] }, "#"], ["terminal", { "sourceInterval": [4130, 4133] }, ":"], ["terminal", { "sourceInterval": [4136, 4139] }, ";"], ["terminal", { "sourceInterval": [4142, 4145] }, ","], ["terminal", { "sourceInterval": [4148, 4151] }, "/"], ["terminal", { "sourceInterval": [4154, 4157] }, "?"], ["terminal", { "sourceInterval": [4178, 4181] }, "["], ["terminal", { "sourceInterval": [4184, 4187] }, "]"], ["terminal", { "sourceInterval": [4190, 4193] }, "!"], ["terminal", { "sourceInterval": [4196, 4199] }, "~"], ["terminal", { "sourceInterval": [4202, 4205] }, "`"], ["terminal", { "sourceInterval": [4208, 4211] }, "@"], ["terminal", { "sourceInterval": [4214, 4217] }, "$"], ["terminal", { "sourceInterval": [4220, 4223] }, "%"], ["terminal", { "sourceInterval": [4226, 4229] }, "^"], ["terminal", { "sourceInterval": [4232, 4235] }, "&"], ["terminal", { "sourceInterval": [4238, 4241] }, "="], ["terminal", { "sourceInterval": [4244, 4247] }, "+"], ["terminal", { "sourceInterval": [4250, 4253] }, "|"], ["terminal", { "sourceInterval": [4256, 4259] }, "<"], ["terminal", { "sourceInterval": [4262, 4265] }, ">"]]], "envVar": ["define", { "sourceInterval": [4270, 4570] }, null, [], ["alt", { "sourceInterval": [4286, 4570] }, ["terminal", { "sourceInterval": [4286, 4302] }, "python_version"], ["terminal", { "sourceInterval": [4305, 4326] }, "python_full_version"], ["terminal", { "sourceInterval": [4329, 4338] }, "os_name"], ["terminal", { "sourceInterval": [4341, 4355] }, "sys_platform"], ["terminal", { "sourceInterval": [4358, 4376] }, "platform_release"], ["terminal", { "sourceInterval": [4397, 4414] }, "platform_system"], ["terminal", { "sourceInterval": [4417, 4435] }, "platform_version"], ["terminal", { "sourceInterval": [4438, 4456] }, "platform_machine"], ["terminal", { "sourceInterval": [4459, 4491] }, "platform_python_implementation"], ["terminal", { "sourceInterval": [4512, 4533] }, "implementation_name"], ["terminal", { "sourceInterval": [4536, 4560] }, "implementation_version"], ["terminal", { "sourceInterval": [4563, 4570] }, "extra"]]], "VersionSpec_parenthesized": ["define", { "sourceInterval": [4717, 4753] }, null, [], ["seq", { "sourceInterval": [4717, 4736] }, ["terminal", { "sourceInterval": [4717, 4720] }, "("], ["app", { "sourceInterval": [4721, 4732] }, "VersionMany", []], ["terminal", { "sourceInterval": [4733, 4736] }, ")"]]], "VersionSpec_direct": ["define", { "sourceInterval": [4774, 4795] }, null, [], ["app", { "sourceInterval": [4774, 4785] }, "VersionMany", []]], "VersionSpec": ["define", { "sourceInterval": [4701, 4795] }, null, [], ["alt", { "sourceInterval": [4717, 4795] }, ["app", { "sourceInterval": [4717, 4736] }, "VersionSpec_parenthesized", []], ["app", { "sourceInterval": [4774, 4785] }, "VersionSpec_direct", []]]], "VersionMany": ["define", { "sourceInterval": [4800, 4839] }, null, [], ["app", { "sourceInterval": [4816, 4839] }, "ListOf", [["app", { "sourceInterval": [4823, 4833] }, "VersionOne", []], ["terminal", { "sourceInterval": [4835, 4838] }, ","]]]], "VersionOne": ["define", { "sourceInterval": [4844, 4878] }, null, [], ["seq", { "sourceInterval": [4860, 4878] }, ["app", { "sourceInterval": [4860, 4870] }, "versionCmp", []], ["app", { "sourceInterval": [4871, 4878] }, "version", []]]], "versionCmp": ["define", { "sourceInterval": [4883, 4951] }, null, [], ["alt", { "sourceInterval": [4899, 4951] }, ["terminal", { "sourceInterval": [4899, 4903] }, "<="], ["terminal", { "sourceInterval": [4906, 4909] }, "<"], ["terminal", { "sourceInterval": [4912, 4916] }, "!="], ["terminal", { "sourceInterval": [4919, 4923] }, "=="], ["terminal", { "sourceInterval": [4926, 4930] }, ">="], ["terminal", { "sourceInterval": [4933, 4936] }, ">"], ["terminal", { "sourceInterval": [4939, 4943] }, "~="], ["terminal", { "sourceInterval": [4946, 4951] }, "==="]]], "version": ["define", { "sourceInterval": [4956, 5017] }, null, [], ["plus", { "sourceInterval": [4972, 5017] }, ["alt", { "sourceInterval": [4973, 5014] }, ["app", { "sourceInterval": [4973, 4978] }, "alnum", []], ["terminal", { "sourceInterval": [4981, 4984] }, "-"], ["terminal", { "sourceInterval": [4987, 4990] }, "_"], ["terminal", { "sourceInterval": [4993, 4996] }, "."], ["terminal", { "sourceInterval": [4999, 5002] }, "*"], ["terminal", { "sourceInterval": [5005, 5008] }, "+"], ["terminal", { "sourceInterval": [5011, 5014] }, "!"]]]], "comment": ["define", { "sourceInterval": [5023, 5049] }, null, [], ["seq", { "sourceInterval": [5033, 5049] }, ["terminal", { "sourceInterval": [5033, 5036] }, "#"], ["star", { "sourceInterval": [5037, 5049] }, ["seq", { "sourceInterval": [5038, 5047] }, ["not", { "sourceInterval": [5038, 5043] }, ["terminal", { "sourceInterval": [5039, 5043] }, "\n"]], ["app", { "sourceInterval": [5044, 5047] }, "any", []]]]]], "space": ["override", { "sourceInterval": [5055, 5074] }, null, [], ["alt", { "sourceInterval": [5064, 5074] }, ["terminal", { "sourceInterval": [5064, 5067] }, " "], ["terminal", { "sourceInterval": [5070, 5074] }, "	"]]], "LooseFile": ["define", { "sourceInterval": [5291, 5334] }, null, [], ["app", { "sourceInterval": [5311, 5334] }, "ListOf", [["app", { "sourceInterval": [5318, 5327] }, "LooseLine", []], ["terminal", { "sourceInterval": [5329, 5333] }, "\n"]]]], "LooseLine": ["define", { "sourceInterval": [5339, 5376] }, null, [], ["seq", { "sourceInterval": [5359, 5376] }, ["app", { "sourceInterval": [5359, 5367] }, "LooseReq", []], ["opt", { "sourceInterval": [5368, 5376] }, ["app", { "sourceInterval": [5368, 5375] }, "comment", []]]]], "LooseReq": ["define", { "sourceInterval": [5381, 5431] }, null, [], ["alt", { "sourceInterval": [5401, 5431] }, ["app", { "sourceInterval": [5401, 5416] }, "LooseNonNameReq", []], ["app", { "sourceInterval": [5419, 5431] }, "LooseNameReq", []]]], "LooseNameReq": ["define", { "sourceInterval": [5436, 5509] }, null, [], ["seq", { "sourceInterval": [5456, 5509] }, ["app", { "sourceInterval": [5456, 5460] }, "Name", []], ["opt", { "sourceInterval": [5461, 5473] }, ["app", { "sourceInterval": [5461, 5472] }, "LooseExtras", []]], ["app", { "sourceInterval": [5474, 5490] }, "LooseVersionSpec", []], ["opt", { "sourceInterval": [5491, 5509] }, ["app", { "sourceInterval": [5491, 5508] }, "LooseQuotedMarker", []]]]], "LooseNonNameReq": ["define", { "sourceInterval": [5514, 5569] }, null, [], ["seq", { "sourceInterval": [5534, 5569] }, ["not", { "sourceInterval": [5535, 5554] }, ["seq", { "sourceInterval": [5537, 5553] }, ["not", { "sourceInterval": [5537, 5548] }, ["seq", { "sourceInterval": [5539, 5547] }, ["app", { "sourceInterval": [5539, 5543] }, "Name", []], ["terminal", { "sourceInterval": [5544, 5547] }, "@"]]], ["app", { "sourceInterval": [5549, 5553] }, "Name", []]]], ["app", { "sourceInterval": [5555, 5568] }, "looseAnything", []]]], "LooseExtras": ["define", { "sourceInterval": [5634, 5691] }, null, [], ["seq", { "sourceInterval": [5654, 5691] }, ["terminal", { "sourceInterval": [5654, 5657] }, "["], ["app", { "sourceInterval": [5658, 5681] }, "ListOf", [["app", { "sourceInterval": [5665, 5675] }, "identifier", []], ["terminal", { "sourceInterval": [5677, 5680] }, ","]]], ["star", { "sourceInterval": [5682, 5686] }, ["terminal", { "sourceInterval": [5682, 5685] }, ","]], ["opt", { "sourceInterval": [5687, 5691] }, ["terminal", { "sourceInterval": [5687, 5690] }, "]"]]]], "LooseQuotedMarker": ["define", { "sourceInterval": [5696, 5733] }, null, [], ["seq", { "sourceInterval": [5716, 5733] }, ["terminal", { "sourceInterval": [5716, 5719] }, ";"], ["app", { "sourceInterval": [5720, 5733] }, "looseAnything", []]]], "LooseVersionSpec_parenthesized": ["define", { "sourceInterval": [5758, 5800] }, null, [], ["seq", { "sourceInterval": [5758, 5783] }, ["terminal", { "sourceInterval": [5758, 5761] }, "("], ["app", { "sourceInterval": [5762, 5778] }, "LooseVersionMany", []], ["opt", { "sourceInterval": [5779, 5783] }, ["terminal", { "sourceInterval": [5779, 5782] }, ")"]]]], "LooseVersionSpec_direct": ["define", { "sourceInterval": [5825, 5851] }, null, [], ["app", { "sourceInterval": [5825, 5841] }, "LooseVersionMany", []]], "LooseVersionSpec": ["define", { "sourceInterval": [5738, 5851] }, null, [], ["alt", { "sourceInterval": [5758, 5851] }, ["app", { "sourceInterval": [5758, 5783] }, "LooseVersionSpec_parenthesized", []], ["app", { "sourceInterval": [5825, 5841] }, "LooseVersionSpec_direct", []]]], "LooseVersionMany": ["define", { "sourceInterval": [5856, 5909] }, null, [], ["seq", { "sourceInterval": [5876, 5909] }, ["app", { "sourceInterval": [5876, 5904] }, "ListOf", [["app", { "sourceInterval": [5883, 5898] }, "LooseVersionOne", []], ["terminal", { "sourceInterval": [5900, 5903] }, ","]]], ["star", { "sourceInterval": [5905, 5909] }, ["terminal", { "sourceInterval": [5905, 5908] }, ","]]]], "LooseVersionOne": ["define", { "sourceInterval": [5914, 5963] }, null, [], ["seq", { "sourceInterval": [5934, 5963] }, ["app", { "sourceInterval": [5934, 5949] }, "looseVersionCmp", []], ["opt", { "sourceInterval": [5950, 5963] }, ["app", { "sourceInterval": [5950, 5962] }, "looseVersion", []]]]], "looseVersionCmp": ["define", { "sourceInterval": [5968, 6018] }, null, [], ["plus", { "sourceInterval": [5988, 6018] }, ["alt", { "sourceInterval": [5989, 6016] }, ["terminal", { "sourceInterval": [5989, 5992] }, "<"], ["terminal", { "sourceInterval": [5995, 5998] }, "="], ["terminal", { "sourceInterval": [6001, 6004] }, "!"], ["terminal", { "sourceInterval": [6007, 6010] }, ">"], ["terminal", { "sourceInterval": [6013, 6016] }, "~"]]]], "looseVersion": ["define", { "sourceInterval": [6023, 6088] }, null, [], ["plus", { "sourceInterval": [6043, 6088] }, ["alt", { "sourceInterval": [6044, 6085] }, ["app", { "sourceInterval": [6044, 6049] }, "alnum", []], ["terminal", { "sourceInterval": [6052, 6055] }, "-"], ["terminal", { "sourceInterval": [6058, 6061] }, "_"], ["terminal", { "sourceInterval": [6064, 6067] }, "."], ["terminal", { "sourceInterval": [6070, 6073] }, "*"], ["terminal", { "sourceInterval": [6076, 6079] }, "+"], ["terminal", { "sourceInterval": [6082, 6085] }, "!"]]]], "looseAnything": ["define", { "sourceInterval": [6093, 6133] }, null, [], ["star", { "sourceInterval": [6113, 6133] }, ["seq", { "sourceInterval": [6114, 6131] }, ["not", { "sourceInterval": [6114, 6127] }, ["alt", { "sourceInterval": [6116, 6126] }, ["terminal", { "sourceInterval": [6116, 6120] }, "\n"], ["terminal", { "sourceInterval": [6123, 6126] }, "#"]]], ["app", { "sourceInterval": [6128, 6131] }, "any", []]]]] }]);
    module2.exports = result;
  }
});

// ../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/semantics.js
var require_semantics = __commonJS({
  "../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/semantics.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequirementsSyntaxError = exports.semantics = void 0;
    var pep_508_ohm_bundle_1 = __importDefault(require_pep_508_ohm_bundle());
    exports.semantics = pep_508_ohm_bundle_1.default.createSemantics();
    function getLocation(node) {
      return {
        startIdx: node.source.startIdx,
        endIdx: node.source.endIdx
      };
    }
    function withLocation(node, data) {
      return {
        data,
        location: getLocation(node)
      };
    }
    exports.semantics.addOperation("extract", {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      File: (linesList) => linesList.asIteration().children.map((line) => line.extract()).filter(Boolean),
      Line: (req, _comment) => {
        var _a;
        return ((_a = req.child(0)) === null || _a === void 0 ? void 0 : _a.extract()) || null;
      },
      NameReq: (name, extras, versionSpec, markers) => {
        var _a, _b;
        return {
          type: "ProjectName",
          name: name.sourceString,
          versionSpec: versionSpec.extract(),
          extras: (_a = extras.child(0)) === null || _a === void 0 ? void 0 : _a.extract(),
          environmentMarkerTree: (_b = markers.child(0)) === null || _b === void 0 ? void 0 : _b.extract()
        };
      },
      UrlReq: (name, extras, url, _space, markers) => {
        var _a, _b;
        return {
          type: "ProjectURL",
          name: name.sourceString,
          url: url.extract(),
          extras: (_a = extras.child(0)) === null || _a === void 0 ? void 0 : _a.extract(),
          environmentMarkerTree: (_b = markers.child(0)) === null || _b === void 0 ? void 0 : _b.extract()
        };
      },
      Extras: (_open, extrasList, _close) => extrasList.asIteration().children.map((extra) => extra.sourceString),
      RequirementsReq: (_dashR, filePath) => ({
        type: "RequirementsFile",
        path: filePath.sourceString
      }),
      ConstraintsReq: (_dashC, filePath) => ({
        type: "ConstraintsFile",
        path: filePath.sourceString
      }),
      UrlSpec: (_at, uriReference) => uriReference.sourceString,
      QuotedMarker: (_semi, marker) => marker.extract(),
      MarkerOr_node: (left, _or, right) => ({
        operator: "or",
        left: left.extract(),
        right: right.extract()
      }),
      MarkerAnd_node: (left, _and, right) => ({
        operator: "and",
        left: left.extract(),
        right: right.extract()
      }),
      MarkerExpr_leaf: (left, operator, right) => ({
        left: left.sourceString,
        operator: operator.sourceString,
        right: right.sourceString
      }),
      MarkerExpr_node: (_open, marker, _close) => marker.extract(),
      VersionSpec_parenthesized: (_open, versionMany, _close) => versionMany.extract() || [],
      VersionMany: (versionOnesList) => {
        const versionOnes = versionOnesList.asIteration().children;
        if (versionOnes.length === 0) {
          return void 0;
        }
        return versionOnes.map((versionOne) => versionOne.extract());
      },
      VersionOne: (operator, version2) => ({
        operator: operator.sourceString,
        version: version2.sourceString
      })
      /* eslint-enable @typescript-eslint/no-unused-vars */
    });
    exports.semantics.addOperation("extractLoosely", {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      LooseFile: (linesList) => linesList.asIteration().children.map((line) => line.extractLoosely()).filter(Boolean),
      LooseLine: (req, _comment) => {
        var _a;
        return ((_a = req.child(0)) === null || _a === void 0 ? void 0 : _a.extractLoosely()) || null;
      },
      LooseNameReq: (name, extras, versionSpec, _markers) => {
        var _a;
        return {
          type: "ProjectName",
          name: name.sourceString,
          extras: (_a = extras.child(0)) === null || _a === void 0 ? void 0 : _a.extractLoosely(),
          versionSpec: versionSpec.extractLoosely()
        };
      },
      LooseNonNameReq: (_) => null,
      LooseExtras: (_open, extrasList, _trailingComma, _close) => extrasList.asIteration().children.map((extra) => extra.sourceString),
      LooseVersionSpec_parenthesized: (_open, versionMany, _close) => versionMany.extractLoosely() || [],
      LooseVersionMany: (versionOnesList, _trailingComma) => {
        const versionOnes = versionOnesList.asIteration().children;
        if (versionOnes.length === 0) {
          return void 0;
        }
        return versionOnes.map((versionOne) => versionOne.extractLoosely());
      },
      LooseVersionOne: (operator, version2) => {
        const result = {
          operator: operator.sourceString
        };
        if (version2.sourceString) {
          result.version = version2.sourceString;
        }
        return result;
      }
      /* eslint-enable @typescript-eslint/no-unused-vars */
    });
    exports.semantics.addOperation("extractWithLocation", {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      File: (linesList) => linesList.asIteration().children.map((line) => line.extractWithLocation()).filter(Boolean),
      Line: (req, _comment) => {
        var _a;
        return ((_a = req.child(0)) === null || _a === void 0 ? void 0 : _a.extractWithLocation()) || null;
      },
      NameReq: function(name, extras, versionSpec, markers) {
        var _a, _b;
        return withLocation(this, {
          type: "ProjectName",
          name: withLocation(name, name.sourceString),
          versionSpec: versionSpec.extractWithLocation(),
          extras: (_a = extras.child(0)) === null || _a === void 0 ? void 0 : _a.extractWithLocation(),
          environmentMarkerTree: (_b = markers.child(0)) === null || _b === void 0 ? void 0 : _b.extractWithLocation()
        });
      },
      UrlReq: function(name, extras, url, _space, markers) {
        var _a, _b;
        return withLocation(this, {
          type: "ProjectURL",
          name: withLocation(name, name.sourceString),
          url: url.extractWithLocation(),
          extras: (_a = extras.child(0)) === null || _a === void 0 ? void 0 : _a.extractWithLocation(),
          environmentMarkerTree: (_b = markers.child(0)) === null || _b === void 0 ? void 0 : _b.extractWithLocation()
        });
      },
      Extras: function(_open, extrasList, _close) {
        return extrasList.asIteration().children.map((extra) => withLocation(extra, extra.sourceString));
      },
      RequirementsReq: function(_dashR, filePath) {
        return withLocation(this, {
          type: "RequirementsFile",
          path: filePath.sourceString
        });
      },
      ConstraintsReq: function(_dashC, filePath) {
        return withLocation(this, {
          type: "ConstraintsFile",
          path: filePath.sourceString
        });
      },
      UrlSpec: function(_at, uriReference) {
        return withLocation(uriReference, uriReference.sourceString);
      },
      QuotedMarker: (_semi, marker) => withLocation(marker, marker.extract()),
      VersionSpec_parenthesized: (_open, versionMany, _close) => versionMany.extractWithLocation() || [],
      VersionMany: (versionOnesList) => {
        const versionOnes = versionOnesList.asIteration().children;
        if (versionOnes.length === 0) {
          return void 0;
        }
        return versionOnes.map((versionOne) => versionOne.extractWithLocation());
      },
      VersionOne: function(operator, version2) {
        return withLocation(this, {
          operator: withLocation(operator, operator.sourceString),
          version: withLocation(version2, version2.sourceString)
        });
      }
      /* eslint-enable @typescript-eslint/no-unused-vars */
    });
    exports.semantics.addOperation("extractLooselyWithLocation", {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      LooseFile: (linesList) => linesList.asIteration().children.map((line) => line.extractLooselyWithLocation()).filter(Boolean),
      LooseLine: (req, _comment) => {
        var _a;
        return ((_a = req.child(0)) === null || _a === void 0 ? void 0 : _a.extractLooselyWithLocation()) || null;
      },
      LooseNameReq: function(name, extras, versionSpec, _markers) {
        var _a;
        return withLocation(this, {
          type: "ProjectName",
          name: withLocation(name, name.sourceString),
          extras: (_a = extras.child(0)) === null || _a === void 0 ? void 0 : _a.extractLooselyWithLocation(),
          versionSpec: versionSpec.extractLooselyWithLocation()
        });
      },
      LooseNonNameReq: (_) => null,
      LooseExtras: function(_open, extrasList, _trailingComma, _close) {
        return extrasList.asIteration().children.map((extra) => withLocation(extra, extra.sourceString));
      },
      LooseVersionSpec_parenthesized: (_open, versionMany, _close) => versionMany.extractLooselyWithLocation() || [],
      LooseVersionMany: (versionOnesList, _trailingComma) => {
        const versionOnes = versionOnesList.asIteration().children;
        if (versionOnes.length === 0) {
          return void 0;
        }
        return versionOnes.map((versionOne) => versionOne.extractLooselyWithLocation());
      },
      LooseVersionOne: function(operator, version2) {
        return withLocation(this, {
          operator: withLocation(operator, operator.sourceString),
          ...version2.sourceString ? { version: withLocation(version2, version2.sourceString) } : {}
        });
      }
      /* eslint-enable @typescript-eslint/no-unused-vars */
    });
    var RequirementsSyntaxError = class extends Error {
    };
    exports.RequirementsSyntaxError = RequirementsSyntaxError;
  }
});

// ../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VersionOperator = exports.EnvironmentMarkerVariable = void 0;
    var EnvironmentMarkerVariable;
    (function(EnvironmentMarkerVariable2) {
      EnvironmentMarkerVariable2["PythonVersion"] = "python_version";
      EnvironmentMarkerVariable2["PythonFullVersion"] = "python_full_version";
      EnvironmentMarkerVariable2["OsName"] = "os_name";
      EnvironmentMarkerVariable2["SysPlatform"] = "sys_platform";
      EnvironmentMarkerVariable2["PlatformRelease"] = "platform_release";
      EnvironmentMarkerVariable2["PlatformSystem"] = "platform_system";
      EnvironmentMarkerVariable2["PlatformVersion"] = "platform_version";
      EnvironmentMarkerVariable2["PlatformMachine"] = "platform_machine";
      EnvironmentMarkerVariable2["PlatformPythonImplementation"] = "platform_python_implementation";
      EnvironmentMarkerVariable2["ImplementationName"] = "implementation_name";
      EnvironmentMarkerVariable2["ImplementationVersion"] = "implementation_version";
      EnvironmentMarkerVariable2["Extra"] = "extra";
    })(EnvironmentMarkerVariable || (exports.EnvironmentMarkerVariable = EnvironmentMarkerVariable = {}));
    var VersionOperator;
    (function(VersionOperator2) {
      VersionOperator2["CompatibleRelease"] = "~=";
      VersionOperator2["VersionMatching"] = "==";
      VersionOperator2["VersionExclusion"] = "!=";
      VersionOperator2["LessThanOrMatching"] = "<=";
      VersionOperator2["GreaterThanOrMatching"] = ">=";
      VersionOperator2["LessThan"] = "<";
      VersionOperator2["GreaterThan"] = ">";
      VersionOperator2["ArbitrarilyEqual"] = "===";
    })(VersionOperator || (exports.VersionOperator = VersionOperator = {}));
  }
});

// ../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/pip-requirements-js@1.0.2/node_modules/pip-requirements-js/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsePipRequirementsLineLoosely = exports.parsePipRequirementsFileLoosely = exports.parsePipRequirementsLine = exports.parsePipRequirementsFile = exports.RequirementsSyntaxError = void 0;
    var pep_508_ohm_bundle_1 = __importDefault(require_pep_508_ohm_bundle());
    var semantics_1 = require_semantics();
    var semantics_2 = require_semantics();
    Object.defineProperty(exports, "RequirementsSyntaxError", { enumerable: true, get: function() {
      return semantics_2.RequirementsSyntaxError;
    } });
    __exportStar(require_types(), exports);
    function parsePipRequirementsFile2(fileContent, options) {
      const matchResult = pep_508_ohm_bundle_1.default.match(fileContent, "File");
      if (matchResult.failed()) {
        throw new semantics_1.RequirementsSyntaxError(`Failed to parse requirements file. ${matchResult.shortMessage}`);
      }
      if (options === null || options === void 0 ? void 0 : options.includeLocations) {
        return (0, semantics_1.semantics)(matchResult).extractWithLocation();
      }
      return (0, semantics_1.semantics)(matchResult).extract();
    }
    exports.parsePipRequirementsFile = parsePipRequirementsFile2;
    function parsePipRequirementsLine(lineContent, options) {
      const matchResult = pep_508_ohm_bundle_1.default.match(lineContent, "Line");
      if (matchResult.failed()) {
        throw new semantics_1.RequirementsSyntaxError(`Failed to parse requirements line. ${matchResult.shortMessage}`);
      }
      if (options === null || options === void 0 ? void 0 : options.includeLocations) {
        return (0, semantics_1.semantics)(matchResult).extractWithLocation();
      }
      return (0, semantics_1.semantics)(matchResult).extract();
    }
    exports.parsePipRequirementsLine = parsePipRequirementsLine;
    function parsePipRequirementsFileLoosely(fileContent, options) {
      const matchResult = pep_508_ohm_bundle_1.default.match(fileContent, "LooseFile");
      if (matchResult.failed()) {
        throw new semantics_1.RequirementsSyntaxError(`Failed to loosely parse requirements file. ${matchResult.shortMessage}`);
      }
      if (options === null || options === void 0 ? void 0 : options.includeLocations) {
        return (0, semantics_1.semantics)(matchResult).extractLooselyWithLocation();
      }
      return (0, semantics_1.semantics)(matchResult).extractLoosely();
    }
    exports.parsePipRequirementsFileLoosely = parsePipRequirementsFileLoosely;
    function parsePipRequirementsLineLoosely(lineContent, options) {
      const matchResult = pep_508_ohm_bundle_1.default.match(lineContent, "LooseLine");
      if (matchResult.failed()) {
        throw new semantics_1.RequirementsSyntaxError(`Failed to loosely parse requirements line. ${matchResult.shortMessage}`);
      }
      if (options === null || options === void 0 ? void 0 : options.includeLocations) {
        return (0, semantics_1.semantics)(matchResult).extractLooselyWithLocation();
      }
      return (0, semantics_1.semantics)(matchResult).extractLoosely();
    }
    exports.parsePipRequirementsLineLoosely = parsePipRequirementsLineLoosely;
  }
});

// ../../node_modules/.pnpm/which@3.0.0/node_modules/which/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/which@3.0.0/node_modules/which/lib/index.js"(exports, module2) {
    var isexe = require_isexe();
    var { join: join7, delimiter: delimiter2, sep: sep2, posix } = require("path");
    var isWindows = process.platform === "win32";
    var rSlash = new RegExp(`[${posix.sep}${sep2 === posix.sep ? "" : sep2}]`.replace(/(\\)/g, "\\$1"));
    var rRel = new RegExp(`^\\.${rSlash.source}`);
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter2
    }) => {
      const pathEnv = cmd.match(rSlash) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)
      ];
      if (isWindows) {
        const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter);
        if (cmd.includes(".") && pathExt[0] !== "") {
          pathExt.unshift("");
        }
        return { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    };
    var getPathPart = (raw, cmd) => {
      const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix + join7(pathPart, cmd);
    };
    var which2 = async (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const envPart of pathEnv) {
        const p = getPathPart(envPart, cmd);
        for (const ext2 of pathExt) {
          const withExt = p + ext2;
          const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    var whichSync = (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const pathEnvPart of pathEnv) {
        const p = getPathPart(pathEnvPart, cmd);
        for (const ext2 of pathExt) {
          const withExt = p + ext2;
          const is = isexe.sync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  build: () => build,
  defaultShouldServe: () => defaultShouldServe,
  downloadFilesInWorkPath: () => downloadFilesInWorkPath,
  installRequirement: () => installRequirement,
  installRequirementsFile: () => installRequirementsFile,
  shouldServe: () => shouldServe,
  startDevServer: () => startDevServer,
  version: () => version
});
module.exports = __toCommonJS(src_exports);
var import_fs5 = __toESM(require("fs"));
var import_util6 = require("util");
var import_path11 = require("path");

// src/runtime-version.ts
var VERCEL_RUNTIME_VERSION = "0.4.1";

// src/index.ts
var import_build_utils8 = require("@vercel/build-utils");

// src/install.ts
var import_execa3 = __toESM(require_execa());
var import_fs3 = __toESM(require("fs"));
var import_path8 = require("path");
var import_build_utils4 = require("@vercel/build-utils");

// ../python-analysis/dist/index.js
var import_path = __toESM(require("path"), 1);

// ../../node_modules/.pnpm/@isaacs+balanced-match@4.0.1/node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a, b, str2) => {
  const ma = a instanceof RegExp ? maybeMatch(a, str2) : a;
  const mb = b instanceof RegExp ? maybeMatch(b, str2) : b;
  const r = ma !== null && mb != null && range(ma, mb, str2);
  return r && {
    start: r[0],
    end: r[1],
    pre: str2.slice(0, r[0]),
    body: str2.slice(r[0] + ma.length, r[1]),
    post: str2.slice(r[1] + mb.length)
  };
};
var maybeMatch = (reg, str2) => {
  const m = str2.match(reg);
  return m ? m[0] : null;
};
var range = (a, b, str2) => {
  let begs, beg, left, right = void 0, result;
  let ai = str2.indexOf(a);
  let bi = str2.indexOf(b, ai + 1);
  let i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str2.length;
    while (i >= 0 && !result) {
      if (i === ai) {
        begs.push(i);
        ai = str2.indexOf(a, i + 1);
      } else if (begs.length === 1) {
        const r = begs.pop();
        if (r !== void 0)
          result = [r, bi];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str2.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// ../../node_modules/.pnpm/@isaacs+brace-expansion@5.0.0/node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str2) {
  return !isNaN(str2) ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str2) {
  return str2.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str2) {
  if (!str2) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str2);
  if (!m) {
    return str2.split(",");
  }
  const { pre, body, post } = m;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str2) {
  if (!str2) {
    return [];
  }
  if (str2.slice(0, 2) === "{}") {
    str2 = "\\{\\}" + str2.slice(2);
  }
  return expand_(escapeBraces(str2), true).map(unescapeBraces);
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand_(str2, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str2);
  if (!m)
    return [str2];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0; k < post.length; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str2 = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str2);
      }
      return [str2];
    }
    let n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1 && n[0] !== void 0) {
        n = expand_(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map((p) => m.pre + n[0] + p);
        }
      }
    }
    let N;
    if (isSequence && n[0] !== void 0 && n[1] !== void 0) {
      const x = numeric(n[0]);
      const y = numeric(n[1]);
      const width = Math.max(n[0].length, n[1].length);
      let incr = n.length === 3 && n[2] !== void 0 ? Math.abs(numeric(n[2])) : 1;
      let test = lte;
      const reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      const pad = n.some(isPadded);
      N = [];
      for (let i = x; test(i, y); i += incr) {
        let c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\") {
            c = "";
          }
        } else {
          c = String(i);
          if (pad) {
            const need = width - c.length;
            if (need > 0) {
              const z2 = new Array(need + 1).join("0");
              if (i < 0) {
                c = "-" + z2 + c.slice(1);
              } else {
                c = z2 + c;
              }
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];
      for (let j = 0; j < n.length; j++) {
        N.push.apply(N, expand_(n[j], false));
      }
    }
    for (let j = 0; j < N.length; j++) {
      for (let k = 0; k < post.length; k++) {
        const expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// ../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob4, position) => {
  const pos = position;
  if (glob4.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i < glob4.length) {
      const c = glob4.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = true;
        i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob4.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob4.length - pos, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
        } else if (c === rangeStart) {
          ranges.push(braceEscape(c));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob4.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-"));
        i += 2;
        continue;
      }
      if (glob4.startsWith("-", i + 1)) {
        rangeStart = c;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob4.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\{}])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
};

// ../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
var _AST = class _AST {
  constructor(type2, parent, options = {}) {
    __privateAdd(this, _fillNegs);
    __privateAdd(this, _partsToRegExp);
    __publicField(this, "type");
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _hasMagic, void 0);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _parentIndex, void 0);
    __privateAdd(this, _negs, void 0);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _toString, void 0);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type2;
    if (type2)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type2 === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p of __privateGet(this, _parts)) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
        throw new Error("invalid part: " + p);
      }
      __privateGet(this, _parts).push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (__privateGet(this, _root) === this)
      return true;
    if (!__privateGet(this, _parent)?.isStart())
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p = __privateGet(this, _parent);
    for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
      const pp = __privateGet(p, _parts)[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (__privateGet(this, _root) === this)
      return true;
    if (__privateGet(this, _parent)?.type === "!")
      return true;
    if (!__privateGet(this, _parent)?.isEnd())
      return false;
    if (!this.type)
      return __privateGet(this, _parent)?.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of __privateGet(this, _parts)) {
      c.copyIn(p);
    }
    return c;
  }
  static fromGlob(pattern, options = {}) {
    var _a;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob4 = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob4.toUpperCase() !== glob4.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob4
    });
  }
  get options() {
    return __privateGet(this, _options);
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd() && !__privateGet(this, _parts).some((s) => typeof s !== "string");
      const src = __privateGet(this, _parts).map((p) => {
        var _a;
        const [re, _, hasMagic, uflag] = typeof p === "string" ? __privateMethod(_a = _AST, _parseGlob, parseGlob_fn).call(_a, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      __privateSet(this, _parts, [s]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_fillNegs = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n;
  while (n = __privateGet(this, _negs).pop()) {
    if (n.type !== "!")
      continue;
    let p = n;
    let pp = __privateGet(p, _parent);
    while (pp) {
      for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
        for (const part of __privateGet(n, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp, _parts)[i]);
        }
      }
      p = pp;
      pp = __privateGet(p, _parent);
    }
  }
  return this;
};
_parseAST = new WeakSet();
parseAST_fn = function(str2, ast, pos, opt) {
  var _a, _b;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i2 = pos;
    let acc2 = "";
    while (i2 < str2.length) {
      const c = str2.charAt(i2++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc2 += c;
        continue;
      }
      if (inBrace) {
        if (i2 === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i2;
        braceNeg = false;
        acc2 += c;
        continue;
      }
      if (!opt.noext && isExtglobType(c) && str2.charAt(i2) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c, ast);
        i2 = __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, str2, ext2, i2, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c;
    }
    ast.push(acc2);
    return i2;
  }
  let i = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i < str2.length) {
    const c = str2.charAt(i++);
    if (escaping || c === "\\") {
      escaping = !escaping;
      acc += c;
      continue;
    }
    if (inBrace) {
      if (i === braceStart + 1) {
        if (c === "^" || c === "!") {
          braceNeg = true;
        }
      } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c;
      continue;
    } else if (c === "[") {
      inBrace = true;
      braceStart = i;
      braceNeg = false;
      acc += c;
      continue;
    }
    if (isExtglobType(c) && str2.charAt(i) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c, part);
      part.push(ext2);
      i = __privateMethod(_b = _AST, _parseAST, parseAST_fn).call(_b, str2, ext2, i, opt);
      continue;
    }
    if (c === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i;
    }
    acc += c;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str2.substring(pos - 1)]);
  return i;
};
_partsToRegExp = new WeakSet();
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p) => {
    if (typeof p === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
};
_parseGlob = new WeakSet();
parseGlob_fn = function(glob4, hasMagic, noEmpty = false) {
  let escaping = false;
  let re = "";
  let uflag = false;
  for (let i = 0; i < glob4.length; i++) {
    const c = glob4.charAt(i);
    if (escaping) {
      escaping = false;
      re += (reSpecials.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      if (i === glob4.length - 1) {
        re += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob4, i);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c === "*") {
      re += noEmpty && glob4 === "*" ? starNoEmpty : star;
      hasMagic = true;
      continue;
    }
    if (c === "?") {
      re += qmark;
      hasMagic = true;
      continue;
    }
    re += regExpEscape(c);
  }
  return [re, unescape(glob4), !!hasMagic, uflag];
};
__privateAdd(_AST, _parseAST);
__privateAdd(_AST, _parseGlob);
var AST = _AST;

// ../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]{}]/g, "[$&]") : s.replace(/[?*()[\]\\{}]/g, "\\$&");
  }
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type2, parent, options = {}) {
        super(type2, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set2 = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set2);
    this.set = set2.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set2, part) => {
        const prev = set2[set2.length - 1];
        if (part === "**" && prev === "**") {
          return set2;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set2.pop();
            return set2;
          }
        }
        set2.push(part);
        return set2;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which2 = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which2 === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which2 === "b")
          return false;
        which2 = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which2 === "a")
          return false;
        which2 = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set2.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      const filtered = pp.filter((p) => p !== GLOBSTAR);
      if (this.partial && filtered.length >= 1) {
        const prefixes = [];
        for (let i = 1; i <= filtered.length; i++) {
          prefixes.push(filtered.slice(0, i).join("/"));
        }
        return "(?:" + prefixes.join("|") + ")";
      }
      return filtered.join("/");
    }).join("|");
    const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.partial) {
      re = "^(?:\\/|" + open + re.slice(1, -1) + close + ")$";
    }
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set2.length; i++) {
      const pattern = set2[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../python-analysis/dist/index.js
var import_path2 = __toESM(require("path"), 1);

// ../../node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match2;
  var foundLineNo = -1;
  while (match2 = re.exec(mark.buffer)) {
    lineEnds.push(match2.index);
    lineStarts.push(match2.index + match2[0].length);
    if (mark.position <= match2.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match2 = YAML_DATE_REGEXP.exec(data);
  if (match2 === null)
    match2 = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match2 === null)
    throw new Error("Date resolve error");
  year = +match2[1];
  month = +match2[2] - 1;
  day = +match2[3];
  if (!match2[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match2[4];
  minute = +match2[5];
  second = +match2[6];
  if (match2[7]) {
    fraction = match2[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match2[9]) {
    tz_hour = +match2[10];
    tz_minute = +(match2[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match2[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function setProperty(object, key, value) {
  if (key === "__proto__") {
    Object.defineProperty(object, key, {
      configurable: true,
      enumerable: true,
      writable: true,
      value
    });
  } else {
    object[key] = value;
  }
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match2, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match2 === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match2[1], 10);
    minor = parseInt(match2[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      setProperty(destination, key, source[key]);
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    setProperty(_result, keyNode, valueNode);
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString2 = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match2;
  while (match2 = lineRe.exec(string)) {
    var prefix = match2[1], line = match2[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match2;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match2 = breakRe.exec(line)) {
    next = match2.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString2.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString2.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types2 = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types: types2,
  safeLoad,
  safeLoadAll,
  safeDump
};

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/error.js
function getLineColFromPtr(string, ptr) {
  let lines = string.slice(0, ptr).split(/\r\n|\n|\r/g);
  return [lines.length, lines.pop().length + 1];
}
function makeCodeBlock(string, line, column) {
  let lines = string.split(/\r\n|\n|\r/g);
  let codeblock = "";
  let numberLen = (Math.log10(line + 1) | 0) + 1;
  for (let i = line - 1; i <= line + 1; i++) {
    let l = lines[i - 1];
    if (!l)
      continue;
    codeblock += i.toString().padEnd(numberLen, " ");
    codeblock += ":  ";
    codeblock += l;
    codeblock += "\n";
    if (i === line) {
      codeblock += " ".repeat(numberLen + column + 2);
      codeblock += "^\n";
    }
  }
  return codeblock;
}
var TomlError = class extends Error {
  constructor(message, options) {
    const [line, column] = getLineColFromPtr(options.toml, options.ptr);
    const codeblock = makeCodeBlock(options.toml, line, column);
    super(`Invalid TOML document: ${message}

${codeblock}`, options);
    __publicField(this, "line");
    __publicField(this, "column");
    __publicField(this, "codeblock");
    this.line = line;
    this.column = column;
    this.codeblock = codeblock;
  }
};

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/util.js
function isEscaped(str2, ptr) {
  let i = 0;
  while (str2[ptr - ++i] === "\\")
    ;
  return --i && i % 2;
}
function indexOfNewline(str2, start = 0, end = str2.length) {
  let idx = str2.indexOf("\n", start);
  if (str2[idx - 1] === "\r")
    idx--;
  return idx <= end ? idx : -1;
}
function skipComment(str2, ptr) {
  for (let i = ptr; i < str2.length; i++) {
    let c = str2[i];
    if (c === "\n")
      return i;
    if (c === "\r" && str2[i + 1] === "\n")
      return i + 1;
    if (c < " " && c !== "	" || c === "\x7F") {
      throw new TomlError("control characters are not allowed in comments", {
        toml: str2,
        ptr
      });
    }
  }
  return str2.length;
}
function skipVoid(str2, ptr, banNewLines, banComments) {
  let c;
  while ((c = str2[ptr]) === " " || c === "	" || !banNewLines && (c === "\n" || c === "\r" && str2[ptr + 1] === "\n"))
    ptr++;
  return banComments || c !== "#" ? ptr : skipVoid(str2, skipComment(str2, ptr), banNewLines);
}
function skipUntil(str2, ptr, sep2, end, banNewLines = false) {
  if (!end) {
    ptr = indexOfNewline(str2, ptr);
    return ptr < 0 ? str2.length : ptr;
  }
  for (let i = ptr; i < str2.length; i++) {
    let c = str2[i];
    if (c === "#") {
      i = indexOfNewline(str2, i);
    } else if (c === sep2) {
      return i + 1;
    } else if (c === end || banNewLines && (c === "\n" || c === "\r" && str2[i + 1] === "\n")) {
      return i;
    }
  }
  throw new TomlError("cannot find end of structure", {
    toml: str2,
    ptr
  });
}
function getStringEnd(str2, seek) {
  let first = str2[seek];
  let target = first === str2[seek + 1] && str2[seek + 1] === str2[seek + 2] ? str2.slice(seek, seek + 3) : first;
  seek += target.length - 1;
  do
    seek = str2.indexOf(target, ++seek);
  while (seek > -1 && first !== "'" && isEscaped(str2, seek));
  if (seek > -1) {
    seek += target.length;
    if (target.length > 1) {
      if (str2[seek] === first)
        seek++;
      if (str2[seek] === first)
        seek++;
    }
  }
  return seek;
}

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/date.js
var DATE_TIME_RE = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
var _hasDate, _hasTime, _offset;
var _TomlDate = class _TomlDate extends Date {
  constructor(date) {
    let hasDate = true;
    let hasTime = true;
    let offset = "Z";
    if (typeof date === "string") {
      let match2 = date.match(DATE_TIME_RE);
      if (match2) {
        if (!match2[1]) {
          hasDate = false;
          date = `0000-01-01T${date}`;
        }
        hasTime = !!match2[2];
        hasTime && date[10] === " " && (date = date.replace(" ", "T"));
        if (match2[2] && +match2[2] > 23) {
          date = "";
        } else {
          offset = match2[3] || null;
          date = date.toUpperCase();
          if (!offset && hasTime)
            date += "Z";
        }
      } else {
        date = "";
      }
    }
    super(date);
    __privateAdd(this, _hasDate, false);
    __privateAdd(this, _hasTime, false);
    __privateAdd(this, _offset, null);
    if (!isNaN(this.getTime())) {
      __privateSet(this, _hasDate, hasDate);
      __privateSet(this, _hasTime, hasTime);
      __privateSet(this, _offset, offset);
    }
  }
  isDateTime() {
    return __privateGet(this, _hasDate) && __privateGet(this, _hasTime);
  }
  isLocal() {
    return !__privateGet(this, _hasDate) || !__privateGet(this, _hasTime) || !__privateGet(this, _offset);
  }
  isDate() {
    return __privateGet(this, _hasDate) && !__privateGet(this, _hasTime);
  }
  isTime() {
    return __privateGet(this, _hasTime) && !__privateGet(this, _hasDate);
  }
  isValid() {
    return __privateGet(this, _hasDate) || __privateGet(this, _hasTime);
  }
  toISOString() {
    let iso = super.toISOString();
    if (this.isDate())
      return iso.slice(0, 10);
    if (this.isTime())
      return iso.slice(11, 23);
    if (__privateGet(this, _offset) === null)
      return iso.slice(0, -1);
    if (__privateGet(this, _offset) === "Z")
      return iso;
    let offset = +__privateGet(this, _offset).slice(1, 3) * 60 + +__privateGet(this, _offset).slice(4, 6);
    offset = __privateGet(this, _offset)[0] === "-" ? offset : -offset;
    let offsetDate = new Date(this.getTime() - offset * 6e4);
    return offsetDate.toISOString().slice(0, -1) + __privateGet(this, _offset);
  }
  static wrapAsOffsetDateTime(jsDate, offset = "Z") {
    let date = new _TomlDate(jsDate);
    __privateSet(date, _offset, offset);
    return date;
  }
  static wrapAsLocalDateTime(jsDate) {
    let date = new _TomlDate(jsDate);
    __privateSet(date, _offset, null);
    return date;
  }
  static wrapAsLocalDate(jsDate) {
    let date = new _TomlDate(jsDate);
    __privateSet(date, _hasTime, false);
    __privateSet(date, _offset, null);
    return date;
  }
  static wrapAsLocalTime(jsDate) {
    let date = new _TomlDate(jsDate);
    __privateSet(date, _hasDate, false);
    __privateSet(date, _offset, null);
    return date;
  }
};
_hasDate = new WeakMap();
_hasTime = new WeakMap();
_offset = new WeakMap();
var TomlDate = _TomlDate;

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/primitive.js
var INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;
var FLOAT_REGEX = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
var LEADING_ZERO = /^[+-]?0[0-9_]/;
var ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i;
var ESC_MAP = {
  b: "\b",
  t: "	",
  n: "\n",
  f: "\f",
  r: "\r",
  '"': '"',
  "\\": "\\"
};
function parseString(str2, ptr = 0, endPtr = str2.length) {
  let isLiteral = str2[ptr] === "'";
  let isMultiline = str2[ptr++] === str2[ptr] && str2[ptr] === str2[ptr + 1];
  if (isMultiline) {
    endPtr -= 2;
    if (str2[ptr += 2] === "\r")
      ptr++;
    if (str2[ptr] === "\n")
      ptr++;
  }
  let tmp = 0;
  let isEscape;
  let parsed = "";
  let sliceStart = ptr;
  while (ptr < endPtr - 1) {
    let c = str2[ptr++];
    if (c === "\n" || c === "\r" && str2[ptr] === "\n") {
      if (!isMultiline) {
        throw new TomlError("newlines are not allowed in strings", {
          toml: str2,
          ptr: ptr - 1
        });
      }
    } else if (c < " " && c !== "	" || c === "\x7F") {
      throw new TomlError("control characters are not allowed in strings", {
        toml: str2,
        ptr: ptr - 1
      });
    }
    if (isEscape) {
      isEscape = false;
      if (c === "u" || c === "U") {
        let code = str2.slice(ptr, ptr += c === "u" ? 4 : 8);
        if (!ESCAPE_REGEX.test(code)) {
          throw new TomlError("invalid unicode escape", {
            toml: str2,
            ptr: tmp
          });
        }
        try {
          parsed += String.fromCodePoint(parseInt(code, 16));
        } catch {
          throw new TomlError("invalid unicode escape", {
            toml: str2,
            ptr: tmp
          });
        }
      } else if (isMultiline && (c === "\n" || c === " " || c === "	" || c === "\r")) {
        ptr = skipVoid(str2, ptr - 1, true);
        if (str2[ptr] !== "\n" && str2[ptr] !== "\r") {
          throw new TomlError("invalid escape: only line-ending whitespace may be escaped", {
            toml: str2,
            ptr: tmp
          });
        }
        ptr = skipVoid(str2, ptr);
      } else if (c in ESC_MAP) {
        parsed += ESC_MAP[c];
      } else {
        throw new TomlError("unrecognized escape sequence", {
          toml: str2,
          ptr: tmp
        });
      }
      sliceStart = ptr;
    } else if (!isLiteral && c === "\\") {
      tmp = ptr - 1;
      isEscape = true;
      parsed += str2.slice(sliceStart, tmp);
    }
  }
  return parsed + str2.slice(sliceStart, endPtr - 1);
}
function parseValue(value, toml, ptr, integersAsBigInt) {
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  if (value === "-inf")
    return -Infinity;
  if (value === "inf" || value === "+inf")
    return Infinity;
  if (value === "nan" || value === "+nan" || value === "-nan")
    return NaN;
  if (value === "-0")
    return integersAsBigInt ? 0n : 0;
  let isInt = INT_REGEX.test(value);
  if (isInt || FLOAT_REGEX.test(value)) {
    if (LEADING_ZERO.test(value)) {
      throw new TomlError("leading zeroes are not allowed", {
        toml,
        ptr
      });
    }
    value = value.replace(/_/g, "");
    let numeric2 = +value;
    if (isNaN(numeric2)) {
      throw new TomlError("invalid number", {
        toml,
        ptr
      });
    }
    if (isInt) {
      if ((isInt = !Number.isSafeInteger(numeric2)) && !integersAsBigInt) {
        throw new TomlError("integer value cannot be represented losslessly", {
          toml,
          ptr
        });
      }
      if (isInt || integersAsBigInt === true)
        numeric2 = BigInt(value);
    }
    return numeric2;
  }
  const date = new TomlDate(value);
  if (!date.isValid()) {
    throw new TomlError("invalid value", {
      toml,
      ptr
    });
  }
  return date;
}

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/extract.js
function sliceAndTrimEndOf(str2, startPtr, endPtr, allowNewLines) {
  let value = str2.slice(startPtr, endPtr);
  let commentIdx = value.indexOf("#");
  if (commentIdx > -1) {
    skipComment(str2, commentIdx);
    value = value.slice(0, commentIdx);
  }
  let trimmed = value.trimEnd();
  if (!allowNewLines) {
    let newlineIdx = value.indexOf("\n", trimmed.length);
    if (newlineIdx > -1) {
      throw new TomlError("newlines are not allowed in inline tables", {
        toml: str2,
        ptr: startPtr + newlineIdx
      });
    }
  }
  return [trimmed, commentIdx];
}
function extractValue(str2, ptr, end, depth, integersAsBigInt) {
  if (depth === 0) {
    throw new TomlError("document contains excessively nested structures. aborting.", {
      toml: str2,
      ptr
    });
  }
  let c = str2[ptr];
  if (c === "[" || c === "{") {
    let [value, endPtr2] = c === "[" ? parseArray(str2, ptr, depth, integersAsBigInt) : parseInlineTable(str2, ptr, depth, integersAsBigInt);
    let newPtr = end ? skipUntil(str2, endPtr2, ",", end) : endPtr2;
    if (endPtr2 - newPtr && end === "}") {
      let nextNewLine = indexOfNewline(str2, endPtr2, newPtr);
      if (nextNewLine > -1) {
        throw new TomlError("newlines are not allowed in inline tables", {
          toml: str2,
          ptr: nextNewLine
        });
      }
    }
    return [value, newPtr];
  }
  let endPtr;
  if (c === '"' || c === "'") {
    endPtr = getStringEnd(str2, ptr);
    let parsed = parseString(str2, ptr, endPtr);
    if (end) {
      endPtr = skipVoid(str2, endPtr, end !== "]");
      if (str2[endPtr] && str2[endPtr] !== "," && str2[endPtr] !== end && str2[endPtr] !== "\n" && str2[endPtr] !== "\r") {
        throw new TomlError("unexpected character encountered", {
          toml: str2,
          ptr: endPtr
        });
      }
      endPtr += +(str2[endPtr] === ",");
    }
    return [parsed, endPtr];
  }
  endPtr = skipUntil(str2, ptr, ",", end);
  let slice = sliceAndTrimEndOf(str2, ptr, endPtr - +(str2[endPtr - 1] === ","), end === "]");
  if (!slice[0]) {
    throw new TomlError("incomplete key-value declaration: no value specified", {
      toml: str2,
      ptr
    });
  }
  if (end && slice[1] > -1) {
    endPtr = skipVoid(str2, ptr + slice[1]);
    endPtr += +(str2[endPtr] === ",");
  }
  return [
    parseValue(slice[0], str2, ptr, integersAsBigInt),
    endPtr
  ];
}

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/struct.js
var KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \t]*$/;
function parseKey(str2, ptr, end = "=") {
  let dot = ptr - 1;
  let parsed = [];
  let endPtr = str2.indexOf(end, ptr);
  if (endPtr < 0) {
    throw new TomlError("incomplete key-value: cannot find end of key", {
      toml: str2,
      ptr
    });
  }
  do {
    let c = str2[ptr = ++dot];
    if (c !== " " && c !== "	") {
      if (c === '"' || c === "'") {
        if (c === str2[ptr + 1] && c === str2[ptr + 2]) {
          throw new TomlError("multiline strings are not allowed in keys", {
            toml: str2,
            ptr
          });
        }
        let eos = getStringEnd(str2, ptr);
        if (eos < 0) {
          throw new TomlError("unfinished string encountered", {
            toml: str2,
            ptr
          });
        }
        dot = str2.indexOf(".", eos);
        let strEnd = str2.slice(eos, dot < 0 || dot > endPtr ? endPtr : dot);
        let newLine = indexOfNewline(strEnd);
        if (newLine > -1) {
          throw new TomlError("newlines are not allowed in keys", {
            toml: str2,
            ptr: ptr + dot + newLine
          });
        }
        if (strEnd.trimStart()) {
          throw new TomlError("found extra tokens after the string part", {
            toml: str2,
            ptr: eos
          });
        }
        if (endPtr < eos) {
          endPtr = str2.indexOf(end, eos);
          if (endPtr < 0) {
            throw new TomlError("incomplete key-value: cannot find end of key", {
              toml: str2,
              ptr
            });
          }
        }
        parsed.push(parseString(str2, ptr, eos));
      } else {
        dot = str2.indexOf(".", ptr);
        let part = str2.slice(ptr, dot < 0 || dot > endPtr ? endPtr : dot);
        if (!KEY_PART_RE.test(part)) {
          throw new TomlError("only letter, numbers, dashes and underscores are allowed in keys", {
            toml: str2,
            ptr
          });
        }
        parsed.push(part.trimEnd());
      }
    }
  } while (dot + 1 && dot < endPtr);
  return [parsed, skipVoid(str2, endPtr + 1, true, true)];
}
function parseInlineTable(str2, ptr, depth, integersAsBigInt) {
  let res = {};
  let seen = /* @__PURE__ */ new Set();
  let c;
  let comma = 0;
  ptr++;
  while ((c = str2[ptr++]) !== "}" && c) {
    let err = { toml: str2, ptr: ptr - 1 };
    if (c === "\n") {
      throw new TomlError("newlines are not allowed in inline tables", err);
    } else if (c === "#") {
      throw new TomlError("inline tables cannot contain comments", err);
    } else if (c === ",") {
      throw new TomlError("expected key-value, found comma", err);
    } else if (c !== " " && c !== "	") {
      let k;
      let t = res;
      let hasOwn = false;
      let [key, keyEndPtr] = parseKey(str2, ptr - 1);
      for (let i = 0; i < key.length; i++) {
        if (i)
          t = hasOwn ? t[k] : t[k] = {};
        k = key[i];
        if ((hasOwn = Object.hasOwn(t, k)) && (typeof t[k] !== "object" || seen.has(t[k]))) {
          throw new TomlError("trying to redefine an already defined value", {
            toml: str2,
            ptr
          });
        }
        if (!hasOwn && k === "__proto__") {
          Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
        }
      }
      if (hasOwn) {
        throw new TomlError("trying to redefine an already defined value", {
          toml: str2,
          ptr
        });
      }
      let [value, valueEndPtr] = extractValue(str2, keyEndPtr, "}", depth - 1, integersAsBigInt);
      seen.add(value);
      t[k] = value;
      ptr = valueEndPtr;
      comma = str2[ptr - 1] === "," ? ptr - 1 : 0;
    }
  }
  if (comma) {
    throw new TomlError("trailing commas are not allowed in inline tables", {
      toml: str2,
      ptr: comma
    });
  }
  if (!c) {
    throw new TomlError("unfinished table encountered", {
      toml: str2,
      ptr
    });
  }
  return [res, ptr];
}
function parseArray(str2, ptr, depth, integersAsBigInt) {
  let res = [];
  let c;
  ptr++;
  while ((c = str2[ptr++]) !== "]" && c) {
    if (c === ",") {
      throw new TomlError("expected value, found comma", {
        toml: str2,
        ptr: ptr - 1
      });
    } else if (c === "#")
      ptr = skipComment(str2, ptr);
    else if (c !== " " && c !== "	" && c !== "\n" && c !== "\r") {
      let e = extractValue(str2, ptr - 1, "]", depth - 1, integersAsBigInt);
      res.push(e[0]);
      ptr = e[1];
    }
  }
  if (!c) {
    throw new TomlError("unfinished array encountered", {
      toml: str2,
      ptr
    });
  }
  return [res, ptr];
}

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/parse.js
function peekTable(key, table, meta, type2) {
  let t = table;
  let m = meta;
  let k;
  let hasOwn = false;
  let state;
  for (let i = 0; i < key.length; i++) {
    if (i) {
      t = hasOwn ? t[k] : t[k] = {};
      m = (state = m[k]).c;
      if (type2 === 0 && (state.t === 1 || state.t === 2)) {
        return null;
      }
      if (state.t === 2) {
        let l = t.length - 1;
        t = t[l];
        m = m[l].c;
      }
    }
    k = key[i];
    if ((hasOwn = Object.hasOwn(t, k)) && m[k]?.t === 0 && m[k]?.d) {
      return null;
    }
    if (!hasOwn) {
      if (k === "__proto__") {
        Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
        Object.defineProperty(m, k, { enumerable: true, configurable: true, writable: true });
      }
      m[k] = {
        t: i < key.length - 1 && type2 === 2 ? 3 : type2,
        d: false,
        i: 0,
        c: {}
      };
    }
  }
  state = m[k];
  if (state.t !== type2 && !(type2 === 1 && state.t === 3)) {
    return null;
  }
  if (type2 === 2) {
    if (!state.d) {
      state.d = true;
      t[k] = [];
    }
    t[k].push(t = {});
    state.c[state.i++] = state = { t: 1, d: false, i: 0, c: {} };
  }
  if (state.d) {
    return null;
  }
  state.d = true;
  if (type2 === 1) {
    t = hasOwn ? t[k] : t[k] = {};
  } else if (type2 === 0 && hasOwn) {
    return null;
  }
  return [k, t, state.c];
}
function parse(toml, { maxDepth = 1e3, integersAsBigInt } = {}) {
  let res = {};
  let meta = {};
  let tbl = res;
  let m = meta;
  for (let ptr = skipVoid(toml, 0); ptr < toml.length; ) {
    if (toml[ptr] === "[") {
      let isTableArray = toml[++ptr] === "[";
      let k = parseKey(toml, ptr += +isTableArray, "]");
      if (isTableArray) {
        if (toml[k[1] - 1] !== "]") {
          throw new TomlError("expected end of table declaration", {
            toml,
            ptr: k[1] - 1
          });
        }
        k[1]++;
      }
      let p = peekTable(
        k[0],
        res,
        meta,
        isTableArray ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!p) {
        throw new TomlError("trying to redefine an already defined table or value", {
          toml,
          ptr
        });
      }
      m = p[2];
      tbl = p[1];
      ptr = k[1];
    } else {
      let k = parseKey(toml, ptr);
      let p = peekTable(
        k[0],
        tbl,
        m,
        0
        /* Type.DOTTED */
      );
      if (!p) {
        throw new TomlError("trying to redefine an already defined table or value", {
          toml,
          ptr
        });
      }
      let v = extractValue(toml, k[1], void 0, maxDepth, integersAsBigInt);
      p[1][p[0]] = v[0];
      ptr = v[1];
    }
    ptr = skipVoid(toml, ptr, true);
    if (toml[ptr] && toml[ptr] !== "\n" && toml[ptr] !== "\r") {
      throw new TomlError("each key-value declaration must be followed by an end-of-line", {
        toml,
        ptr
      });
    }
    ptr = skipVoid(toml, ptr);
  }
  return res;
}

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/stringify.js
var BARE_KEY = /^[a-z0-9-_]+$/i;
function extendedTypeOf(obj) {
  let type2 = typeof obj;
  if (type2 === "object") {
    if (Array.isArray(obj))
      return "array";
    if (obj instanceof Date)
      return "date";
  }
  return type2;
}
function isArrayOfTables(obj) {
  for (let i = 0; i < obj.length; i++) {
    if (extendedTypeOf(obj[i]) !== "object")
      return false;
  }
  return obj.length != 0;
}
function formatString(s) {
  return JSON.stringify(s).replace(/\x7f/g, "\\u007f");
}
function stringifyValue(val, type2, depth, numberAsFloat) {
  if (depth === 0) {
    throw new Error("Could not stringify the object: maximum object depth exceeded");
  }
  if (type2 === "number") {
    if (isNaN(val))
      return "nan";
    if (val === Infinity)
      return "inf";
    if (val === -Infinity)
      return "-inf";
    if (numberAsFloat && Number.isInteger(val))
      return val.toFixed(1);
    return val.toString();
  }
  if (type2 === "bigint" || type2 === "boolean") {
    return val.toString();
  }
  if (type2 === "string") {
    return formatString(val);
  }
  if (type2 === "date") {
    if (isNaN(val.getTime())) {
      throw new TypeError("cannot serialize invalid date");
    }
    return val.toISOString();
  }
  if (type2 === "object") {
    return stringifyInlineTable(val, depth, numberAsFloat);
  }
  if (type2 === "array") {
    return stringifyArray(val, depth, numberAsFloat);
  }
}
function stringifyInlineTable(obj, depth, numberAsFloat) {
  let keys = Object.keys(obj);
  if (keys.length === 0)
    return "{}";
  let res = "{ ";
  for (let i = 0; i < keys.length; i++) {
    let k = keys[i];
    if (i)
      res += ", ";
    res += BARE_KEY.test(k) ? k : formatString(k);
    res += " = ";
    res += stringifyValue(obj[k], extendedTypeOf(obj[k]), depth - 1, numberAsFloat);
  }
  return res + " }";
}
function stringifyArray(array, depth, numberAsFloat) {
  if (array.length === 0)
    return "[]";
  let res = "[ ";
  for (let i = 0; i < array.length; i++) {
    if (i)
      res += ", ";
    if (array[i] === null || array[i] === void 0) {
      throw new TypeError("arrays cannot contain null or undefined values");
    }
    res += stringifyValue(array[i], extendedTypeOf(array[i]), depth - 1, numberAsFloat);
  }
  return res + " ]";
}
function stringifyArrayTable(array, key, depth, numberAsFloat) {
  if (depth === 0) {
    throw new Error("Could not stringify the object: maximum object depth exceeded");
  }
  let res = "";
  for (let i = 0; i < array.length; i++) {
    res += `${res && "\n"}[[${key}]]
`;
    res += stringifyTable(0, array[i], key, depth, numberAsFloat);
  }
  return res;
}
function stringifyTable(tableKey, obj, prefix, depth, numberAsFloat) {
  if (depth === 0) {
    throw new Error("Could not stringify the object: maximum object depth exceeded");
  }
  let preamble = "";
  let tables = "";
  let keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    let k = keys[i];
    if (obj[k] !== null && obj[k] !== void 0) {
      let type2 = extendedTypeOf(obj[k]);
      if (type2 === "symbol" || type2 === "function") {
        throw new TypeError(`cannot serialize values of type '${type2}'`);
      }
      let key = BARE_KEY.test(k) ? k : formatString(k);
      if (type2 === "array" && isArrayOfTables(obj[k])) {
        tables += (tables && "\n") + stringifyArrayTable(obj[k], prefix ? `${prefix}.${key}` : key, depth - 1, numberAsFloat);
      } else if (type2 === "object") {
        let tblKey = prefix ? `${prefix}.${key}` : key;
        tables += (tables && "\n") + stringifyTable(tblKey, obj[k], tblKey, depth - 1, numberAsFloat);
      } else {
        preamble += key;
        preamble += " = ";
        preamble += stringifyValue(obj[k], type2, depth, numberAsFloat);
        preamble += "\n";
      }
    }
  }
  if (tableKey && (preamble || !tables))
    preamble = preamble ? `[${tableKey}]
${preamble}` : `[${tableKey}]`;
  return preamble && tables ? `${preamble}
${tables}` : preamble || tables;
}
function stringify(obj, { maxDepth = 1e3, numbersAsFloat = false } = {}) {
  if (extendedTypeOf(obj) !== "object") {
    throw new TypeError("stringify can only be called with an object");
  }
  let str2 = stringifyTable(0, obj, "", maxDepth, numbersAsFloat);
  if (str2[str2.length - 1] !== "\n")
    return str2 + "\n";
  return str2;
}

// ../../node_modules/.pnpm/smol-toml@1.5.2/node_modules/smol-toml/dist/index.js
var dist_default = { parse, stringify, TomlDate, TomlError };

// ../python-analysis/dist/index.js
var import_path3 = __toESM(require("path"), 1);
var import_fs_extra = __toESM(require_lib(), 1);
var import_util5 = __toESM(require("util"), 1);
var import_assert = __toESM(require("assert"), 1);
var import_version = __toESM(require_version(), 1);
var import_pep440 = __toESM(require_pep440(), 1);
var import_specifier = __toESM(require_specifier(), 1);

// ../../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs
var util;
(function(util3) {
  util3.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util3.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util3.assertNever = assertNever;
  util3.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util3.getValidEnumValues = (obj) => {
    const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util3.objectValues(filtered);
  };
  util3.objectValues = (obj) => {
    return util3.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util3.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util3.joinValues = joinValues;
  util3.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path: path5, errorMaps, issueData } = params;
  const fullPath = [...path5, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path5, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path5;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema2, params) => {
  return new ZodArray({
    type: schema2,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema2.shape) {
      const fieldSchema = schema2.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: () => newShape
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema2) {
    return this.augment({ [key]: schema2 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types3, params) => {
  return new ZodUnion({
    options: types3,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema2 = this._def.items[itemIndex] || this._def.rest;
      if (!schema2)
        return null;
      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema2, params) => {
  return new ZodPromise({
    type: schema2,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema2, effect, params) => {
  return new ZodEffects({
    schema: schema2,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
  return new ZodEffects({
    schema: schema2,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// ../python-analysis/dist/index.js
var import_path4 = require("path");
var import_pip_requirements_js = __toESM(require_dist(), 1);
var isErrnoException = (error, code = void 0) => {
  return import_util5.default.types.isNativeError(error) && "code" in error && (code === void 0 || error.code === code);
};
var PythonAnalysisError = class extends Error {
  constructor({
    message,
    code,
    path: path42,
    link,
    action,
    fileContent
  }) {
    super(message);
    this.hideStackTrace = true;
    this.name = "PythonAnalysisError";
    this.code = code;
    this.path = path42;
    this.link = link;
    this.action = action;
    this.fileContent = fileContent;
  }
};
async function readFileIfExists(file) {
  try {
    return await (0, import_fs_extra.readFile)(file);
  } catch (error) {
    if (!isErrnoException(error, "ENOENT")) {
      throw error;
    }
  }
  return null;
}
async function readFileTextIfExists(file, encoding = "utf8") {
  const data = await readFileIfExists(file);
  if (data == null) {
    return null;
  } else {
    return data.toString(encoding);
  }
}
function normalizePath(p) {
  let np = import_path3.default.normalize(p);
  if (np.endsWith(import_path3.default.sep)) {
    np = np.slice(0, -1);
  }
  return np;
}
function isSubpath(somePath, parentPath) {
  const rel = import_path3.default.relative(parentPath, somePath);
  return rel === "" || !rel.startsWith("..") && !import_path3.default.isAbsolute(rel);
}
function parseRawConfig(content, filename, filetype = void 0) {
  if (filetype === void 0) {
    filetype = import_path2.default.extname(filename.toLowerCase());
  }
  try {
    if (filetype === ".json") {
      return JSON.parse(content);
    } else if (filetype === ".toml") {
      return dist_default.parse(content);
    } else if (filetype === ".yaml" || filetype === ".yml") {
      return jsYaml.load(content, { filename });
    } else {
      throw new PythonAnalysisError({
        message: `Could not parse config file "${filename}": unrecognized config format`,
        code: "PYTHON_CONFIG_UNKNOWN_FORMAT",
        path: filename
      });
    }
  } catch (error) {
    if (error instanceof PythonAnalysisError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PythonAnalysisError({
        message: `Could not parse config file "${filename}": ${error.message}`,
        code: "PYTHON_CONFIG_PARSE_ERROR",
        path: filename,
        fileContent: content
      });
    }
    throw error;
  }
}
function parseConfig(content, filename, schema2, filetype = void 0) {
  const raw = parseRawConfig(content, filename, filetype);
  const result = schema2.safeParse(raw);
  if (!result.success) {
    const issues = result.error.issues.map((issue) => {
      const path42 = issue.path.length > 0 ? issue.path.join(".") : "(root)";
      return `  - ${path42}: ${issue.message}`;
    }).join("\n");
    throw new PythonAnalysisError({
      message: `Invalid config in "${filename}":
${issues}`,
      code: "PYTHON_CONFIG_VALIDATION_ERROR",
      path: filename,
      fileContent: content
    });
  }
  return result.data;
}
async function readConfigIfExists(filename, schema2, filetype = void 0) {
  const content = await readFileTextIfExists(filename);
  if (content == null) {
    return null;
  }
  return parseConfig(content, filename, schema2, filetype);
}
function pep440ConstraintFromVersion(v) {
  return [
    {
      operator: "==",
      version: unparsePep440Version(v),
      prefix: ""
    }
  ];
}
function unparsePep440Version(v) {
  const verstr = (0, import_version.stringify)(v);
  (0, import_assert.default)(verstr != null, "pep440/lib/version:stringify returned null");
  return verstr;
}
var pipfileDependencyDetailSchema = z.object({
  version: z.string().optional(),
  hashes: z.array(z.string()).optional(),
  extras: z.union([z.array(z.string()), z.string()]).optional(),
  markers: z.string().optional(),
  index: z.string().optional(),
  git: z.string().optional(),
  ref: z.string().optional(),
  editable: z.boolean().optional(),
  path: z.string().optional()
});
var pipfileDependencySchema = z.union([
  z.string(),
  pipfileDependencyDetailSchema
]);
var pipfileSourceSchema = z.object({
  name: z.string(),
  url: z.string(),
  verify_ssl: z.boolean().optional()
});
var pipfileLikeSchema = z.record(
  z.union([
    z.record(pipfileDependencySchema),
    z.array(pipfileSourceSchema),
    z.record(z.string()),
    z.undefined()
  ])
).and(
  z.object({
    packages: z.record(pipfileDependencySchema).optional(),
    "dev-packages": z.record(pipfileDependencySchema).optional(),
    source: z.array(pipfileSourceSchema).optional(),
    scripts: z.record(z.string()).optional()
  })
);
var pipfileLockMetaSchema = z.object({
  hash: z.object({
    sha256: z.string().optional()
  }).optional(),
  "pipfile-spec": z.number().optional(),
  requires: z.object({
    python_version: z.string().optional(),
    python_full_version: z.string().optional()
  }).optional(),
  sources: z.array(pipfileSourceSchema).optional()
});
var pipfileLockLikeSchema = z.record(
  z.union([
    pipfileLockMetaSchema,
    z.record(pipfileDependencyDetailSchema),
    z.undefined()
  ])
).and(
  z.object({
    _meta: pipfileLockMetaSchema.optional(),
    default: z.record(pipfileDependencyDetailSchema).optional(),
    develop: z.record(pipfileDependencyDetailSchema).optional()
  })
);
var PipfileDependencyDetailSchema = pipfileDependencyDetailSchema.passthrough();
var PipfileSourceSchema = pipfileSourceSchema.passthrough();
var PipfileLikeSchema = pipfileLikeSchema;
var PipfileLockMetaSchema = pipfileLockMetaSchema.passthrough();
var PipfileLockLikeSchema = pipfileLockLikeSchema;
var EXTRAS_REGEX = /^(.+)\[([^\]]+)\]$/;
function splitExtras(spec) {
  const match2 = EXTRAS_REGEX.exec(spec);
  if (!match2) {
    return [spec, void 0];
  }
  const extras = match2[2].split(",").map((e) => e.trim());
  return [match2[1], extras];
}
function formatPep508(req) {
  let result = req.name;
  if (req.extras && req.extras.length > 0) {
    result += `[${req.extras.join(",")}]`;
  }
  if (req.url) {
    result += ` @ ${req.url}`;
  } else if (req.version && req.version !== "*") {
    result += req.version;
  }
  if (req.markers) {
    result += ` ; ${req.markers}`;
  }
  return result;
}
function mergeExtras(existing, additional) {
  const result = new Set(existing || []);
  if (additional) {
    const additionalArray = Array.isArray(additional) ? additional : [additional];
    for (const extra of additionalArray) {
      result.add(extra);
    }
  }
  return result.size > 0 ? Array.from(result) : void 0;
}
function isPlainObject(value) {
  return value != null && typeof value === "object" && !Array.isArray(value);
}
var PYPI_INDEX_NAME = "pypi";
function addDepSource(sources, dep) {
  if (!dep.source) {
    return;
  }
  if (Object.prototype.hasOwnProperty.call(sources, dep.name)) {
    sources[dep.name].push(dep.source);
  } else {
    sources[dep.name] = [dep.source];
  }
}
function isPypiSource(source) {
  return typeof source?.name === "string" && source.name === PYPI_INDEX_NAME;
}
function processIndexSources(sources) {
  const hasPypi = sources.some(isPypiSource);
  const setExplicit = sources.length > 1 && hasPypi;
  const indexes = [];
  for (const source of sources) {
    if (isPypiSource(source)) {
      continue;
    }
    const entry = {
      name: source.name,
      url: source.url
    };
    if (setExplicit) {
      entry.explicit = true;
    }
    indexes.push(entry);
  }
  return indexes;
}
function buildUvToolSection(sources, indexes) {
  const uv = {};
  if (indexes.length > 0) {
    uv.index = indexes;
  }
  if (Object.keys(sources).length > 0) {
    uv.sources = sources;
  }
  return Object.keys(uv).length > 0 ? uv : null;
}
function pipfileDepsToRequirements(entries) {
  const deps = [];
  for (const [name, properties] of Object.entries(entries)) {
    const dep = pipfileDepToRequirement(name, properties);
    deps.push(dep);
  }
  return deps;
}
function pipfileDepToRequirement(spec, properties) {
  const [name, extrasFromName] = splitExtras(spec);
  const dep = { name };
  if (extrasFromName && extrasFromName.length > 0) {
    dep.extras = extrasFromName;
  }
  if (typeof properties === "string") {
    dep.version = properties;
  } else if (properties && typeof properties === "object") {
    if (properties.version) {
      dep.version = properties.version;
    }
    if (properties.extras) {
      dep.extras = mergeExtras(dep.extras, properties.extras);
    }
    if (properties.markers) {
      dep.markers = properties.markers;
    }
    const source = buildDependencySource(properties);
    if (source) {
      dep.source = source;
    }
  }
  return dep;
}
function pipfileLockDepsToRequirements(entries) {
  const deps = [];
  for (const [name, properties] of Object.entries(entries)) {
    const dep = pipfileLockDepToRequirement(name, properties);
    deps.push(dep);
  }
  return deps;
}
function pipfileLockDepToRequirement(spec, properties) {
  const [name, extrasFromName] = splitExtras(spec);
  const dep = { name };
  if (extrasFromName && extrasFromName.length > 0) {
    dep.extras = extrasFromName;
  }
  if (properties.version) {
    dep.version = properties.version;
  }
  if (properties.extras) {
    dep.extras = mergeExtras(dep.extras, properties.extras);
  }
  if (properties.markers) {
    dep.markers = properties.markers;
  }
  const source = buildDependencySource(properties);
  if (source) {
    dep.source = source;
  }
  return dep;
}
function buildDependencySource(properties) {
  const source = {};
  if (properties.index && properties.index !== PYPI_INDEX_NAME) {
    source.index = properties.index;
  }
  if (properties.git) {
    source.git = properties.git;
    if (properties.ref) {
      source.rev = properties.ref;
    }
  }
  if (properties.path) {
    source.path = properties.path;
    if (properties.editable) {
      source.editable = true;
    }
  }
  return Object.keys(source).length > 0 ? source : null;
}
function convertPipfileToPyprojectToml(pipfile) {
  const sources = {};
  const pyproject = {};
  const deps = [];
  for (const dep of pipfileDepsToRequirements(pipfile.packages || {})) {
    deps.push(formatPep508(dep));
    addDepSource(sources, dep);
  }
  if (deps.length > 0) {
    pyproject.project = {
      name: "app",
      version: "0.1.0",
      dependencies: deps
    };
  }
  const devDeps = [];
  for (const dep of pipfileDepsToRequirements(pipfile["dev-packages"] || {})) {
    devDeps.push(formatPep508(dep));
    addDepSource(sources, dep);
  }
  if (devDeps.length > 0) {
    pyproject["dependency-groups"] = {
      dev: devDeps
    };
  }
  const RESERVED_KEYS = /* @__PURE__ */ new Set([
    "packages",
    "dev-packages",
    "source",
    "scripts",
    "requires",
    "pipenv"
  ]);
  for (const [sectionName, value] of Object.entries(pipfile)) {
    if (RESERVED_KEYS.has(sectionName))
      continue;
    if (!isPlainObject(value))
      continue;
    const groupDeps = [];
    for (const dep of pipfileDepsToRequirements(
      value
    )) {
      groupDeps.push(formatPep508(dep));
      addDepSource(sources, dep);
    }
    if (groupDeps.length > 0) {
      pyproject["dependency-groups"] = {
        ...pyproject["dependency-groups"] || {},
        [sectionName]: groupDeps
      };
    }
  }
  const indexes = processIndexSources(pipfile.source ?? []);
  const uv = buildUvToolSection(sources, indexes);
  if (uv) {
    pyproject.tool = { uv };
  }
  return pyproject;
}
function convertPipfileLockToPyprojectToml(pipfileLock) {
  const sources = {};
  const pyproject = {};
  const deps = [];
  for (const dep of pipfileLockDepsToRequirements(pipfileLock.default || {})) {
    deps.push(formatPep508(dep));
    addDepSource(sources, dep);
  }
  if (deps.length > 0) {
    pyproject.project = {
      name: "app",
      version: "0.1.0",
      dependencies: deps
    };
  }
  const devDeps = [];
  for (const dep of pipfileLockDepsToRequirements(pipfileLock.develop || {})) {
    devDeps.push(formatPep508(dep));
    addDepSource(sources, dep);
  }
  if (devDeps.length > 0) {
    pyproject["dependency-groups"] = {
      dev: devDeps
    };
  }
  const RESERVED_KEYS = /* @__PURE__ */ new Set(["_meta", "default", "develop"]);
  for (const [sectionName, value] of Object.entries(pipfileLock)) {
    if (RESERVED_KEYS.has(sectionName))
      continue;
    if (!isPlainObject(value))
      continue;
    const groupDeps = [];
    for (const dep of pipfileLockDepsToRequirements(
      value
    )) {
      groupDeps.push(formatPep508(dep));
      addDepSource(sources, dep);
    }
    if (groupDeps.length > 0) {
      pyproject["dependency-groups"] = {
        ...pyproject["dependency-groups"] || {},
        [sectionName]: groupDeps
      };
    }
  }
  const indexes = processIndexSources(pipfileLock._meta?.sources ?? []);
  const uv = buildUvToolSection(sources, indexes);
  if (uv) {
    pyproject.tool = { uv };
  }
  return pyproject;
}
var dependencySourceSchema = z.object({
  index: z.string().optional(),
  git: z.string().optional(),
  rev: z.string().optional(),
  path: z.string().optional(),
  editable: z.boolean().optional()
});
var normalizedRequirementSchema = z.object({
  name: z.string(),
  version: z.string().optional(),
  extras: z.array(z.string()).optional(),
  markers: z.string().optional(),
  url: z.string().optional(),
  hashes: z.array(z.string()).optional(),
  source: dependencySourceSchema.optional()
});
var hashDigestSchema = z.string();
var uvConfigWorkspaceSchema = z.object({
  members: z.array(z.string()).optional(),
  exclude: z.array(z.string()).optional()
});
var uvIndexEntrySchema = z.object({
  name: z.string(),
  url: z.string(),
  default: z.boolean().optional(),
  explicit: z.boolean().optional(),
  format: z.string().optional()
});
var uvConfigSchema = z.object({
  sources: z.record(z.union([dependencySourceSchema, z.array(dependencySourceSchema)])).optional(),
  index: z.array(uvIndexEntrySchema).optional(),
  workspace: uvConfigWorkspaceSchema.optional()
});
var pyProjectBuildSystemSchema = z.object({
  requires: z.array(z.string()),
  "build-backend": z.string().optional(),
  "backend-path": z.array(z.string()).optional()
});
var personSchema = z.object({
  name: z.string().optional(),
  email: z.string().optional()
});
var readmeObjectSchema = z.object({
  file: z.union([z.string(), z.array(z.string())]),
  content_type: z.string().optional()
});
var readmeSchema = z.union([z.string(), readmeObjectSchema]);
var licenseObjectSchema = z.object({
  text: z.string().optional(),
  file: z.string().optional()
});
var licenseSchema = z.union([z.string(), licenseObjectSchema]);
var pyProjectProjectSchema = z.object({
  name: z.string().optional(),
  version: z.string().optional(),
  description: z.string().optional(),
  readme: readmeSchema.optional(),
  keywords: z.array(z.string()).optional(),
  authors: z.array(personSchema).optional(),
  maintainers: z.array(personSchema).optional(),
  license: licenseSchema.optional(),
  classifiers: z.array(z.string()).optional(),
  urls: z.record(z.string()).optional(),
  dependencies: z.array(z.string()).optional(),
  "optional-dependencies": z.record(z.array(z.string())).optional(),
  dynamic: z.array(z.string()).optional(),
  "requires-python": z.string().optional(),
  scripts: z.record(z.string()).optional(),
  entry_points: z.record(z.record(z.string())).optional()
});
var pyProjectDependencyGroupsSchema = z.record(z.array(z.string()));
var pyProjectToolSectionSchema = z.object({
  uv: uvConfigSchema.optional()
});
var pyProjectTomlSchema = z.object({
  project: pyProjectProjectSchema.optional(),
  "build-system": pyProjectBuildSystemSchema.optional(),
  "dependency-groups": pyProjectDependencyGroupsSchema.optional(),
  tool: pyProjectToolSectionSchema.optional()
});
var PyProjectBuildSystemSchema = pyProjectBuildSystemSchema.passthrough();
var PersonSchema = personSchema.passthrough();
var ReadmeObjectSchema = readmeObjectSchema.passthrough();
var LicenseObjectSchema = licenseObjectSchema.passthrough();
var PyProjectProjectSchema = pyProjectProjectSchema.passthrough();
var PyProjectToolSectionSchema = pyProjectToolSectionSchema.passthrough();
var PyProjectTomlSchema = pyProjectTomlSchema.passthrough();
var PRIMARY_INDEX_NAME = "primary";
var EXTRA_INDEX_PREFIX = "extra-";
var FIND_LINKS_PREFIX = "find-links-";
function parseGitUrl(url) {
  if (!url.startsWith("git+")) {
    return null;
  }
  let remaining = url.slice(4);
  let egg;
  const fragmentIdx = remaining.indexOf("#");
  if (fragmentIdx !== -1) {
    const fragment = remaining.slice(fragmentIdx + 1);
    remaining = remaining.slice(0, fragmentIdx);
    for (const part of fragment.split("&")) {
      const [key, value] = part.split("=");
      if (key === "egg" && value) {
        egg = value;
      }
    }
  }
  let ref;
  const lastSlashIdx = remaining.lastIndexOf("/");
  const atIdx = remaining.indexOf("@", lastSlashIdx > 0 ? lastSlashIdx : 0);
  if (atIdx !== -1 && atIdx > remaining.indexOf("://")) {
    ref = remaining.slice(atIdx + 1);
    remaining = remaining.slice(0, atIdx);
  }
  return {
    url: remaining,
    ref,
    egg
  };
}
function isGitUrl(url) {
  return url.startsWith("git+");
}
function extractPipArguments(fileContent) {
  const options = {
    requirementFiles: [],
    constraintFiles: [],
    extraIndexUrls: []
  };
  const lines = fileContent.split(/\r?\n/);
  const cleanedLines = [];
  const pathRequirements = [];
  const editableRequirements = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();
    if (trimmed === "" || trimmed.startsWith("#")) {
      cleanedLines.push(line);
      continue;
    }
    let fullLine = trimmed;
    let linesConsumed = 0;
    while (fullLine.endsWith("\\") && i + linesConsumed + 1 < lines.length) {
      linesConsumed++;
      fullLine = fullLine.slice(0, -1) + lines[i + linesConsumed].trim();
    }
    const extracted = tryExtractPipArgument(fullLine, options);
    if (extracted === true) {
      i += linesConsumed;
    } else if (typeof extracted === "object" && extracted.editable) {
      editableRequirements.push(extracted.editable);
      i += linesConsumed;
    } else {
      if (/^-[a-zA-Z]/.test(fullLine) && !fullLine.startsWith("-r") && !fullLine.startsWith("-c")) {
        i += linesConsumed;
        continue;
      }
      const strippedLine = stripInlineHashes(fullLine);
      const effectiveLine = (strippedLine !== fullLine ? strippedLine : fullLine).trim();
      if (isPathOrUrlRequirement(effectiveLine)) {
        pathRequirements.push(effectiveLine);
      } else if (strippedLine !== fullLine) {
        cleanedLines.push(strippedLine);
      } else {
        cleanedLines.push(line);
        for (let j = 1; j <= linesConsumed; j++) {
          cleanedLines.push(lines[i + j]);
        }
      }
      i += linesConsumed;
    }
  }
  return {
    cleanedContent: cleanedLines.join("\n"),
    options,
    pathRequirements,
    editableRequirements
  };
}
function tryExtractPipArgument(line, options) {
  if (line.startsWith("--requirement")) {
    const path42 = extractArgValue(line, "--requirement");
    if (path42) {
      options.requirementFiles.push(path42);
      return true;
    }
  }
  if (line.startsWith("--constraint")) {
    const path42 = extractArgValue(line, "--constraint");
    if (path42) {
      options.constraintFiles.push(path42);
      return true;
    }
  }
  if (line.startsWith("--index-url")) {
    const url = extractArgValue(line, "--index-url");
    if (url) {
      options.indexUrl = url;
      return true;
    }
  }
  if (line.startsWith("-i ") || line === "-i") {
    const match2 = line.match(/^-i\s+(\S+)/);
    if (match2) {
      options.indexUrl = match2[1];
      return true;
    }
  }
  if (line.startsWith("--extra-index-url")) {
    const url = extractArgValue(line, "--extra-index-url");
    if (url) {
      options.extraIndexUrls.push(url);
      return true;
    }
  }
  if (line.startsWith("--editable")) {
    const path42 = extractArgValue(line, "--editable");
    if (path42) {
      return { editable: path42 };
    }
  }
  if (line.startsWith("-e ") || line.startsWith("-e	")) {
    const path42 = line.slice(2).trim();
    if (path42) {
      return { editable: path42 };
    }
  }
  if (line.startsWith("--find-links")) {
    const url = extractArgValue(line, "--find-links");
    if (url) {
      if (!options.findLinks)
        options.findLinks = [];
      options.findLinks.push(url);
      return true;
    }
  }
  if (line.startsWith("-f ") || line.startsWith("-f	")) {
    const match2 = line.match(/^-f\s+(\S+)/);
    if (match2) {
      if (!options.findLinks)
        options.findLinks = [];
      options.findLinks.push(match2[1]);
      return true;
    }
  }
  if (line === "--no-index" || line.startsWith("--no-index ")) {
    options.noIndex = true;
    return true;
  }
  if (line.startsWith("--no-binary") || line.startsWith("--only-binary")) {
    return true;
  }
  if (line.startsWith("--")) {
    return true;
  }
  return false;
}
function stripInlineHashes(line) {
  return line.replace(/\s+--hash=\S+/g, "").trim();
}
function extractInlineHashes(line) {
  const hashes = [];
  const hashRegex = /--hash=(\S+)/g;
  let match2;
  while ((match2 = hashRegex.exec(line)) != null) {
    hashes.push(match2[1]);
  }
  return hashes;
}
function extractArgValue(line, option) {
  let value = null;
  if (line.startsWith(`${option}=`)) {
    value = line.slice(option.length + 1).trim();
  } else if (line.startsWith(`${option} `) || line.startsWith(`${option}	`)) {
    value = line.slice(option.length).trim();
  }
  if (!value)
    return null;
  const commentIdx = value.indexOf(" #");
  if (commentIdx !== -1) {
    value = value.slice(0, commentIdx).trim();
  }
  return value || null;
}
function isPathOrUrlRequirement(line) {
  if (line.startsWith("./") || line.startsWith("../"))
    return true;
  if (line.startsWith("/"))
    return true;
  if (line.startsWith("~/"))
    return true;
  if (/^(https?|ftp|file):\/\//i.test(line))
    return true;
  if (isBareArchiveFilename(line))
    return true;
  return false;
}
function isBareArchiveFilename(line) {
  if (line.includes(" @ "))
    return false;
  let check = line;
  const commentIdx = check.indexOf(" #");
  if (commentIdx !== -1)
    check = check.slice(0, commentIdx);
  const markerIdx = check.indexOf(" ;");
  if (markerIdx !== -1)
    check = check.slice(0, markerIdx);
  const extrasIdx = check.indexOf("[");
  if (extrasIdx !== -1)
    check = check.slice(0, extrasIdx);
  check = check.trim();
  return /\.(whl|tar\.gz|tar\.bz2|tar\.xz|zip)$/i.test(check);
}
function parseWheelFilename(filename) {
  if (!filename.endsWith(".whl"))
    return null;
  const stem = filename.slice(0, -4);
  const parts = stem.split("-");
  if (parts.length < 5 || parts.length > 6)
    return null;
  const name = parts[0];
  const version2 = parts[1];
  if (!name || !version2)
    return null;
  return {
    name: name.replace(/_/g, "-"),
    version: version2
  };
}
function parseSdistFilename(filename) {
  let stem = filename;
  for (const ext2 of [".tar.gz", ".tar.bz2", ".tar.xz", ".zip"]) {
    if (stem.endsWith(ext2)) {
      stem = stem.slice(0, -ext2.length);
      break;
    }
  }
  if (stem === filename)
    return null;
  const parts = stem.split("-");
  let versionIdx = -1;
  for (let i = 1; i < parts.length; i++) {
    if (/^\d/.test(parts[i])) {
      versionIdx = i;
      break;
    }
  }
  if (versionIdx === -1)
    return null;
  return {
    name: parts.slice(0, versionIdx).join("-"),
    version: parts.slice(versionIdx).join("-")
  };
}
function normalizePathRequirement(rawLine) {
  let line = rawLine;
  const commentIdx = line.indexOf(" #");
  if (commentIdx !== -1) {
    line = line.slice(0, commentIdx).trim();
  }
  let markers;
  const markerIdx = line.indexOf(" ;");
  if (markerIdx !== -1) {
    markers = line.slice(markerIdx + 2).trim();
    line = line.slice(0, markerIdx).trim();
  }
  let extras;
  const extrasMatch = line.match(/\[([^\]]+)\]$/);
  if (extrasMatch) {
    extras = extrasMatch[1].split(",").map((e) => e.trim());
    line = line.slice(0, extrasMatch.index).trim();
  }
  const isUrl = /^(https?|ftp|file):\/\//i.test(line);
  let filename;
  if (isUrl) {
    try {
      const url = new URL(line);
      filename = url.pathname.split("/").pop() || "";
    } catch {
      return null;
    }
  } else {
    const cleanPath = line.replace(/\/+$/, "");
    filename = cleanPath.split("/").pop() || "";
  }
  if (!filename)
    return null;
  let name;
  let version2;
  const wheelParsed = parseWheelFilename(filename);
  if (wheelParsed) {
    name = wheelParsed.name;
    version2 = wheelParsed.version;
  }
  if (!name) {
    const sdistParsed = parseSdistFilename(filename);
    if (sdistParsed) {
      name = sdistParsed.name;
      version2 = sdistParsed.version;
    }
  }
  if (!name) {
    name = filename.replace(/[-_.]+/g, "-").toLowerCase();
  }
  if (!name)
    return null;
  const req = { name };
  if (version2) {
    req.version = `==${version2}`;
  }
  if (extras && extras.length > 0) {
    req.extras = extras;
  }
  if (markers) {
    req.markers = markers;
  }
  if (isUrl) {
    req.url = line;
  } else {
    req.source = { path: line };
  }
  return req;
}
function convertRequirementsToPyprojectToml(fileContent, readFile3) {
  const pyproject = {};
  const parsed = parseRequirementsFile(fileContent, readFile3);
  const deps = [];
  const sources = {};
  for (const req of parsed.requirements) {
    deps.push(formatPep508(req));
    if (req.source) {
      if (Object.prototype.hasOwnProperty.call(sources, req.name)) {
        sources[req.name].push(req.source);
      } else {
        sources[req.name] = [req.source];
      }
    }
  }
  if (deps.length > 0) {
    pyproject.project = {
      name: "app",
      version: "0.1.0",
      dependencies: deps
    };
  }
  const uv = {};
  const indexes = buildIndexEntries(parsed.pipOptions);
  if (indexes.length > 0) {
    uv.index = indexes;
  }
  if (Object.keys(sources).length > 0) {
    uv.sources = sources;
  }
  if (Object.keys(uv).length > 0) {
    pyproject.tool = { uv };
  }
  return pyproject;
}
function buildIndexEntries(pipOptions) {
  const indexes = [];
  if (pipOptions.indexUrl) {
    indexes.push({
      name: PRIMARY_INDEX_NAME,
      url: pipOptions.indexUrl,
      default: true
    });
  }
  for (let i = 0; i < pipOptions.extraIndexUrls.length; i++) {
    indexes.push({
      name: `${EXTRA_INDEX_PREFIX}${i + 1}`,
      url: pipOptions.extraIndexUrls[i]
    });
  }
  if (pipOptions.findLinks) {
    for (let i = 0; i < pipOptions.findLinks.length; i++) {
      indexes.push({
        name: `${FIND_LINKS_PREFIX}${i + 1}`,
        url: pipOptions.findLinks[i],
        format: "flat"
      });
    }
  }
  return indexes;
}
function parseRequirementsFile(fileContent, readFile3) {
  const visited = /* @__PURE__ */ new Set();
  return parseRequirementsFileInternal(fileContent, readFile3, visited);
}
function parseRequirementsFileInternal(fileContent, readFile3, visited) {
  const { cleanedContent, options, pathRequirements, editableRequirements } = extractPipArguments(fileContent);
  const hashMap = buildHashMap(fileContent);
  const requirements = (0, import_pip_requirements_js.parsePipRequirementsFile)(cleanedContent);
  const normalized = [];
  const mergedOptions = {
    requirementFiles: [...options.requirementFiles],
    constraintFiles: [...options.constraintFiles],
    indexUrl: options.indexUrl,
    extraIndexUrls: [...options.extraIndexUrls],
    findLinks: options.findLinks ? [...options.findLinks] : void 0,
    noIndex: options.noIndex
  };
  for (const req of requirements) {
    if (req.type === "RequirementsFile") {
      mergedOptions.requirementFiles.push(req.path);
      continue;
    }
    if (req.type === "ConstraintsFile") {
      mergedOptions.constraintFiles.push(req.path);
      continue;
    }
    const norm = normalizeRequirement(req);
    if (norm != null) {
      const hashes = hashMap.get(norm.name.toLowerCase());
      if (hashes && hashes.length > 0) {
        norm.hashes = hashes;
      }
      normalized.push(norm);
    }
  }
  for (const rawPath of pathRequirements) {
    const norm = normalizePathRequirement(rawPath);
    if (norm != null) {
      normalized.push(norm);
    }
  }
  for (const rawPath of editableRequirements) {
    const norm = normalizePathRequirement(rawPath);
    if (norm != null) {
      if (norm.source) {
        norm.source.editable = true;
      } else {
        norm.source = { path: rawPath, editable: true };
      }
      normalized.push(norm);
    }
  }
  if (readFile3) {
    for (const refPath of mergedOptions.requirementFiles) {
      const refPathKey = (0, import_path4.normalize)(refPath);
      if (visited.has(refPathKey)) {
        continue;
      }
      visited.add(refPathKey);
      const refContent = readFile3(refPath);
      if (refContent != null) {
        const refParsed = parseRequirementsFileInternal(
          refContent,
          readFile3,
          visited
        );
        const existingNames = new Set(
          normalized.map((r) => r.name.toLowerCase())
        );
        for (const req of refParsed.requirements) {
          if (!existingNames.has(req.name.toLowerCase())) {
            normalized.push(req);
            existingNames.add(req.name.toLowerCase());
          }
        }
        if (refParsed.pipOptions.indexUrl) {
          mergedOptions.indexUrl = refParsed.pipOptions.indexUrl;
        }
        for (const url of refParsed.pipOptions.extraIndexUrls) {
          if (!mergedOptions.extraIndexUrls.includes(url)) {
            mergedOptions.extraIndexUrls.push(url);
          }
        }
        for (const constraintPath of refParsed.pipOptions.constraintFiles) {
          if (!mergedOptions.constraintFiles.includes(constraintPath)) {
            mergedOptions.constraintFiles.push(constraintPath);
          }
        }
        if (refParsed.pipOptions.findLinks) {
          if (!mergedOptions.findLinks)
            mergedOptions.findLinks = [];
          for (const fl of refParsed.pipOptions.findLinks) {
            if (!mergedOptions.findLinks.includes(fl)) {
              mergedOptions.findLinks.push(fl);
            }
          }
        }
        if (refParsed.pipOptions.noIndex) {
          mergedOptions.noIndex = true;
        }
      }
    }
  }
  return {
    requirements: normalized,
    pipOptions: mergedOptions
  };
}
function buildHashMap(fileContent) {
  const hashMap = /* @__PURE__ */ new Map();
  const lines = fileContent.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i].trim();
    if (line === "" || line.startsWith("#") || line.startsWith("-")) {
      continue;
    }
    while (line.endsWith("\\") && i + 1 < lines.length) {
      i++;
      line = line.slice(0, -1) + lines[i].trim();
    }
    const hashes = extractInlineHashes(line);
    if (hashes.length === 0) {
      continue;
    }
    const packageMatch = line.match(/^([a-zA-Z0-9][-a-zA-Z0-9._]*)/);
    if (packageMatch) {
      const packageName = packageMatch[1].toLowerCase();
      hashMap.set(packageName, hashes);
    }
  }
  return hashMap;
}
function normalizeRequirement(req) {
  if (req.type === "RequirementsFile" || req.type === "ConstraintsFile") {
    return null;
  }
  if (req.type === "ProjectURL") {
    return normalizeProjectURLRequirement(req);
  }
  if (req.type === "ProjectName") {
    return normalizeProjectNameRequirement(req);
  }
  return null;
}
function normalizeProjectNameRequirement(req) {
  const normalized = {
    name: req.name
  };
  if (req.extras && req.extras.length > 0) {
    normalized.extras = req.extras;
  }
  if (req.versionSpec && req.versionSpec.length > 0) {
    normalized.version = req.versionSpec.map((spec) => `${spec.operator}${spec.version}`).join(",");
  }
  if (req.environmentMarkerTree) {
    normalized.markers = formatEnvironmentMarkers(req.environmentMarkerTree);
  }
  return normalized;
}
function normalizeProjectURLRequirement(req) {
  const normalized = {
    name: req.name
  };
  if (req.extras && req.extras.length > 0) {
    normalized.extras = req.extras;
  }
  if (req.environmentMarkerTree) {
    normalized.markers = formatEnvironmentMarkers(req.environmentMarkerTree);
  }
  if (isGitUrl(req.url)) {
    const parsed = parseGitUrl(req.url);
    if (parsed) {
      const source = {
        git: parsed.url
      };
      if (parsed.ref) {
        source.rev = parsed.ref;
      }
      if (parsed.editable) {
        source.editable = true;
      }
      normalized.source = source;
    }
  }
  normalized.url = req.url;
  return normalized;
}
function formatEnvironmentMarkers(marker) {
  if (isEnvironmentMarkerNode(marker)) {
    const left = formatEnvironmentMarkers(marker.left);
    const right = formatEnvironmentMarkers(marker.right);
    return `(${left}) ${marker.operator} (${right})`;
  }
  const leaf = marker;
  const leftStr = formatMarkerValue(leaf.left);
  const rightStr = formatMarkerValue(leaf.right);
  return `${leftStr} ${leaf.operator} ${rightStr}`;
}
function isEnvironmentMarkerNode(marker) {
  if (typeof marker !== "object" || marker == null) {
    return false;
  }
  const op = marker.operator;
  return op === "and" || op === "or";
}
function formatMarkerValue(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value;
  }
  return value;
}
var UvConfigWorkspaceSchema = uvConfigWorkspaceSchema.passthrough();
var UvIndexEntrySchema = uvIndexEntrySchema.passthrough();
var UvConfigSchema = uvConfigSchema.passthrough();
var PythonImplementation = {
  knownLongNames() {
    return {
      python: "cpython",
      cpython: "cpython",
      pypy: "pypy",
      pyodide: "pyodide",
      graalpy: "graalpy"
    };
  },
  knownShortNames() {
    return { cp: "cpython", pp: "pypy", gp: "graalpy" };
  },
  knownNames() {
    return { ...this.knownLongNames(), ...this.knownShortNames() };
  },
  parse(s) {
    const impl = this.knownNames()[s];
    if (impl !== void 0) {
      return impl;
    } else {
      return { implementation: s };
    }
  },
  isUnknown(impl) {
    return impl.implementation !== void 0;
  },
  toString(impl) {
    switch (impl) {
      case "cpython":
        return "cpython";
      case "pypy":
        return "pypy";
      case "pyodide":
        return "pyodide";
      case "graalpy":
        return "graalpy";
      default:
        return impl.implementation;
    }
  },
  toStringPretty(impl) {
    switch (impl) {
      case "cpython":
        return "CPython";
      case "pypy":
        return "PyPy";
      case "pyodide":
        return "PyOdide";
      case "graalpy":
        return "GraalPy";
      default:
        return impl.implementation;
    }
  }
};
var PythonVariant = {
  parse(s) {
    switch (s) {
      case "default":
        return "default";
      case "d":
      case "debug":
        return "debug";
      case "freethreaded":
        return "freethreaded";
      case "t":
        return "freethreaded";
      case "gil":
        return "gil";
      case "freethreaded+debug":
        return "freethreaded+debug";
      case "td":
        return "freethreaded+debug";
      case "gil+debug":
        return "gil+debug";
      default:
        return { type: "unknown", variant: s };
    }
  },
  toString(v) {
    switch (v) {
      case "default":
        return "default";
      case "debug":
        return "debug";
      case "freethreaded":
        return "freethreaded";
      case "gil":
        return "gil";
      case "freethreaded+debug":
        return "freethreaded+debug";
      case "gil+debug":
        return "gil+debug";
      default:
        return v.variant;
    }
  }
};
function pythonRequestFromConstraint(constraint) {
  return {
    implementation: "cpython",
    version: {
      constraint,
      variant: "default"
    }
  };
}
function parsePythonVersionFile(content) {
  const lines = content.split(/\r?\n/);
  const requests = [];
  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i] ?? "";
    const trimmed = raw.trim();
    if (!trimmed)
      continue;
    if (trimmed.startsWith("#"))
      continue;
    const parsed = parseUvPythonRequest(trimmed);
    if (parsed != null) {
      requests.push(parsed);
    }
  }
  if (requests.length === 0) {
    return null;
  } else {
    return requests;
  }
}
function parseUvPythonRequest(input) {
  const raw = input.trim();
  if (!raw) {
    return null;
  }
  const lowercase = raw.toLowerCase();
  if (lowercase === "any" || lowercase === "default") {
    return {};
  }
  for (const [implName, implementation] of Object.entries(
    PythonImplementation.knownNames()
  )) {
    if (lowercase.startsWith(implName)) {
      let rest = lowercase.substring(implName.length);
      if (rest.length === 0) {
        return {
          implementation
        };
      }
      if (rest[0] === "@") {
        rest = rest.substring(1);
      }
      const version22 = parseVersionRequest(rest);
      if (version22 != null) {
        return {
          implementation,
          version: version22
        };
      }
    }
  }
  const version2 = parseVersionRequest(lowercase);
  if (version2 != null) {
    return {
      implementation: "cpython",
      version: version2
    };
  }
  return tryParsePlatformRequest(lowercase);
}
function parseVersionRequest(input) {
  const [version2, variant] = parseVariantSuffix(input);
  let parsedVer = (0, import_pep440.parse)(version2);
  if (parsedVer != null) {
    if (parsedVer.release.length === 1) {
      const converted = splitWheelTagVersion(version2);
      if (converted != null) {
        const convertedVer = (0, import_pep440.parse)(converted);
        if (convertedVer != null) {
          parsedVer = convertedVer;
        }
      }
    }
    return {
      constraint: pep440ConstraintFromVersion(parsedVer),
      variant
    };
  }
  const parsedConstr = (0, import_specifier.parse)(version2);
  if (parsedConstr?.length) {
    return {
      constraint: parsedConstr,
      variant
    };
  }
  return null;
}
function splitWheelTagVersion(version2) {
  if (!/^\d+$/.test(version2)) {
    return null;
  }
  if (version2.length < 2) {
    return null;
  }
  const major = version2[0];
  const minorStr = version2.substring(1);
  const minor = parseInt(minorStr, 10);
  if (isNaN(minor) || minor > 255) {
    return null;
  }
  return `${major}.${minor}`;
}
function rfindNumericChar(s) {
  for (let i = s.length - 1; i >= 0; i--) {
    const code = s.charCodeAt(i);
    if (code >= 48 && code <= 57)
      return i;
  }
  return -1;
}
function parseVariantSuffix(vrs) {
  let pos = rfindNumericChar(vrs);
  if (pos < 0) {
    return [vrs, "default"];
  }
  pos += 1;
  if (pos + 1 > vrs.length) {
    return [vrs, "default"];
  }
  let variant = vrs.substring(pos);
  if (variant[0] === "+") {
    variant = variant.substring(1);
  }
  const prefix = vrs.substring(0, pos);
  return [prefix, PythonVariant.parse(variant)];
}
function tryParsePlatformRequest(raw) {
  const parts = raw.split("-");
  let partIdx = 0;
  const state = ["implementation", "version", "os", "arch", "libc", "end"];
  let stateIdx = 0;
  let implementation;
  let version2;
  let os2;
  let arch;
  let libc;
  let implOrVersionFailed = false;
  for (; ; ) {
    if (partIdx >= parts.length || state[stateIdx] === "end") {
      break;
    }
    const part = parts[partIdx].toLowerCase();
    if (part.length === 0) {
      break;
    }
    switch (state[stateIdx]) {
      case "implementation":
        if (part === "any") {
          partIdx += 1;
          stateIdx += 1;
          continue;
        }
        implementation = PythonImplementation.parse(part);
        if (PythonImplementation.isUnknown(implementation)) {
          implementation = void 0;
          stateIdx += 1;
          implOrVersionFailed = true;
          continue;
        }
        stateIdx += 1;
        partIdx += 1;
        break;
      case "version":
        if (part === "any") {
          partIdx += 1;
          stateIdx += 1;
          continue;
        }
        version2 = parseVersionRequest(part);
        if (version2 == null) {
          version2 = void 0;
          stateIdx += 1;
          implOrVersionFailed = true;
          continue;
        }
        stateIdx += 1;
        partIdx += 1;
        break;
      case "os":
        if (part === "any") {
          partIdx += 1;
          stateIdx += 1;
          continue;
        }
        os2 = part;
        stateIdx += 1;
        partIdx += 1;
        break;
      case "arch":
        if (part === "any") {
          partIdx += 1;
          stateIdx += 1;
          continue;
        }
        arch = part;
        stateIdx += 1;
        partIdx += 1;
        break;
      case "libc":
        if (part === "any") {
          partIdx += 1;
          stateIdx += 1;
          continue;
        }
        libc = part;
        stateIdx += 1;
        partIdx += 1;
        break;
      default:
        break;
    }
  }
  if (implOrVersionFailed && implementation === void 0 && version2 === void 0) {
    return null;
  }
  let platform;
  if (os2 !== void 0 || arch !== void 0 || libc !== void 0) {
    platform = {
      os: os2,
      arch,
      libc
    };
  }
  return { implementation, version: version2, platform };
}
var PythonLockFileKind = /* @__PURE__ */ ((PythonLockFileKind2) => {
  PythonLockFileKind2["UvLock"] = "uv.lock";
  PythonLockFileKind2["PylockToml"] = "pylock.toml";
  return PythonLockFileKind2;
})(PythonLockFileKind || {});
var PythonManifestConvertedKind = /* @__PURE__ */ ((PythonManifestConvertedKind2) => {
  PythonManifestConvertedKind2["Pipfile"] = "Pipfile";
  PythonManifestConvertedKind2["PipfileLock"] = "Pipfile.lock";
  PythonManifestConvertedKind2["RequirementsIn"] = "requirements.in";
  PythonManifestConvertedKind2["RequirementsTxt"] = "requirements.txt";
  return PythonManifestConvertedKind2;
})(PythonManifestConvertedKind || {});
async function discoverPythonPackage({
  entrypointDir,
  rootDir
}) {
  const entrypointPath = normalizePath(entrypointDir);
  const rootPath = normalizePath(rootDir);
  let prefix = import_path.default.relative(rootPath, entrypointPath);
  if (prefix.startsWith("..")) {
    throw new PythonAnalysisError({
      message: "Entrypoint directory outside of repository root",
      code: "PYTHON_INVALID_ENTRYPOINT_PATH"
    });
  }
  const manifests = [];
  let configs = [];
  for (; ; ) {
    const prefixConfigs = await loadPythonConfigs(rootPath, prefix);
    if (Object.keys(prefixConfigs).length !== 0) {
      configs.push(prefixConfigs);
    }
    const prefixManifest = await loadPythonManifest(rootPath, prefix);
    if (prefixManifest != null) {
      manifests.push(prefixManifest);
      if (prefixManifest.isRoot) {
        break;
      }
    }
    if (prefix === "" || prefix === ".") {
      break;
    }
    prefix = import_path.default.dirname(prefix);
  }
  let entrypointManifest;
  let workspaceManifest;
  let workspaceLockFile;
  if (manifests.length === 0) {
    return {
      configs
    };
  } else {
    entrypointManifest = manifests[0];
    const entrypointWorkspaceManifest = findWorkspaceManifestFor(
      entrypointManifest,
      manifests
    );
    workspaceManifest = entrypointWorkspaceManifest;
    workspaceLockFile = entrypointWorkspaceManifest.lockFile;
    configs = configs.filter(
      (config) => Object.values(config).some(
        (cfg) => cfg !== void 0 && isSubpath(
          import_path.default.dirname(cfg.path),
          import_path.default.dirname(entrypointWorkspaceManifest.path)
        )
      )
    );
  }
  const requiresPython = computeRequiresPython(
    entrypointManifest,
    workspaceManifest,
    configs
  );
  return {
    manifest: entrypointManifest,
    workspaceManifest,
    workspaceLockFile,
    configs,
    requiresPython
  };
}
function computeRequiresPython(manifest, workspaceManifest, configs) {
  const constraints = [];
  for (const configSet of configs) {
    const pythonVersionConfig = configSet[
      ".python-version"
      /* PythonVersion */
    ];
    if (pythonVersionConfig !== void 0) {
      constraints.push({
        request: pythonVersionConfig.data,
        source: `${pythonVersionConfig.path}`
      });
      break;
    }
  }
  const manifestRequiresPython = manifest?.data.project?.["requires-python"];
  if (manifestRequiresPython) {
    const parsed = (0, import_specifier.parse)(manifestRequiresPython);
    if (parsed?.length) {
      const request = pythonRequestFromConstraint(parsed);
      constraints.push({
        request: [request],
        source: `"requires-python" key in ${manifest.path}`
      });
    }
  } else {
    const workspaceRequiresPython = workspaceManifest?.data.project?.["requires-python"];
    if (workspaceRequiresPython) {
      const parsed = (0, import_specifier.parse)(workspaceRequiresPython);
      if (parsed?.length) {
        const request = pythonRequestFromConstraint(parsed);
        constraints.push({
          request: [request],
          source: `"requires-python" key in ${workspaceManifest.path}`
        });
      }
    }
  }
  return constraints;
}
function findWorkspaceManifestFor(manifest, manifestStack) {
  if (manifest.isRoot) {
    return manifest;
  }
  for (const parentManifest of manifestStack) {
    if (parentManifest.path === manifest.path) {
      continue;
    }
    const workspace = parentManifest.data.tool?.uv?.workspace;
    if (workspace !== void 0) {
      let members = workspace.members ?? [];
      if (!Array.isArray(members)) {
        members = [];
      }
      let exclude = workspace.exclude ?? [];
      if (!Array.isArray(exclude)) {
        exclude = [];
      }
      const entrypointRelPath = import_path.default.relative(
        import_path.default.dirname(parentManifest.path),
        import_path.default.dirname(manifest.path)
      );
      if (members.length > 0 && members.some(
        (pat) => match([entrypointRelPath], pat).length > 0
      ) && !exclude.some(
        (pat) => match([entrypointRelPath], pat).length > 0
      )) {
        return parentManifest;
      }
    }
  }
  return manifest;
}
async function loadPythonManifest(root, prefix) {
  let manifest = null;
  const pyproject = await maybeLoadPyProjectToml(root, prefix);
  if (pyproject != null) {
    manifest = pyproject;
    manifest.isRoot = pyproject.data.tool?.uv?.workspace !== void 0;
  } else {
    const pipfileLockPyProject = await maybeLoadPipfileLock(root, prefix);
    if (pipfileLockPyProject != null) {
      manifest = pipfileLockPyProject;
      manifest.isRoot = true;
    } else {
      const pipfilePyProject = await maybeLoadPipfile(root, prefix);
      if (pipfilePyProject != null) {
        manifest = pipfilePyProject;
        manifest.isRoot = true;
      } else {
        for (const fileName of [
          "requirements.frozen.txt",
          "requirements-frozen.txt",
          "requirements.txt",
          "requirements.in",
          import_path.default.join("requirements", "prod.txt")
        ]) {
          const requirementsTxtManifest = await maybeLoadRequirementsTxt(
            root,
            prefix,
            fileName
          );
          if (requirementsTxtManifest != null) {
            manifest = requirementsTxtManifest;
            manifest.isRoot = true;
            break;
          }
        }
      }
    }
  }
  return manifest;
}
async function maybeLoadLockFile(root, subdir) {
  const uvLockRelPath = import_path.default.join(subdir, "uv.lock");
  const uvLockPath = import_path.default.join(root, uvLockRelPath);
  const uvLockContent = await readFileTextIfExists(uvLockPath);
  if (uvLockContent != null) {
    return {
      path: uvLockRelPath,
      kind: "uv.lock"
      /* UvLock */
    };
  }
  const pylockRelPath = import_path.default.join(subdir, "pylock.toml");
  const pylockPath = import_path.default.join(root, pylockRelPath);
  const pylockContent = await readFileTextIfExists(pylockPath);
  if (pylockContent != null) {
    return {
      path: pylockRelPath,
      kind: "pylock.toml"
      /* PylockToml */
    };
  }
  return void 0;
}
async function maybeLoadPyProjectToml(root, subdir) {
  const pyprojectTomlRelPath = import_path.default.join(subdir, "pyproject.toml");
  const pyprojectTomlPath = import_path.default.join(root, pyprojectTomlRelPath);
  let pyproject;
  try {
    pyproject = await readConfigIfExists(
      pyprojectTomlPath,
      PyProjectTomlSchema
    );
  } catch (error) {
    if (error instanceof PythonAnalysisError) {
      error.path = pyprojectTomlRelPath;
      throw error;
    }
    throw new PythonAnalysisError({
      message: `could not parse pyproject.toml: ${error instanceof Error ? error.message : String(error)}`,
      code: "PYTHON_PYPROJECT_PARSE_ERROR",
      path: pyprojectTomlRelPath
    });
  }
  if (pyproject == null) {
    return null;
  }
  const uvTomlRelPath = import_path.default.join(subdir, "uv.toml");
  const uvTomlPath = import_path.default.join(root, uvTomlRelPath);
  let uvToml;
  try {
    uvToml = await readConfigIfExists(uvTomlPath, UvConfigSchema);
  } catch (error) {
    if (error instanceof PythonAnalysisError) {
      error.path = uvTomlRelPath;
      throw error;
    }
    throw new PythonAnalysisError({
      message: `could not parse uv.toml: ${error instanceof Error ? error.message : String(error)}`,
      code: "PYTHON_UV_CONFIG_PARSE_ERROR",
      path: uvTomlRelPath
    });
  }
  if (uvToml != null) {
    if (pyproject.tool == null) {
      pyproject.tool = { uv: uvToml };
    } else {
      pyproject.tool.uv = uvToml;
    }
  }
  const lockFile = await maybeLoadLockFile(root, subdir);
  return {
    path: pyprojectTomlRelPath,
    data: pyproject,
    lockFile
  };
}
async function maybeLoadPipfile(root, subdir) {
  const pipfileRelPath = import_path.default.join(subdir, "Pipfile");
  const pipfilePath = import_path.default.join(root, pipfileRelPath);
  let pipfile;
  try {
    pipfile = await readConfigIfExists(pipfilePath, PipfileLikeSchema, ".toml");
  } catch (error) {
    if (error instanceof PythonAnalysisError) {
      error.path = pipfileRelPath;
      throw error;
    }
    throw new PythonAnalysisError({
      message: `could not parse Pipfile: ${error instanceof Error ? error.message : String(error)}`,
      code: "PYTHON_PIPFILE_PARSE_ERROR",
      path: pipfileRelPath
    });
  }
  if (pipfile == null) {
    return null;
  }
  const pyproject = convertPipfileToPyprojectToml(pipfile);
  return {
    path: pipfileRelPath,
    data: pyproject,
    origin: {
      kind: "Pipfile",
      path: pipfileRelPath
    }
  };
}
async function maybeLoadPipfileLock(root, subdir) {
  const pipfileLockRelPath = import_path.default.join(subdir, "Pipfile.lock");
  const pipfileLockPath = import_path.default.join(root, pipfileLockRelPath);
  let pipfileLock;
  try {
    pipfileLock = await readConfigIfExists(
      pipfileLockPath,
      PipfileLockLikeSchema,
      ".json"
    );
  } catch (error) {
    if (error instanceof PythonAnalysisError) {
      error.path = pipfileLockRelPath;
      throw error;
    }
    throw new PythonAnalysisError({
      message: `could not parse Pipfile.lock: ${error instanceof Error ? error.message : String(error)}`,
      code: "PYTHON_PIPFILE_LOCK_PARSE_ERROR",
      path: pipfileLockRelPath
    });
  }
  if (pipfileLock == null) {
    return null;
  }
  const pyproject = convertPipfileLockToPyprojectToml(pipfileLock);
  return {
    path: pipfileLockRelPath,
    data: pyproject,
    origin: {
      kind: "Pipfile.lock",
      path: pipfileLockRelPath
    }
  };
}
async function maybeLoadRequirementsTxt(root, subdir, fileName) {
  const requirementsTxtRelPath = import_path.default.join(subdir, fileName);
  const requirementsTxtPath = import_path.default.join(root, requirementsTxtRelPath);
  const requirementsContent = await readFileTextIfExists(requirementsTxtPath);
  if (requirementsContent == null) {
    return null;
  }
  try {
    const pyproject = convertRequirementsToPyprojectToml(requirementsContent);
    return {
      path: requirementsTxtRelPath,
      data: pyproject,
      origin: {
        kind: "requirements.txt",
        path: requirementsTxtRelPath
      }
    };
  } catch (error) {
    if (error instanceof PythonAnalysisError) {
      error.path = requirementsTxtRelPath;
      if (!error.fileContent) {
        error.fileContent = requirementsContent;
      }
      throw error;
    }
    throw new PythonAnalysisError({
      message: `could not parse ${fileName}: ${error instanceof Error ? error.message : String(error)}`,
      code: "PYTHON_REQUIREMENTS_PARSE_ERROR",
      path: requirementsTxtRelPath,
      fileContent: requirementsContent
    });
  }
}
async function loadPythonConfigs(root, prefix) {
  const configs = {};
  const pythonRequest = await maybeLoadPythonRequest(root, prefix);
  if (pythonRequest != null) {
    configs[
      ".python-version"
      /* PythonVersion */
    ] = pythonRequest;
  }
  return configs;
}
async function maybeLoadPythonRequest(root, subdir) {
  const dotPythonVersionRelPath = import_path.default.join(subdir, ".python-version");
  const dotPythonVersionPath = import_path.default.join(
    root,
    dotPythonVersionRelPath
  );
  const data = await readFileTextIfExists(dotPythonVersionPath);
  if (data == null) {
    return null;
  }
  const pyreq = parsePythonVersionFile(data);
  if (pyreq == null) {
    throw new PythonAnalysisError({
      message: `could not parse .python-version file: no valid Python version requests found`,
      code: "PYTHON_VERSION_FILE_PARSE_ERROR",
      path: dotPythonVersionRelPath
    });
  }
  return {
    kind: ".python-version",
    path: dotPythonVersionRelPath,
    data: pyreq
  };
}
function stringifyManifest(data) {
  return dist_default.stringify(data);
}
function createMinimalManifest(options = {}) {
  const {
    name = "app",
    version: version2 = "0.1.0",
    requiresPython,
    dependencies = []
  } = options;
  return {
    project: {
      name,
      version: version2,
      ...requiresPython && { "requires-python": requiresPython },
      dependencies,
      classifiers: ["Private :: Do Not Upload"]
    }
  };
}
function parseUvLock(content, path42) {
  let parsed;
  try {
    parsed = dist_default.parse(content);
  } catch (error) {
    throw new PythonAnalysisError({
      message: `Could not parse uv.lock: ${error instanceof Error ? error.message : String(error)}`,
      code: "PYTHON_UV_LOCK_PARSE_ERROR",
      path: path42,
      fileContent: content
    });
  }
  const packages = (parsed.package ?? []).filter((pkg) => pkg.name && pkg.version).map((pkg) => ({
    name: pkg.name,
    version: pkg.version,
    source: pkg.source
  }));
  return { version: parsed.version, packages };
}
var PUBLIC_PYPI_PATTERNS = [
  "https://pypi.org",
  "https://files.pythonhosted.org",
  "pypi.org"
];
function isPublicPyPIRegistry(registryUrl) {
  if (!registryUrl)
    return true;
  const normalized = registryUrl.toLowerCase();
  return PUBLIC_PYPI_PATTERNS.some((pattern) => normalized.includes(pattern));
}
function isPrivatePackageSource(source) {
  if (!source)
    return false;
  if (source.git)
    return true;
  if (source.path)
    return true;
  if (source.editable)
    return true;
  if (source.url)
    return true;
  if (source.virtual)
    return true;
  if (source.registry && !isPublicPyPIRegistry(source.registry)) {
    return true;
  }
  return false;
}
function normalizePackageName(name) {
  return name.toLowerCase().replace(/[-_.]+/g, "-");
}
function classifyPackages(options) {
  const { lockFile, excludePackages = [] } = options;
  const privatePackages = [];
  const publicPackages = [];
  const packageVersions = {};
  const excludeSet = new Set(excludePackages.map(normalizePackageName));
  for (const pkg of lockFile.packages) {
    if (excludeSet.has(normalizePackageName(pkg.name))) {
      continue;
    }
    packageVersions[pkg.name] = pkg.version;
    if (isPrivatePackageSource(pkg.source)) {
      privatePackages.push(pkg.name);
    } else {
      publicPackages.push(pkg.name);
    }
  }
  return { privatePackages, publicPackages, packageVersions };
}
function generateRuntimeRequirements(classification) {
  const lines = [
    "# Auto-generated requirements for runtime installation",
    "# Private packages are bundled separately and not listed here.",
    ""
  ];
  for (const pkgName of classification.publicPackages) {
    const version2 = classification.packageVersions[pkgName];
    if (version2) {
      lines.push(`${pkgName}==${version2}`);
    } else {
      lines.push(pkgName);
    }
  }
  return lines.join("\n");
}
var DependencySourceSchema = dependencySourceSchema.passthrough();

// src/utils.ts
var import_fs2 = __toESM(require("fs"));
var import_path7 = require("path");
var import_build_utils2 = require("@vercel/build-utils");
var import_execa2 = __toESM(require_execa());

// src/uv.ts
var import_child_process = require("child_process");
var import_path5 = require("path");
var import_path6 = require("path");
var import_execa = __toESM(require_execa());
var import_fs = __toESM(require("fs"));
var import_os = __toESM(require("os"));
var import_which = __toESM(require_lib2());
var import_build_utils = require("@vercel/build-utils");
var UV_VERSION = "0.9.22";
var UV_PYTHON_PATH_PREFIX = "/uv/python/";
var UV_PYTHON_DOWNLOADS_MODE = "automatic";
var isWin = process.platform === "win32";
var uvExec = isWin ? "uv.exe" : "uv";
function findUvInPath() {
  return import_which.default.sync("uv", { nothrow: true });
}
var UvRunner = class {
  constructor(uvPath) {
    this.uvPath = uvPath;
  }
  getPath() {
    return this.uvPath;
  }
  /**
   * List installed Python versions managed by uv.
   * Excludes system Python.
   */
  listInstalledPythons() {
    let output;
    try {
      output = (0, import_child_process.execSync)(
        `${this.uvPath} python list --only-installed --output-format json`,
        { encoding: "utf8", stdio: ["pipe", "pipe", "pipe"] }
      );
    } catch (err) {
      throw new Error(
        `Failed to run 'uv python list': ${err instanceof Error ? err.message : String(err)}`
      );
    }
    if (!output || output.trim() === "" || output.trim() === "[]") {
      return /* @__PURE__ */ new Set();
    }
    let pyList;
    try {
      pyList = JSON.parse(output);
    } catch (err) {
      throw new Error(
        `Failed to parse 'uv python list' output: ${err instanceof Error ? err.message : String(err)}`
      );
    }
    if (process.env.VERCEL_BUILD_IMAGE) {
      pyList = pyList.filter(
        (entry) => entry.path !== null && entry.path.startsWith(UV_PYTHON_PATH_PREFIX) && entry.implementation === "cpython"
      );
    } else {
      pyList = pyList.filter(
        (entry) => entry.path !== null && entry.implementation === "cpython"
      );
    }
    return new Set(
      pyList.map(
        (entry) => `${entry.version_parts.major}.${entry.version_parts.minor}`
      )
    );
  }
  async sync(options) {
    const { venvPath, projectDir, locked, frozen, noBuild } = options;
    const args = ["sync", "--active", "--no-dev", "--link-mode", "copy"];
    if (frozen) {
      args.push("--frozen");
    } else if (locked) {
      args.push("--locked");
    }
    if (noBuild) {
      args.push("--no-build");
    }
    args.push("--no-editable");
    await this.runUvCmd(args, projectDir, venvPath);
  }
  async lock(projectDir, options) {
    const args = ["lock"];
    if (options?.noBuild) {
      args.push("--no-build");
    }
    if (options?.upgrade) {
      args.push("--upgrade");
    }
    const pretty = `uv ${args.join(" ")}`;
    (0, import_build_utils.debug)(`Running "${pretty}" in ${projectDir}...`);
    try {
      await (0, import_execa.default)(this.uvPath, args, {
        cwd: projectDir,
        env: getProtectedUvEnv(process.env)
      });
    } catch (err) {
      const error = new Error(
        `Failed to run "${pretty}": ${err instanceof Error ? err.message : String(err)}`
      );
      if (err && typeof err === "object") {
        if ("code" in err) {
          error.code = err.code;
        } else if ("signal" in err) {
          error.code = err.signal;
        }
      }
      throw error;
    }
  }
  async addDependencies(options) {
    const { venvPath, projectDir, dependencies } = options;
    const toAdd = dependencies.filter(Boolean);
    if (!toAdd.length)
      return;
    const args = ["add", "--active", ...toAdd];
    (0, import_build_utils.debug)(`Running "uv ${args.join(" ")}" in ${projectDir}...`);
    await this.runUvCmd(args, projectDir, venvPath);
  }
  async addFromFile(options) {
    const { venvPath, projectDir, requirementsPath } = options;
    const args = ["add", "--active", "-r", requirementsPath];
    (0, import_build_utils.debug)(`Running "uv ${args.join(" ")}" in ${projectDir}...`);
    await this.runUvCmd(args, projectDir, venvPath);
  }
  /**
   * Run a `uv pip` command (e.g., `uv pip install`).
   */
  async pip(options) {
    const { venvPath, projectDir, args } = options;
    const fullArgs = ["pip", ...args];
    await this.runUvCmd(fullArgs, projectDir, venvPath);
  }
  async runUvCmd(args, cwd, venvPath) {
    const pretty = `uv ${args.join(" ")}`;
    (0, import_build_utils.debug)(`Running "${pretty}"...`);
    try {
      await (0, import_execa.default)(this.uvPath, args, {
        cwd,
        env: this.getVenvEnv(venvPath)
      });
    } catch (err) {
      const error = new Error(
        `Failed to run "${pretty}": ${err instanceof Error ? err.message : String(err)}`
      );
      if (err && typeof err === "object") {
        if ("code" in err) {
          error.code = err.code;
        } else if ("signal" in err) {
          error.code = err.signal;
        }
      }
      throw error;
    }
  }
  getVenvEnv(venvPath) {
    const binDir = isWin ? (0, import_path5.join)(venvPath, "Scripts") : (0, import_path5.join)(venvPath, "bin");
    const existingPath = process.env.PATH || "";
    return {
      ...getProtectedUvEnv(process.env),
      VIRTUAL_ENV: venvPath,
      PATH: existingPath ? `${binDir}${import_path6.delimiter}${existingPath}` : binDir
    };
  }
};
async function getGlobalScriptsDir(pythonPath) {
  const code = `import sysconfig; print(sysconfig.get_path('scripts'))`;
  try {
    const { stdout } = await (0, import_execa.default)(pythonPath, ["-c", code]);
    const out = stdout.trim();
    return out || null;
  } catch (err) {
    (0, import_build_utils.debug)("Failed to resolve Python global scripts directory", err);
    return null;
  }
}
async function getUserScriptsDir(pythonPath) {
  const code = `import sys, sysconfig; print(sysconfig.get_path('scripts', scheme=('nt_user' if sys.platform == 'win32' else 'posix_user')))`.replace(
    /\n/g,
    " "
  );
  try {
    const { stdout } = await (0, import_execa.default)(pythonPath, ["-c", code]);
    const out = stdout.trim();
    return out || null;
  } catch (err) {
    (0, import_build_utils.debug)("Failed to resolve Python user scripts directory", err);
    return null;
  }
}
async function findUvBinary(pythonPath) {
  const found = import_which.default.sync("uv", { nothrow: true });
  if (found)
    return found;
  try {
    const globalScriptsDir = await getGlobalScriptsDir(pythonPath);
    if (globalScriptsDir) {
      const uvPath = (0, import_path5.join)(globalScriptsDir, uvExec);
      if (import_fs.default.existsSync(uvPath))
        return uvPath;
    }
  } catch (err) {
    (0, import_build_utils.debug)("Failed to resolve Python global scripts directory", err);
  }
  try {
    const userScriptsDir = await getUserScriptsDir(pythonPath);
    if (userScriptsDir) {
      const uvPath = (0, import_path5.join)(userScriptsDir, uvExec);
      if (import_fs.default.existsSync(uvPath))
        return uvPath;
    }
  } catch (err) {
    (0, import_build_utils.debug)("Failed to resolve Python user scripts directory", err);
  }
  try {
    const candidates = [];
    if (!isWin) {
      candidates.push((0, import_path5.join)(import_os.default.homedir(), ".local", "bin", "uv"));
      candidates.push("/usr/local/bin/uv");
      candidates.push("/opt/homebrew/bin/uv");
    } else {
      candidates.push("C:\\Users\\Public\\uv\\uv.exe");
    }
    for (const p of candidates) {
      if (import_fs.default.existsSync(p))
        return p;
    }
  } catch (err) {
    (0, import_build_utils.debug)("Failed to resolve uv fallback paths", err);
  }
  return null;
}
async function getUvBinaryOrInstall(pythonPath) {
  const uvBin = await findUvBinary(pythonPath);
  if (uvBin)
    return uvBin;
  try {
    console.log("Installing uv...");
    await (0, import_execa.default)(
      pythonPath,
      [
        "-m",
        "pip",
        "install",
        "--disable-pip-version-check",
        "--no-cache-dir",
        "--user",
        `uv==${UV_VERSION}`
      ],
      { env: { ...process.env, PIP_USER: "1" } }
    );
  } catch (err) {
    throw new Error(
      `Failed to install uv via pip: ${err instanceof Error ? err.message : String(err)}`
    );
  }
  const resolvedUvBin = await findUvBinary(pythonPath);
  if (!resolvedUvBin) {
    throw new Error("Unable to resolve uv binary after pip install");
  }
  console.log(`Installed uv at "${resolvedUvBin}"`);
  return resolvedUvBin;
}
function filterUnsafeUvPipArgs(args) {
  return args.filter((arg) => arg !== "--no-warn-script-location");
}
function getProtectedUvEnv(baseEnv = process.env) {
  return {
    ...baseEnv,
    UV_PYTHON_DOWNLOADS: UV_PYTHON_DOWNLOADS_MODE
  };
}
var UV_BUNDLE_DIR = "_uv";
async function getUvBinaryForBundling(pythonPath) {
  const uvPath = await findUvBinary(pythonPath);
  if (!uvPath) {
    throw new Error(
      "Cannot find uv binary for bundling. Ensure uv is installed and available in PATH."
    );
  }
  const resolvedPath = await import_fs.default.promises.realpath(uvPath);
  return resolvedPath;
}

// src/utils.ts
var isWin2 = process.platform === "win32";
var isInVirtualEnv = () => {
  return process.env.VIRTUAL_ENV;
};
function getVenvBinDir(venvPath) {
  return (0, import_path7.join)(venvPath, isWin2 ? "Scripts" : "bin");
}
function useVirtualEnv(workPath, env, systemPython) {
  const venvDirs = [".venv", "venv"];
  let pythonCmd = systemPython;
  for (const venv of venvDirs) {
    const venvRoot = (0, import_path7.join)(workPath, venv);
    const binDir = process.platform === "win32" ? (0, import_path7.join)(venvRoot, "Scripts") : (0, import_path7.join)(venvRoot, "bin");
    const candidates = process.platform === "win32" ? [(0, import_path7.join)(binDir, "python.exe"), (0, import_path7.join)(binDir, "python")] : [(0, import_path7.join)(binDir, "python3"), (0, import_path7.join)(binDir, "python")];
    const found = candidates.find((p) => import_fs2.default.existsSync(p));
    if (found) {
      pythonCmd = found;
      env.VIRTUAL_ENV = venvRoot;
      env.PATH = `${binDir}${import_path7.delimiter}${env.PATH || ""}`;
      return { pythonCmd, venvRoot };
    }
  }
  return { pythonCmd };
}
function createVenvEnv(venvPath, baseEnv = process.env) {
  const env = {
    ...getProtectedUvEnv(baseEnv),
    VIRTUAL_ENV: venvPath
  };
  const binDir = getVenvBinDir(venvPath);
  const existingPath = env.PATH || process.env.PATH || "";
  env.PATH = existingPath ? `${binDir}${import_path7.delimiter}${existingPath}` : binDir;
  return env;
}
async function ensureVenv({
  pythonPath,
  venvPath,
  uvPath,
  quiet
}) {
  const marker = (0, import_path7.join)(venvPath, "pyvenv.cfg");
  try {
    await import_fs2.default.promises.access(marker);
    return;
  } catch {
  }
  await import_fs2.default.promises.mkdir(venvPath, { recursive: true });
  if (!quiet) {
    console.log(`Creating virtual environment at "${venvPath}"...`);
  }
  if (uvPath) {
    await (0, import_execa2.default)(uvPath, ["venv", venvPath]);
  } else {
    await (0, import_execa2.default)(pythonPath, ["-m", "venv", venvPath]);
  }
}
function getVenvPythonBin(venvPath) {
  return (0, import_path7.join)(getVenvBinDir(venvPath), isWin2 ? "python.exe" : "python");
}
async function runPyprojectScript(workPath, scriptNames, env, useUserVirtualEnv = true) {
  const pyprojectPath = (0, import_path7.join)(workPath, "pyproject.toml");
  if (!import_fs2.default.existsSync(pyprojectPath))
    return false;
  let pyproject = null;
  try {
    pyproject = await (0, import_build_utils2.readConfigFile)(pyprojectPath);
  } catch {
    console.error("Failed to parse pyproject.toml");
    return false;
  }
  const scripts = pyproject?.tool?.vercel?.scripts || {};
  const candidates = typeof scriptNames === "string" ? [scriptNames] : Array.from(scriptNames);
  const scriptToRun = candidates.find((name) => Boolean(scripts[name]));
  if (!scriptToRun)
    return false;
  const systemPython = process.platform === "win32" ? "python" : "python3";
  const finalEnv = { ...process.env, ...env };
  if (useUserVirtualEnv) {
    useVirtualEnv(workPath, finalEnv, systemPython);
  }
  const scriptCommand = scripts[scriptToRun];
  if (typeof scriptCommand === "string" && scriptCommand.trim()) {
    console.log(`Executing: ${scriptCommand}`);
    await (0, import_build_utils2.execCommand)(scriptCommand, {
      cwd: workPath,
      env: finalEnv
    });
    return true;
  }
  return false;
}
function findDir({
  file,
  entryDirectory,
  workPath,
  fsFiles
}) {
  if (fsFiles[(0, import_path7.join)(entryDirectory, file)]) {
    return (0, import_path7.join)(workPath, entryDirectory);
  }
  if (fsFiles[file]) {
    return workPath;
  }
  return null;
}

// src/version.ts
var import_build_utils3 = require("@vercel/build-utils");
var DEFAULT_PYTHON_VERSION = "3.12";
var allOptions = [
  {
    version: "3.14",
    pipPath: "pip3.14",
    pythonPath: "python3.14",
    runtime: "python3.14"
  },
  {
    version: "3.13",
    pipPath: "pip3.13",
    pythonPath: "python3.13",
    runtime: "python3.13"
  },
  {
    version: "3.12",
    pipPath: "pip3.12",
    pythonPath: "python3.12",
    runtime: "python3.12"
  },
  {
    version: "3.11",
    pipPath: "pip3.11",
    pythonPath: "python3.11",
    runtime: "python3.11"
  },
  {
    version: "3.10",
    pipPath: "pip3.10",
    pythonPath: "python3.10",
    runtime: "python3.10"
  },
  {
    version: "3.9",
    pipPath: "pip3.9",
    pythonPath: "python3.9",
    runtime: "python3.9"
  },
  {
    version: "3.6",
    pipPath: "pip3.6",
    pythonPath: "python3.6",
    runtime: "python3.6",
    discontinueDate: /* @__PURE__ */ new Date("2022-07-18")
  }
];
function getDevPythonVersion() {
  return {
    version: "3",
    pipPath: "pip3",
    pythonPath: "python3",
    runtime: "python3"
  };
}
function getDefaultPythonVersion({
  isDev
}) {
  if (isDev) {
    return getDevPythonVersion();
  }
  const defaultOption = allOptions.find(
    (opt) => opt.version === DEFAULT_PYTHON_VERSION && isInstalled(opt)
  );
  if (defaultOption) {
    return defaultOption;
  }
  const selection = allOptions.find(isInstalled);
  if (!selection) {
    throw new import_build_utils3.NowBuildError({
      code: "PYTHON_NOT_FOUND",
      link: "https://vercel.link/python-version",
      message: `Unable to find any supported Python versions.`
    });
  }
  return selection;
}
function parseVersionTuple(input) {
  const cleaned = input.trim().replace(/\s+/g, "");
  const m = cleaned.match(/^(\d+)(?:\.(\d+))?/);
  if (!m)
    return null;
  const major = Number(m[1]);
  const minor = m[2] !== void 0 ? Number(m[2]) : 0;
  if (Number.isNaN(major) || Number.isNaN(minor))
    return null;
  return [major, minor];
}
function compareTuples(a, b) {
  if (a[0] !== b[0])
    return a[0] - b[0];
  return a[1] - b[1];
}
function parseSpecifier(spec) {
  const s = spec.trim();
  const m = s.match(
    /^(<=|>=|==|!=|~=|<|>)\s*([0-9]+(?:\.[0-9]+)?)(?:\.[0-9]+)?(?:\.\*)?$/
  ) || // Bare version like "3.11" or "3.11.4" -> implied ==
  s.match(/^()([0-9]+(?:\.[0-9]+)?)(?:\.[0-9]+)?(?:\.\*)?$/);
  if (!m)
    return null;
  const op = m[1] || "==";
  const vt = parseVersionTuple(m[2]);
  if (!vt)
    return null;
  return { op, ver: vt };
}
function satisfies2(candidate, spec) {
  const cmp = compareTuples(candidate, spec.ver);
  switch (spec.op) {
    case "==":
      return cmp === 0;
    case "!=":
      return cmp !== 0;
    case "<":
      return cmp < 0;
    case "<=":
      return cmp <= 0;
    case ">":
      return cmp > 0;
    case ">=":
      return cmp >= 0;
    case "~=": {
      const lowerOk = cmp >= 0;
      const upper = [spec.ver[0], spec.ver[1] + 1];
      return lowerOk && compareTuples(candidate, upper) < 0;
    }
    default:
      return false;
  }
}
function selectFromRequiresPython(expr) {
  const raw = expr.trim();
  if (!raw)
    return void 0;
  const parts = raw.split(",").map((p) => p.trim()).filter(Boolean);
  const specifiers = [];
  for (const p of parts) {
    const sp = parseSpecifier(p);
    if (sp)
      specifiers.push(sp);
  }
  if (specifiers.length === 0) {
    return allOptions.find((o) => o.version === raw);
  }
  const matches = allOptions.filter((opt) => {
    const vt = parseVersionTuple(opt.version);
    return specifiers.every((sp) => satisfies2(vt, sp));
  });
  if (matches.length === 0)
    return void 0;
  const defaultMatch = matches.find(
    (opt) => opt.version === DEFAULT_PYTHON_VERSION && isInstalled(opt)
  );
  if (defaultMatch) {
    return defaultMatch;
  }
  const installedMatch = matches.find(isInstalled);
  return installedMatch ?? matches[0];
}
function getSupportedPythonVersion({
  isDev,
  declaredPythonVersion
}) {
  if (isDev) {
    return getDevPythonVersion();
  }
  let selection = getDefaultPythonVersion({ isDev: false });
  if (declaredPythonVersion) {
    const { version: version2, source } = declaredPythonVersion;
    let requested;
    if (source === "pyproject.toml" || source === ".python-version") {
      requested = selectFromRequiresPython(version2);
    } else {
      requested = allOptions.find((o) => o.version === version2);
    }
    if (requested) {
      if (isDiscontinued(requested)) {
        throw new import_build_utils3.NowBuildError({
          code: "BUILD_UTILS_PYTHON_VERSION_DISCONTINUED",
          link: "https://vercel.link/python-version",
          message: `Python version "${requested.version}" detected in ${source} is discontinued and must be upgraded.`
        });
      }
      if (isInstalled(requested)) {
        selection = requested;
        console.log(`Using Python ${selection.version} from ${source}`);
      } else {
        console.warn(
          `Warning: Python version "${version2}" detected in ${source} is not installed and will be ignored. https://vercel.link/python-version`
        );
        console.log(`Using python version: ${selection.version}`);
      }
    } else {
      console.warn(
        `Warning: Python version "${version2}" detected in ${source} is invalid and will be ignored. https://vercel.link/python-version`
      );
      console.log(`Using python version: ${selection.version}`);
    }
  } else {
    console.log(
      `No Python version specified in .python-version, pyproject.toml, or Pipfile.lock. Using python version: ${selection.version}`
    );
  }
  if (isDiscontinued(selection)) {
    throw new import_build_utils3.NowBuildError({
      code: "BUILD_UTILS_PYTHON_VERSION_DISCONTINUED",
      link: "https://vercel.link/python-version",
      message: `Python version "${selection.version}" declared in project configuration is discontinued and must be upgraded.`
    });
  }
  if (selection.discontinueDate) {
    const d = selection.discontinueDate.toISOString().split("T")[0];
    const srcSuffix = declaredPythonVersion ? `detected in ${declaredPythonVersion.source}` : "selected by runtime";
    console.warn(
      `Error: Python version "${selection.version}" ${srcSuffix} has reached End-of-Life. Deployments created on or after ${d} will fail to build. https://vercel.link/python-version`
    );
  }
  return selection;
}
function isDiscontinued({ discontinueDate }) {
  const today = Date.now();
  return discontinueDate !== void 0 && discontinueDate.getTime() <= today;
}
var installedPythonsCache = null;
function getInstalledPythons() {
  if (installedPythonsCache !== null) {
    return installedPythonsCache;
  }
  const uvPath = findUvInPath();
  if (!uvPath) {
    throw new import_build_utils3.NowBuildError({
      code: "UV_ERROR",
      link: "https://vercel.link/python-version",
      message: "uv is required but was not found in PATH."
    });
  }
  const uv = new UvRunner(uvPath);
  installedPythonsCache = uv.listInstalledPythons();
  return installedPythonsCache;
}
function isInstalled({ version: version2 }) {
  try {
    const installed = getInstalledPythons();
    return installed.has(version2);
  } catch (err) {
    throw new import_build_utils3.NowBuildError({
      code: "UV_ERROR",
      link: "https://vercel.link/python-version",
      message: err instanceof Error ? err.message : String(err)
    });
  }
}

// src/install.ts
var LAMBDA_SIZE_THRESHOLD_BYTES = 249 * 1024 * 1024;
var makeDependencyCheckCode = (dependency) => `
from importlib import util
dep = '${dependency}'.replace('-', '_')
spec = util.find_spec(dep)
print(spec.origin)
`;
async function isInstalled2(pythonPath, dependency, cwd) {
  try {
    const { stdout } = await (0, import_execa3.default)(
      pythonPath,
      ["-c", makeDependencyCheckCode(dependency)],
      {
        stdio: "pipe",
        cwd,
        env: { ...process.env, PYTHONPATH: (0, import_path8.join)(cwd, resolveVendorDir()) }
      }
    );
    return stdout.startsWith(cwd);
  } catch (err) {
    return false;
  }
}
var makeRequirementsCheckCode = (requirementsPath) => `
import distutils.text_file
import pkg_resources
from pkg_resources import DistributionNotFound, VersionConflict
dependencies = distutils.text_file.TextFile(filename='${requirementsPath}').readlines()
pkg_resources.require(dependencies)
`;
async function areRequirementsInstalled(pythonPath, requirementsPath, cwd) {
  try {
    await (0, import_execa3.default)(
      pythonPath,
      ["-c", makeRequirementsCheckCode(requirementsPath)],
      {
        stdio: "pipe",
        cwd,
        env: { ...process.env, PYTHONPATH: (0, import_path8.join)(cwd, resolveVendorDir()) }
      }
    );
    return true;
  } catch (err) {
    return false;
  }
}
async function getSitePackagesDirs(pythonBin) {
  const code = `
import json
import sysconfig
paths = []
for key in ("purelib", "platlib"):
    candidate = sysconfig.get_path(key)
    if candidate and candidate not in paths:
        paths.append(candidate)
print(json.dumps(paths))
`.trim();
  const { stdout } = await (0, import_execa3.default)(pythonBin, ["-c", code]);
  try {
    const parsed = JSON.parse(stdout);
    if (Array.isArray(parsed)) {
      return parsed.filter((p) => typeof p === "string");
    }
  } catch (err) {
    (0, import_build_utils4.debug)("Failed to parse site-packages output", err);
  }
  return [];
}
async function getVenvSitePackagesDirs(venvPath) {
  const pythonBin = getVenvPythonBin(venvPath);
  return getSitePackagesDirs(pythonBin);
}
function resolveVendorDir() {
  const vendorDir = process.env.VERCEL_PYTHON_VENDOR_DIR || "_vendor";
  return vendorDir;
}
function toBuildError(error) {
  return new import_build_utils4.NowBuildError({
    code: error.code,
    message: error.message,
    link: error.link,
    action: error.action
  });
}
async function detectInstallSource({
  workPath,
  entryDirectory,
  repoRootPath
}) {
  const entrypointDir = (0, import_path8.join)(workPath, entryDirectory);
  const rootDir = repoRootPath ?? workPath;
  let pythonPackage;
  try {
    pythonPackage = await discoverPythonPackage({
      entrypointDir,
      rootDir
    });
  } catch (error) {
    if (error instanceof PythonAnalysisError) {
      if (error.fileContent && (error.code.endsWith("_PARSE_ERROR") || error.code.endsWith("_VALIDATION_ERROR"))) {
        console.log(
          `Failed to parse "${error.path}". File content:
${error.fileContent}`
        );
      }
      throw toBuildError(error);
    }
    throw error;
  }
  let manifestType = null;
  let manifestPath = null;
  const lockFile = pythonPackage.manifest?.lockFile ?? pythonPackage.workspaceLockFile;
  if (lockFile) {
    if (lockFile.kind === PythonLockFileKind.UvLock) {
      manifestType = "uv.lock";
      manifestPath = (0, import_path8.join)(rootDir, lockFile.path);
    } else if (lockFile.kind === PythonLockFileKind.PylockToml) {
      manifestType = "pylock.toml";
      manifestPath = (0, import_path8.join)(rootDir, lockFile.path);
    }
  } else if (pythonPackage.manifest) {
    manifestType = "pyproject.toml";
    manifestPath = (0, import_path8.join)(rootDir, pythonPackage.manifest.path);
  }
  return { manifestPath, manifestType, pythonPackage };
}
async function ensureUvProject({
  workPath,
  entryDirectory,
  repoRootPath,
  pythonVersion,
  uv,
  generateLockFile = false,
  requireBinaryWheels = false
}) {
  const rootDir = repoRootPath ?? workPath;
  const installInfo = await detectInstallSource({
    workPath,
    entryDirectory,
    repoRootPath
  });
  const { manifestType, pythonPackage } = installInfo;
  const manifest = pythonPackage?.manifest;
  let projectDir;
  let pyprojectPath;
  let lockPath = null;
  let lockFileProvidedByUser = false;
  if (manifestType === "uv.lock" || manifestType === "pylock.toml") {
    lockFileProvidedByUser = true;
    const lockFile = pythonPackage?.manifest?.lockFile ?? pythonPackage?.workspaceLockFile;
    if (!lockFile) {
      throw new Error(
        `Expected lock file path to be resolved, but it was null`
      );
    }
    lockPath = (0, import_path8.join)(rootDir, lockFile.path);
    projectDir = (0, import_path8.dirname)(lockPath);
    pyprojectPath = (0, import_path8.join)(projectDir, "pyproject.toml");
    if (!import_fs3.default.existsSync(pyprojectPath)) {
      throw new Error(
        `Expected "pyproject.toml" next to "${lockFile.kind}" in "${projectDir}"`
      );
    }
    console.log(`Installing required dependencies from ${lockFile.kind}...`);
  } else if (manifest) {
    projectDir = (0, import_path8.join)(rootDir, (0, import_path8.dirname)(manifest.path));
    pyprojectPath = (0, import_path8.join)(rootDir, manifest.path);
    const originKind = manifest.origin?.kind;
    if (originKind === PythonManifestConvertedKind.Pipfile) {
      console.log("Installing required dependencies from Pipfile...");
    } else if (originKind === PythonManifestConvertedKind.PipfileLock) {
      console.log("Installing required dependencies from Pipfile.lock...");
    } else if (originKind === PythonManifestConvertedKind.RequirementsTxt || originKind === PythonManifestConvertedKind.RequirementsIn) {
      console.log(
        `Installing required dependencies from ${manifest.origin?.path ?? "requirements.txt"}...`
      );
    } else {
      console.log("Installing required dependencies from pyproject.toml...");
    }
    if (manifest.origin) {
      if (manifest.data.project && !manifest.data.project["requires-python"]) {
        manifest.data.project["requires-python"] = `~=${pythonVersion}.0`;
      }
      const content = stringifyManifest(manifest.data);
      pyprojectPath = (0, import_path8.join)(projectDir, "pyproject.toml");
      await import_fs3.default.promises.writeFile(pyprojectPath, content);
    }
    const workspaceLockFile = pythonPackage?.workspaceLockFile;
    if (workspaceLockFile) {
      lockPath = (0, import_path8.join)(rootDir, workspaceLockFile.path);
    } else {
      await uv.lock(
        projectDir,
        requireBinaryWheels ? { noBuild: true, upgrade: true } : void 0
      );
    }
    if (generateLockFile && !lockPath) {
      await uv.lock(
        projectDir,
        requireBinaryWheels ? { noBuild: true, upgrade: true } : void 0
      );
    }
  } else {
    projectDir = workPath;
    pyprojectPath = (0, import_path8.join)(projectDir, "pyproject.toml");
    console.log(
      "No Python manifest found; creating an empty pyproject.toml and uv.lock..."
    );
    const requiresPython = `~=${pythonVersion}.0`;
    const minimalManifest = createMinimalManifest({
      name: "app",
      requiresPython,
      dependencies: []
    });
    const content = stringifyManifest(minimalManifest);
    await import_fs3.default.promises.writeFile(pyprojectPath, content);
    await uv.lock(
      projectDir,
      requireBinaryWheels ? { noBuild: true, upgrade: true } : void 0
    );
  }
  const resolvedLockPath = lockPath && import_fs3.default.existsSync(lockPath) ? lockPath : (0, import_path8.join)(projectDir, "uv.lock");
  return {
    projectDir,
    pyprojectPath,
    lockPath: resolvedLockPath,
    lockFileProvidedByUser
  };
}
async function pipInstall(pipPath, uvPath, workPath, args, targetDir) {
  const target = targetDir ? (0, import_path8.join)(targetDir, resolveVendorDir()) : resolveVendorDir();
  process.env.PIP_USER = "0";
  if (uvPath) {
    const uvArgs = [
      "pip",
      "install",
      "--no-compile",
      "--no-cache-dir",
      "--target",
      target,
      ...filterUnsafeUvPipArgs(args)
    ];
    const prettyUv = `${uvPath} ${uvArgs.join(" ")}`;
    (0, import_build_utils4.debug)(`Running "${prettyUv}"...`);
    try {
      await (0, import_execa3.default)(uvPath, uvArgs, {
        cwd: workPath,
        env: getProtectedUvEnv()
      });
      return;
    } catch (err) {
      console.log(`Failed to run "${prettyUv}", falling back to pip`);
      (0, import_build_utils4.debug)(`error: ${err}`);
    }
  }
  const cmdArgs = [
    "install",
    "--disable-pip-version-check",
    "--no-compile",
    "--no-cache-dir",
    "--target",
    target,
    ...args
  ];
  const pretty = `${pipPath} ${cmdArgs.join(" ")}`;
  (0, import_build_utils4.debug)(`Running "${pretty}"...`);
  try {
    await (0, import_execa3.default)(pipPath, cmdArgs, {
      cwd: workPath
    });
  } catch (err) {
    console.log(`Failed to run "${pretty}"`);
    (0, import_build_utils4.debug)(`error: ${err}`);
    throw err;
  }
}
async function installRequirement({
  pythonPath,
  pipPath,
  uvPath,
  dependency,
  version: version2,
  workPath,
  targetDir,
  meta,
  args = []
}) {
  const actualTargetDir = targetDir || workPath;
  if (meta.isDev && await isInstalled2(pythonPath, dependency, actualTargetDir)) {
    (0, import_build_utils4.debug)(
      `Skipping ${dependency} dependency installation, already installed in ${actualTargetDir}`
    );
    return;
  }
  const exact = `${dependency}==${version2}`;
  await pipInstall(pipPath, uvPath, workPath, [exact, ...args], targetDir);
}
async function installRequirementsFile({
  pythonPath,
  pipPath,
  uvPath,
  filePath,
  workPath,
  targetDir,
  meta,
  args = []
}) {
  const actualTargetDir = targetDir || workPath;
  if (meta.isDev && await areRequirementsInstalled(pythonPath, filePath, actualTargetDir)) {
    (0, import_build_utils4.debug)(`Skipping requirements file installation, already installed`);
    return;
  }
  await pipInstall(
    pipPath,
    uvPath,
    workPath,
    ["--upgrade", "-r", filePath, ...args],
    targetDir
  );
}
async function mirrorSitePackagesIntoVendor({
  venvPath,
  vendorDirName
}) {
  const vendorFiles = {};
  try {
    const sitePackageDirs = await getVenvSitePackagesDirs(venvPath);
    for (const dir of sitePackageDirs) {
      if (!import_fs3.default.existsSync(dir))
        continue;
      const dirFiles = await (0, import_build_utils4.glob)("**", dir);
      for (const relativePath of Object.keys(dirFiles)) {
        if (relativePath.endsWith(".pyc") || relativePath.includes("__pycache__")) {
          continue;
        }
        const srcFsPath = (0, import_path8.join)(dir, relativePath);
        const bundlePath = (0, import_path8.join)(vendorDirName, relativePath).replace(
          /\\/g,
          "/"
        );
        vendorFiles[bundlePath] = new import_build_utils4.FileFsRef({ fsPath: srcFsPath });
      }
    }
  } catch (err) {
    console.log("Failed to collect site-packages from virtual environment");
    throw err;
  }
  return vendorFiles;
}
async function calculateBundleSize(files) {
  let totalSize = 0;
  for (const filePath of Object.keys(files)) {
    const file = files[filePath];
    if ("fsPath" in file && file.fsPath) {
      try {
        const stats = await import_fs3.default.promises.stat(file.fsPath);
        totalSize += stats.size;
      } catch (err) {
        console.warn(
          `Warning: Failed to stat file ${file.fsPath}, size will not be included in bundle calculation: ${err}`
        );
      }
    } else if ("data" in file) {
      const data = file.data;
      totalSize += typeof data === "string" ? Buffer.byteLength(data) : data.length;
    }
  }
  return totalSize;
}
async function mirrorPrivatePackagesIntoVendor({
  venvPath,
  vendorDirName,
  privatePackages
}) {
  const vendorFiles = {};
  if (privatePackages.length === 0) {
    (0, import_build_utils4.debug)("No private packages to bundle");
    return vendorFiles;
  }
  const privatePackageSet = new Set(privatePackages.map(normalizePackageName));
  try {
    const sitePackageDirs = await getVenvSitePackagesDirs(venvPath);
    for (const dir of sitePackageDirs) {
      if (!import_fs3.default.existsSync(dir))
        continue;
      const entries = await import_fs3.default.promises.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.name === "__pycache__" || entry.name.endsWith(".pyc")) {
          continue;
        }
        const entryBaseName = entry.name.replace(/-[\d.]+\.dist-info$/, "").replace(/\.dist-info$/, "").replace(/-[\d.]+\.egg-info$/, "").replace(/\.egg-info$/, "");
        const normalizedEntry = normalizePackageName(entryBaseName);
        const isPrivate = privatePackageSet.has(normalizedEntry);
        if (isPrivate) {
          const entryPath = (0, import_path8.join)(dir, entry.name);
          if (entry.isDirectory()) {
            const dirFiles = await (0, import_build_utils4.glob)("**", entryPath);
            for (const relativePath of Object.keys(dirFiles)) {
              if (relativePath.endsWith(".pyc") || relativePath.includes("__pycache__")) {
                continue;
              }
              const srcFsPath = (0, import_path8.join)(entryPath, relativePath);
              const bundlePath = (0, import_path8.join)(
                vendorDirName,
                entry.name,
                relativePath
              ).replace(/\\/g, "/");
              vendorFiles[bundlePath] = new import_build_utils4.FileFsRef({ fsPath: srcFsPath });
            }
          } else {
            const bundlePath = (0, import_path8.join)(vendorDirName, entry.name).replace(
              /\\/g,
              "/"
            );
            vendorFiles[bundlePath] = new import_build_utils4.FileFsRef({ fsPath: entryPath });
          }
        }
      }
    }
    (0, import_build_utils4.debug)(
      `Bundled ${Object.keys(vendorFiles).length} files from private packages`
    );
  } catch (err) {
    console.log("Failed to collect private packages from virtual environment");
    throw err;
  }
  return vendorFiles;
}

// src/index.ts
var import_build_utils9 = require("@vercel/build-utils");

// src/start-dev-server.ts
var import_child_process2 = require("child_process");
var import_fs4 = require("fs");
var import_path10 = require("path");
var import_build_utils7 = require("@vercel/build-utils");

// src/entrypoint.ts
var import_path9 = require("path");
var import_build_utils5 = require("@vercel/build-utils");
var import_build_utils6 = require("@vercel/build-utils");
var PYTHON_ENTRYPOINT_FILENAMES = [
  "app",
  "index",
  "server",
  "main",
  "wsgi",
  "asgi"
];
var PYTHON_ENTRYPOINT_DIRS = ["", "src", "app", "api"];
var PYTHON_CANDIDATE_ENTRYPOINTS = PYTHON_ENTRYPOINT_FILENAMES.flatMap(
  (filename) => PYTHON_ENTRYPOINT_DIRS.map(
    (dir) => import_path9.posix.join(dir, `${filename}.py`)
  )
);
async function getPyprojectEntrypoint(workPath) {
  const pyprojectData = await (0, import_build_utils6.readConfigFile)((0, import_path9.join)(workPath, "pyproject.toml"));
  if (!pyprojectData)
    return null;
  const scripts = pyprojectData.project?.scripts;
  const appScript = scripts?.app;
  if (typeof appScript !== "string")
    return null;
  const match2 = appScript.match(/([A-Za-z_][\w.]*)\s*:\s*([A-Za-z_][\w]*)/);
  if (!match2)
    return null;
  const modulePath = match2[1];
  const relPath = modulePath.replace(/\./g, "/");
  try {
    const fsFiles = await (0, import_build_utils5.glob)("**", workPath);
    const candidates = [`${relPath}.py`, `${relPath}/__init__.py`];
    for (const candidate of candidates) {
      if (fsFiles[candidate])
        return candidate;
    }
    return null;
  } catch {
    (0, import_build_utils5.debug)("Failed to discover Python entrypoint from pyproject.toml");
    return null;
  }
}
async function detectGenericPythonEntrypoint(workPath, configuredEntrypoint) {
  const entry = configuredEntrypoint.endsWith(".py") ? configuredEntrypoint : `${configuredEntrypoint}.py`;
  try {
    const fsFiles = await (0, import_build_utils5.glob)("**", workPath);
    if (fsFiles[entry]) {
      const isValid2 = await (0, import_build_utils5.isPythonEntrypoint)(fsFiles[entry]);
      if (isValid2) {
        (0, import_build_utils5.debug)(`Using configured Python entrypoint: ${entry}`);
        return entry;
      }
    }
    const candidates = PYTHON_CANDIDATE_ENTRYPOINTS.filter(
      (c) => !!fsFiles[c]
    );
    for (const candidate of candidates) {
      const isValid2 = await (0, import_build_utils5.isPythonEntrypoint)(fsFiles[candidate]);
      if (isValid2) {
        (0, import_build_utils5.debug)(`Detected Python entrypoint: ${candidate}`);
        return candidate;
      }
    }
    return null;
  } catch {
    (0, import_build_utils5.debug)("Failed to discover Python entrypoint");
    return null;
  }
}
async function detectPythonEntrypoint(_framework, workPath, configuredEntrypoint) {
  const entrypoint = await detectGenericPythonEntrypoint(
    workPath,
    configuredEntrypoint
  );
  if (entrypoint)
    return entrypoint;
  return await getPyprojectEntrypoint(workPath);
}

// src/start-dev-server.ts
function silenceNodeWarnings() {
  const original = process.emitWarning.bind(
    process
  );
  let active = true;
  const wrapped = (warning, ...args) => {
    if (!active) {
      return original(
        warning,
        ...args
      );
    }
    return;
  };
  process.emitWarning = wrapped;
  return () => {
    if (!active)
      return;
    active = false;
    if (process.emitWarning === wrapped) {
      process.emitWarning = original;
    }
  };
}
var ANSI_PATTERN = "[\\u001B\\u009B][[\\]()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nq-uy=><]";
var ANSI_ESCAPE_RE = new RegExp(ANSI_PATTERN, "g");
var stripAnsi = (s) => s.replace(ANSI_ESCAPE_RE, "");
var ASGI_SHIM_MODULE = "vc_init_dev_asgi";
var WSGI_SHIM_MODULE = "vc_init_dev_wsgi";
function createLogListener(callback, stream) {
  return (buf) => {
    if (callback) {
      callback(buf);
    } else {
      const s = buf.toString();
      for (const line of s.split(/\r?\n/)) {
        if (line) {
          stream.write(line.endsWith("\n") ? line : line + "\n");
        }
      }
    }
  };
}
async function syncDependencies({
  workPath,
  uvPath,
  pythonBin,
  env,
  onStdout,
  onStderr
}) {
  const installInfo = await detectInstallSource({
    workPath,
    entryDirectory: "."
  });
  let { manifestType, manifestPath } = installInfo;
  const manifest = installInfo.pythonPackage?.manifest;
  if (!manifestType || !manifestPath) {
    (0, import_build_utils7.debug)("No Python project manifest found, skipping dependency sync");
    return;
  }
  if (manifest?.origin && manifestType === "pyproject.toml") {
    const syncDir = (0, import_path10.join)(workPath, ".vercel", "python", "sync");
    (0, import_fs4.mkdirSync)(syncDir, { recursive: true });
    const tempPyproject = (0, import_path10.join)(syncDir, "pyproject.toml");
    const content = stringifyManifest(manifest.data);
    (0, import_fs4.writeFileSync)(tempPyproject, content, "utf8");
    manifestPath = tempPyproject;
    (0, import_build_utils7.debug)(
      `Wrote converted ${manifest.origin.kind} manifest to ${tempPyproject}`
    );
  }
  const writeOut = (msg) => {
    if (onStdout) {
      onStdout(Buffer.from(msg));
    } else {
      process.stdout.write(msg);
    }
  };
  const writeErr = (msg) => {
    if (onStderr) {
      onStderr(Buffer.from(msg));
    } else {
      process.stderr.write(msg);
    }
  };
  const captured = [];
  try {
    await runSync({
      manifestType,
      manifestPath,
      uvPath,
      pythonBin,
      env,
      onStdout: (data) => captured.push(["stdout", data]),
      onStderr: (data) => captured.push(["stderr", data])
    });
  } catch (err) {
    for (const [channel, chunk] of captured) {
      (channel === "stdout" ? writeOut : writeErr)(chunk.toString());
    }
    throw new import_build_utils7.NowBuildError({
      code: "PYTHON_DEPENDENCY_SYNC_FAILED",
      message: `Failed to install Python dependencies from ${manifestType}: ${err instanceof Error ? err.message : String(err)}`
    });
  }
}
async function runSync({
  manifestType,
  manifestPath,
  uvPath,
  pythonBin,
  env,
  onStdout,
  onStderr
}) {
  const projectDir = (0, import_path10.dirname)(manifestPath);
  const pip = uvPath ? { cmd: uvPath, prefix: ["pip", "install"] } : { cmd: pythonBin, prefix: ["-m", "pip", "install"] };
  let spawnCmd;
  let spawnArgs;
  switch (manifestType) {
    case "uv.lock": {
      if (!uvPath) {
        throw new import_build_utils7.NowBuildError({
          code: "PYTHON_DEPENDENCY_SYNC_FAILED",
          message: "uv is required to install dependencies from uv.lock.",
          link: "https://docs.astral.sh/uv/getting-started/installation/",
          action: "Install uv"
        });
      }
      spawnCmd = uvPath;
      spawnArgs = ["sync"];
      break;
    }
    case "pylock.toml": {
      spawnCmd = pip.cmd;
      spawnArgs = [...pip.prefix, "-r", manifestPath];
      break;
    }
    case "pyproject.toml": {
      spawnCmd = pip.cmd;
      spawnArgs = [...pip.prefix, projectDir];
      break;
    }
    default:
      (0, import_build_utils7.debug)(`Unknown manifest type: ${manifestType}`);
      return;
  }
  await new Promise((resolve, reject) => {
    (0, import_build_utils7.debug)(`Running "${spawnCmd} ${spawnArgs.join(" ")}" in ${projectDir}...`);
    const child = (0, import_child_process2.spawn)(spawnCmd, spawnArgs, {
      cwd: projectDir,
      env: getProtectedUvEnv(env),
      stdio: ["inherit", "pipe", "pipe"]
    });
    child.stdout?.on("data", (data) => {
      if (onStdout) {
        onStdout(data);
      } else {
        process.stdout.write(data.toString());
      }
    });
    child.stderr?.on("data", (data) => {
      if (onStderr) {
        onStderr(data);
      } else {
        process.stderr.write(data.toString());
      }
    });
    child.on("error", reject);
    child.on("exit", (code, signal) => {
      if (code === 0) {
        resolve();
      } else {
        reject(
          new Error(
            `Command "${spawnCmd} ${spawnArgs.join(" ")}" failed with code ${code}, signal ${signal}`
          )
        );
      }
    });
  });
}
var PERSISTENT_SERVERS = /* @__PURE__ */ new Map();
var PENDING_STARTS = /* @__PURE__ */ new Map();
var restoreWarnings = null;
var cleanupHandlersInstalled = false;
function installGlobalCleanupHandlers() {
  if (cleanupHandlersInstalled)
    return;
  cleanupHandlersInstalled = true;
  const killAll = () => {
    for (const [key, info] of PERSISTENT_SERVERS.entries()) {
      try {
        process.kill(info.pid, "SIGTERM");
      } catch (err) {
        (0, import_build_utils7.debug)(`Error sending SIGTERM to ${info.pid}: ${err}`);
      }
      try {
        process.kill(info.pid, "SIGKILL");
      } catch (err) {
        (0, import_build_utils7.debug)(`Error sending SIGKILL to ${info.pid}: ${err}`);
      }
      PERSISTENT_SERVERS.delete(key);
    }
    if (restoreWarnings) {
      try {
        restoreWarnings();
      } catch (err) {
        (0, import_build_utils7.debug)(`Error restoring warnings: ${err}`);
      }
      restoreWarnings = null;
    }
  };
  process.on("SIGINT", () => {
    killAll();
  });
  process.on("SIGTERM", () => {
    killAll();
  });
  process.on("exit", () => {
    killAll();
  });
}
function createDevAsgiShim(workPath, modulePath) {
  try {
    const vercelPythonDir = (0, import_path10.join)(workPath, ".vercel", "python");
    (0, import_fs4.mkdirSync)(vercelPythonDir, { recursive: true });
    const shimPath = (0, import_path10.join)(vercelPythonDir, `${ASGI_SHIM_MODULE}.py`);
    const templatePath = (0, import_path10.join)(__dirname, "..", `${ASGI_SHIM_MODULE}.py`);
    const template = (0, import_fs4.readFileSync)(templatePath, "utf8");
    const shimSource = template.replace(/__VC_DEV_MODULE_PATH__/g, modulePath);
    (0, import_fs4.writeFileSync)(shimPath, shimSource, "utf8");
    (0, import_build_utils7.debug)(`Prepared Python dev static shim at ${shimPath}`);
    return ASGI_SHIM_MODULE;
  } catch (err) {
    (0, import_build_utils7.debug)(`Failed to prepare dev static shim: ${err?.message || err}`);
    return null;
  }
}
function createDevWsgiShim(workPath, modulePath) {
  try {
    const vercelPythonDir = (0, import_path10.join)(workPath, ".vercel", "python");
    (0, import_fs4.mkdirSync)(vercelPythonDir, { recursive: true });
    const shimPath = (0, import_path10.join)(vercelPythonDir, `${WSGI_SHIM_MODULE}.py`);
    const templatePath = (0, import_path10.join)(__dirname, "..", `${WSGI_SHIM_MODULE}.py`);
    const template = (0, import_fs4.readFileSync)(templatePath, "utf8");
    const shimSource = template.replace(/__VC_DEV_MODULE_PATH__/g, modulePath);
    (0, import_fs4.writeFileSync)(shimPath, shimSource, "utf8");
    (0, import_build_utils7.debug)(`Prepared Python dev WSGI shim at ${shimPath}`);
    return WSGI_SHIM_MODULE;
  } catch (err) {
    (0, import_build_utils7.debug)(`Failed to prepare dev WSGI shim: ${err?.message || err}`);
    return null;
  }
}
async function getMultiServicePythonRunner(workPath, env, systemPython, uvPath) {
  const { pythonCmd, venvRoot } = useVirtualEnv(workPath, env, systemPython);
  if (venvRoot) {
    (0, import_build_utils7.debug)(`Using existing virtualenv at ${venvRoot} for multi-service dev`);
    return { command: pythonCmd, args: [] };
  }
  const venvPath = (0, import_path10.join)(workPath, ".venv");
  await ensureVenv({ pythonPath: systemPython, venvPath, uvPath, quiet: true });
  (0, import_build_utils7.debug)(`Created virtualenv at ${venvPath} for multi-service dev`);
  const pythonBin = getVenvPythonBin(venvPath);
  const binDir = getVenvBinDir(venvPath);
  env.VIRTUAL_ENV = venvPath;
  env.PATH = `${binDir}${import_path10.delimiter}${env.PATH || ""}`;
  return { command: pythonBin, args: [] };
}
var startDevServer = async (opts) => {
  const {
    entrypoint: rawEntrypoint,
    workPath,
    meta = {},
    config,
    onStdout,
    onStderr
  } = opts;
  const framework = config?.framework;
  if (framework !== "fastapi" && framework !== "flask") {
    return null;
  }
  if (!restoreWarnings)
    restoreWarnings = silenceNodeWarnings();
  installGlobalCleanupHandlers();
  const entry = await detectPythonEntrypoint(
    framework,
    workPath,
    rawEntrypoint
  );
  if (!entry) {
    const searched = PYTHON_CANDIDATE_ENTRYPOINTS.join(", ");
    throw new import_build_utils7.NowBuildError({
      code: "PYTHON_ENTRYPOINT_NOT_FOUND",
      message: `No ${framework} entrypoint found. Add an 'app' script in pyproject.toml or define an entrypoint in one of: ${searched}.`,
      link: `https://vercel.com/docs/frameworks/backend/${framework?.toLowerCase()}#exporting-the-${framework?.toLowerCase()}-application`,
      action: "Learn More"
    });
  }
  const modulePath = entry.replace(/\.py$/i, "").replace(/[\\/]/g, ".");
  const env = { ...process.env, ...meta.env || {} };
  const serverKey = `${workPath}::${entry}::${framework}`;
  const existing = PERSISTENT_SERVERS.get(serverKey);
  if (existing) {
    return {
      port: existing.port,
      pid: existing.pid,
      shutdown: async () => {
      }
    };
  }
  {
    const pending = PENDING_STARTS.get(serverKey);
    if (pending) {
      const { port, pid } = await pending;
      return {
        port,
        pid,
        shutdown: async () => {
        }
      };
    }
  }
  let childProcess = null;
  let stdoutLogListener = null;
  let stderrLogListener = null;
  let resolveChildReady;
  let rejectChildReady;
  const childReady = new Promise(
    (resolve, reject) => {
      resolveChildReady = resolve;
      rejectChildReady = reject;
    }
  );
  PENDING_STARTS.set(serverKey, childReady);
  try {
    const { pythonPath: systemPython } = getDefaultPythonVersion(meta);
    const uvPath = await findUvBinary(systemPython);
    const venv = isInVirtualEnv();
    const serviceCount = meta.serviceCount ?? 0;
    const pythonServiceCount = meta.pythonServiceCount ?? 1;
    if (venv && pythonServiceCount > 1) {
      const yellow = "\x1B[33m";
      const white = "\x1B[1m";
      const reset = "\x1B[0m";
      throw new import_build_utils7.NowBuildError({
        code: "PYTHON_EXTERNAL_VENV_DETECTED",
        message: `Detected activated venv at ${yellow}${venv}${reset}, ${white}vercel dev${reset} manages virtual environments automatically.
Run ${white}deactivate${reset} and try again.`
      });
    }
    let spawnCommand = systemPython;
    let spawnArgsPrefix = [];
    if (serviceCount > 0) {
      const runner = await getMultiServicePythonRunner(
        workPath,
        env,
        systemPython,
        uvPath
      );
      spawnCommand = runner.command;
      spawnArgsPrefix = runner.args;
      (0, import_build_utils7.debug)(
        `Multi-service Python runner: ${spawnCommand} ${spawnArgsPrefix.join(" ")}`
      );
    } else if (venv) {
      (0, import_build_utils7.debug)(`Running in virtualenv at ${venv}`);
    } else {
      const { pythonCmd: venvPythonCmd, venvRoot } = useVirtualEnv(
        workPath,
        env,
        systemPython
      );
      spawnCommand = venvPythonCmd;
      if (venvRoot) {
        (0, import_build_utils7.debug)(`Using virtualenv at ${venvRoot}`);
      } else {
        (0, import_build_utils7.debug)("No virtualenv found");
        try {
          const yellow = "\x1B[33m";
          const reset = "\x1B[0m";
          const venvCmd = process.platform === "win32" ? "python -m venv .venv && .venv\\Scripts\\activate" : "python -m venv .venv && source .venv/bin/activate";
          process.stderr.write(
            `${yellow}Warning: no virtual environment detected in ${workPath}. Using system Python: ${systemPython}.${reset}
If you are using a virtual environment, activate it before running "vercel dev", or create one: ${venvCmd}
`
          );
        } catch (_) {
        }
      }
    }
    if (meta.syncDependencies) {
      const gray = "\x1B[90m";
      const reset = "\x1B[0m";
      const syncMessage = `${gray}Synchronizing dependencies...${reset}
`;
      if (onStdout) {
        onStdout(Buffer.from(syncMessage));
      } else {
        console.log(syncMessage);
      }
      await syncDependencies({
        workPath,
        uvPath,
        pythonBin: spawnCommand,
        env,
        onStdout,
        onStderr
      });
    }
    await new Promise((resolve, reject) => {
      let resolved = false;
      if (framework !== "flask") {
        const devShimModule = createDevAsgiShim(workPath, modulePath);
        if (devShimModule) {
          const vercelPythonDir = (0, import_path10.join)(workPath, ".vercel", "python");
          const existingPythonPath = env.PYTHONPATH || "";
          env.PYTHONPATH = existingPythonPath ? `${vercelPythonDir}:${existingPythonPath}` : vercelPythonDir;
        }
        const moduleToRun = devShimModule || modulePath;
        const pythonArgs = ["-u", "-m", moduleToRun];
        const argv = [...spawnArgsPrefix, ...pythonArgs];
        (0, import_build_utils7.debug)(
          `Starting ASGI dev server (${framework}): ${spawnCommand} ${argv.join(" ")}`
        );
        const child = (0, import_child_process2.spawn)(spawnCommand, argv, {
          cwd: workPath,
          env,
          stdio: ["inherit", "pipe", "pipe"]
        });
        childProcess = child;
        stdoutLogListener = createLogListener(onStdout, process.stdout);
        stderrLogListener = createLogListener(onStderr, process.stderr);
        child.stdout?.on("data", stdoutLogListener);
        child.stderr?.on("data", stderrLogListener);
        const readinessRegexes = [
          /Uvicorn running on https?:\/\/(?:\[[^\]]+\]|[^:]+):(\d+)/i,
          /Hypercorn running on https?:\/\/(?:\[[^\]]+\]|[^:]+):(\d+)/i,
          /(?:Running|Serving) on https?:\/\/(?:\[[^\]]+\]|[^:\s]+):(\d+)/i
        ];
        const onDetect = (chunk) => {
          const text = chunk.toString();
          const clean = stripAnsi(text);
          let portMatch = null;
          for (const rx of readinessRegexes) {
            const m = clean.match(rx);
            if (m) {
              portMatch = m;
              break;
            }
          }
          if (portMatch && child.pid) {
            if (!resolved) {
              resolved = true;
              child.stdout?.removeListener("data", onDetect);
              child.stderr?.removeListener("data", onDetect);
              const port2 = Number(portMatch[1]);
              resolveChildReady({ port: port2, pid: child.pid });
              resolve();
            }
          }
        };
        child.stdout?.on("data", onDetect);
        child.stderr?.on("data", onDetect);
        child.once("error", (err) => {
          if (!resolved) {
            rejectChildReady(err);
            reject(err);
          }
        });
        child.once("exit", (code, signal) => {
          if (!resolved) {
            const err = new Error(
              `ASGI dev server exited before binding (code=${code}, signal=${signal})`
            );
            rejectChildReady(err);
            reject(err);
          }
        });
      } else {
        const devShimModule = createDevWsgiShim(workPath, modulePath);
        if (devShimModule) {
          const vercelPythonDir = (0, import_path10.join)(workPath, ".vercel", "python");
          const existingPythonPath = env.PYTHONPATH || "";
          env.PYTHONPATH = existingPythonPath ? `${vercelPythonDir}:${existingPythonPath}` : vercelPythonDir;
        }
        const moduleToRun = devShimModule || modulePath;
        const pythonArgs = ["-u", "-m", moduleToRun];
        const argv = [...spawnArgsPrefix, ...pythonArgs];
        (0, import_build_utils7.debug)(`Starting Flask dev server: ${spawnCommand} ${argv.join(" ")}`);
        const child = (0, import_child_process2.spawn)(spawnCommand, argv, {
          cwd: workPath,
          env,
          stdio: ["inherit", "pipe", "pipe"]
        });
        childProcess = child;
        stdoutLogListener = createLogListener(onStdout, process.stdout);
        stderrLogListener = createLogListener(onStderr, process.stderr);
        child.stdout?.on("data", stdoutLogListener);
        child.stderr?.on("data", stderrLogListener);
        const readinessRegexes = [
          /Werkzeug running on https?:\/\/(?:\[[^\]]+\]|[^:]+):(\d+)/i,
          /(?:Running|Serving) on https?:\/\/(?:\[[^\]]+\]|[^:\s]+):(\d+)/i
        ];
        const onDetect = (chunk) => {
          const text = chunk.toString();
          const clean = stripAnsi(text);
          let portMatch = null;
          for (const rx of readinessRegexes) {
            const m = clean.match(rx);
            if (m) {
              portMatch = m;
              break;
            }
          }
          if (portMatch && child.pid) {
            if (!resolved) {
              resolved = true;
              child.stdout?.removeListener("data", onDetect);
              child.stderr?.removeListener("data", onDetect);
              const port2 = Number(portMatch[1]);
              resolveChildReady({ port: port2, pid: child.pid });
              resolve();
            }
          }
        };
        child.stdout?.on("data", onDetect);
        child.stderr?.on("data", onDetect);
        child.once("error", (err) => {
          if (!resolved) {
            rejectChildReady(err);
            reject(err);
          }
        });
        child.once("exit", (code, signal) => {
          if (!resolved) {
            const err = new Error(
              `Flask dev server exited before binding (code=${code}, signal=${signal})`
            );
            rejectChildReady(err);
            reject(err);
          }
        });
      }
    });
    const { port, pid } = await childReady;
    PERSISTENT_SERVERS.set(serverKey, {
      port,
      pid,
      child: childProcess,
      stdoutLogListener,
      stderrLogListener
    });
    const shutdown = async () => {
    };
    return { port, pid, shutdown };
  } finally {
    PENDING_STARTS.delete(serverKey);
  }
};

// src/index.ts
var readFile = (0, import_util6.promisify)(import_fs5.default.readFile);
var writeFile = (0, import_util6.promisify)(import_fs5.default.writeFile);
var version = 3;
async function downloadFilesInWorkPath({
  entrypoint,
  workPath,
  files,
  meta = {}
}) {
  (0, import_build_utils8.debug)("Downloading user files...");
  let downloadedFiles = await (0, import_build_utils8.download)(files, workPath, meta);
  if (meta.isDev) {
    const { devCacheDir = (0, import_path11.join)(workPath, ".now", "cache") } = meta;
    const destCache = (0, import_path11.join)(devCacheDir, (0, import_path11.basename)(entrypoint, ".py"));
    await (0, import_build_utils8.download)(downloadedFiles, destCache);
    downloadedFiles = await (0, import_build_utils8.glob)("**", destCache);
    workPath = destCache;
  }
  return workPath;
}
var build = async ({
  workPath,
  repoRootPath,
  files: originalFiles,
  entrypoint,
  meta = {},
  config
}) => {
  const framework = config?.framework;
  let spawnEnv;
  let projectInstallCommand;
  (0, import_build_utils8.debug)(`workPath: ${workPath}`);
  workPath = await downloadFilesInWorkPath({
    workPath,
    files: originalFiles,
    entrypoint,
    meta
  });
  try {
    if (meta.isDev) {
      const setupCfg = (0, import_path11.join)(workPath, "setup.cfg");
      await writeFile(setupCfg, "[install]\nprefix=\n");
    }
  } catch (err) {
    console.log('Failed to create "setup.cfg" file');
    throw err;
  }
  if ((0, import_build_utils8.isPythonFramework)(framework)) {
    const {
      cliType,
      lockfileVersion,
      packageJsonPackageManager,
      turboSupportsCorepackHome
    } = await (0, import_build_utils8.scanParentDirs)(workPath, true);
    spawnEnv = (0, import_build_utils8.getEnvForPackageManager)({
      cliType,
      lockfileVersion,
      packageJsonPackageManager,
      env: process.env,
      turboSupportsCorepackHome,
      projectCreatedAt: config?.projectSettings?.createdAt
    });
    const installCommand = config?.projectSettings?.installCommand;
    if (typeof installCommand === "string") {
      const trimmed = installCommand.trim();
      if (trimmed) {
        projectInstallCommand = trimmed;
      } else {
        console.log('Skipping "install" command...');
      }
    }
    const projectBuildCommand = config?.projectSettings?.buildCommand ?? // fallback if provided directly on config (some callers set this)
    config?.buildCommand;
    if (projectBuildCommand) {
      console.log(`Running "${projectBuildCommand}"`);
      await (0, import_build_utils8.execCommand)(projectBuildCommand, {
        env: spawnEnv,
        cwd: workPath
      });
    } else {
      await runPyprojectScript(
        workPath,
        ["vercel-build", "now-build", "build"],
        spawnEnv
      );
    }
  }
  let fsFiles = await (0, import_build_utils8.glob)("**", workPath);
  if ((0, import_build_utils8.isPythonFramework)(framework) && (!fsFiles[entrypoint] || !entrypoint.endsWith(".py"))) {
    const detected = await detectPythonEntrypoint(
      config.framework,
      workPath,
      entrypoint
    );
    if (detected) {
      (0, import_build_utils8.debug)(
        `Resolved Python entrypoint to "${detected}" (configured "${entrypoint}" not found).`
      );
      entrypoint = detected;
    } else {
      const searchedList = PYTHON_CANDIDATE_ENTRYPOINTS.join(", ");
      throw new import_build_utils8.NowBuildError({
        code: `${framework.toUpperCase()}_ENTRYPOINT_NOT_FOUND`,
        message: `No ${framework} entrypoint found. Add an 'app' script in pyproject.toml or define an entrypoint in one of: ${searchedList}.`,
        link: `https://vercel.com/docs/frameworks/backend/${framework}#exporting-the-${framework}-application`,
        action: "Learn More"
      });
    }
  }
  const entryDirectory = (0, import_path11.dirname)(entrypoint);
  const pyprojectDir = findDir({
    file: "pyproject.toml",
    entryDirectory,
    workPath,
    fsFiles
  });
  const pipfileLockDir = findDir({
    file: "Pipfile.lock",
    entryDirectory,
    workPath,
    fsFiles
  });
  const pythonVersionFileDir = findDir({
    file: ".python-version",
    entryDirectory,
    workPath,
    fsFiles
  });
  let declaredPythonVersion;
  if (pythonVersionFileDir) {
    try {
      const content = await readFile(
        (0, import_path11.join)(pythonVersionFileDir, ".python-version"),
        "utf8"
      );
      const version2 = parsePythonVersionFile2(content);
      if (version2) {
        declaredPythonVersion = { version: version2, source: ".python-version" };
        (0, import_build_utils8.debug)(`Found Python version ${version2} in .python-version`);
      }
    } catch (err) {
      (0, import_build_utils8.debug)("Failed to read .python-version file", err);
    }
  }
  if (!declaredPythonVersion && pyprojectDir) {
    let requiresPython;
    try {
      const pyproject = await (0, import_build_utils9.readConfigFile)((0, import_path11.join)(pyprojectDir, "pyproject.toml"));
      requiresPython = pyproject?.project?.["requires-python"];
    } catch (err) {
      (0, import_build_utils8.debug)("Failed to parse pyproject.toml", err);
    }
    if (typeof requiresPython === "string" && requiresPython.trim()) {
      declaredPythonVersion = {
        version: requiresPython.trim(),
        source: "pyproject.toml"
      };
      (0, import_build_utils8.debug)(`Found requires-python "${requiresPython}" in pyproject.toml`);
    }
  }
  if (!declaredPythonVersion && pipfileLockDir) {
    let lock = {};
    const pipfileLockPath = (0, import_path11.join)(pipfileLockDir, "Pipfile.lock");
    try {
      const pipfileLockContent = await readFile(pipfileLockPath, "utf8");
      try {
        lock = JSON.parse(pipfileLockContent);
      } catch (err) {
        console.log(
          `Failed to parse "Pipfile.lock". File content:
${pipfileLockContent}`
        );
        throw err;
      }
    } catch (err) {
      throw new import_build_utils8.NowBuildError({
        code: "INVALID_PIPFILE_LOCK",
        message: "Unable to parse Pipfile.lock"
      });
    }
    const pyFromLock = lock?._meta?.requires?.python_version;
    if (pyFromLock) {
      declaredPythonVersion = { version: pyFromLock, source: "Pipfile.lock" };
      (0, import_build_utils8.debug)(`Found Python version ${pyFromLock} in Pipfile.lock`);
    }
  }
  const pythonVersion = getSupportedPythonVersion({
    isDev: meta.isDev,
    declaredPythonVersion
  });
  const selectedVersionTuple = parseVersionTuple(pythonVersion.version);
  const defaultVersionTuple = parseVersionTuple(DEFAULT_PYTHON_VERSION);
  if (!pythonVersionFileDir && pyprojectDir && declaredPythonVersion?.source === "pyproject.toml" && selectedVersionTuple && defaultVersionTuple && compareTuples(selectedVersionTuple, defaultVersionTuple) <= 0) {
    const pythonVersionFilePath = (0, import_path11.join)(pyprojectDir, ".python-version");
    await writeFile(pythonVersionFilePath, `${pythonVersion.version}
`);
    console.log(
      `Writing .python-version file with version ${pythonVersion.version}`
    );
  }
  fsFiles = await (0, import_build_utils8.glob)("**", workPath);
  const venvPath = (0, import_path11.join)(workPath, ".vercel", "python", ".venv");
  await ensureVenv({
    pythonPath: pythonVersion.pythonPath,
    venvPath
  });
  const baseEnv = spawnEnv || process.env;
  const pythonEnv = createVenvEnv(venvPath, baseEnv);
  pythonEnv.VERCEL_PYTHON_VENV_PATH = venvPath;
  let assumeDepsInstalled = false;
  if (projectInstallCommand) {
    console.log(`Running "install" command: \`${projectInstallCommand}\`...`);
    await (0, import_build_utils8.execCommand)(projectInstallCommand, {
      env: pythonEnv,
      cwd: workPath
    });
    assumeDepsInstalled = true;
  } else {
    assumeDepsInstalled = await runPyprojectScript(
      workPath,
      ["vercel-install", "now-install", "install"],
      pythonEnv,
      /* useUserVirtualEnv */
      false
    );
  }
  let uv;
  try {
    const uvPath = await getUvBinaryOrInstall(pythonVersion.pythonPath);
    console.log(`Using uv at "${uvPath}"`);
    uv = new UvRunner(uvPath);
  } catch (err) {
    console.log("Failed to install or locate uv");
    throw new Error(
      `uv is required for this project but failed to install: ${err instanceof Error ? err.message : String(err)}`
    );
  }
  const runtimeInstallFeatureEnabled = process.env.VERCEL_EXPERIMENTAL_PYTHON_UV_INSTALL_ON_STARTUP === "1" || process.env.VERCEL_EXPERIMENTAL_PYTHON_UV_INSTALL_ON_STARTUP === "true";
  let uvLockPath = null;
  let uvProjectDir = null;
  let projectName;
  let noBuildCheckFailed = false;
  if (!assumeDepsInstalled) {
    const { projectDir, lockPath, lockFileProvidedByUser } = await ensureUvProject({
      workPath,
      entryDirectory,
      repoRootPath,
      pythonVersion: pythonVersion.version,
      uv,
      generateLockFile: runtimeInstallFeatureEnabled,
      requireBinaryWheels: runtimeInstallFeatureEnabled
    });
    uvLockPath = lockPath;
    uvProjectDir = projectDir;
    const installInfo = await detectInstallSource({
      workPath,
      entryDirectory,
      repoRootPath
    });
    projectName = installInfo.pythonPackage?.manifest?.data?.project?.name;
    if (lockFileProvidedByUser && runtimeInstallFeatureEnabled) {
      try {
        await uv.sync({
          venvPath,
          projectDir,
          frozen: true,
          noBuild: true
        });
      } catch (err) {
        noBuildCheckFailed = true;
        (0, import_build_utils8.debug)(
          `--no-build check failed: ${err instanceof Error ? err.message : String(err)}`
        );
      }
    }
    await uv.sync({
      venvPath,
      projectDir,
      frozen: lockFileProvidedByUser,
      locked: !lockFileProvidedByUser
    });
  }
  const runtimeDep = baseEnv.VERCEL_RUNTIME_PYTHON || `vercel-runtime==${VERCEL_RUNTIME_VERSION}`;
  (0, import_build_utils8.debug)(`Installing ${runtimeDep}`);
  await uv.pip({
    venvPath,
    projectDir: (0, import_path11.join)(workPath, entryDirectory),
    args: ["install", runtimeDep]
  });
  (0, import_build_utils8.debug)("Entrypoint is", entrypoint);
  const moduleName = entrypoint.replace(/\//g, ".").replace(/\.py$/i, "");
  const vendorDir = resolveVendorDir();
  const suffix = meta.isDev && !entrypoint.endsWith(".py") ? ".py" : "";
  const entrypointWithSuffix = `${entrypoint}${suffix}`;
  (0, import_build_utils8.debug)("Entrypoint with suffix is", entrypointWithSuffix);
  const runtimeTrampoline = `
import importlib
import os
import os.path
import site
import sys

_here = os.path.dirname(__file__)

os.environ.update({
  "__VC_HANDLER_MODULE_NAME": "${moduleName}",
  "__VC_HANDLER_ENTRYPOINT": "${entrypointWithSuffix}",
  "__VC_HANDLER_ENTRYPOINT_ABS": os.path.join(_here, "${entrypointWithSuffix}"),
  "__VC_HANDLER_VENDOR_DIR": "${vendorDir}",
})

_vendor_rel = '${vendorDir}'
_vendor = os.path.normpath(os.path.join(_here, _vendor_rel))

if os.path.isdir(_vendor):
    # Process .pth files like a real site-packages dir
    site.addsitedir(_vendor)

    # Move _vendor to the front (after script dir if present)
    try:
        while _vendor in sys.path:
            sys.path.remove(_vendor)
    except ValueError:
        pass

    # Put vendored deps ahead of site-packages but after the script dir
    idx = 1 if (sys.path and sys.path[0] in ('', _here)) else 0
    sys.path.insert(idx, _vendor)

    importlib.invalidate_caches()

from vercel_runtime.vc_init import vc_handler
`;
  const predefinedExcludes = [
    ".git/**",
    ".gitignore",
    ".vercel/**",
    ".pnpm-store/**",
    "**/node_modules/**",
    "**/.next/**",
    "**/.nuxt/**",
    "**/.venv/**",
    "**/venv/**",
    "**/__pycache__/**",
    "**/.mypy_cache/**",
    "**/.ruff_cache/**",
    "**/public/**",
    "**/pnpm-lock.yaml",
    "**/yarn.lock",
    "**/package-lock.json"
  ];
  const lambdaEnv = {};
  lambdaEnv.PYTHONPATH = vendorDir;
  const globOptions = {
    cwd: workPath,
    ignore: config && typeof config.excludeFiles === "string" ? [...predefinedExcludes, config.excludeFiles] : predefinedExcludes
  };
  const files = await (0, import_build_utils8.glob)("**", globOptions);
  const allVendorFiles = await mirrorSitePackagesIntoVendor({
    venvPath,
    vendorDirName: vendorDir
  });
  const tempFilesForSizing = { ...files };
  for (const [p, f] of Object.entries(allVendorFiles)) {
    tempFilesForSizing[p] = f;
  }
  const totalBundleSize = await calculateBundleSize(tempFilesForSizing);
  const totalBundleSizeMB = (totalBundleSize / (1024 * 1024)).toFixed(2);
  (0, import_build_utils8.debug)(`Total bundle size: ${totalBundleSizeMB} MB`);
  const runtimeInstallEnabled = runtimeInstallFeatureEnabled && totalBundleSize > LAMBDA_SIZE_THRESHOLD_BYTES && uvLockPath !== null;
  if (runtimeInstallEnabled && uvLockPath && uvProjectDir) {
    console.log(
      `Bundle size (${totalBundleSizeMB} MB) exceeds limit. Enabling runtime dependency installation.`
    );
    if (noBuildCheckFailed) {
      throw new import_build_utils8.NowBuildError({
        code: "RUNTIME_DEPENDENCY_INSTALLATION_FAILED",
        message: `Bundle size exceeds the Lambda limit and requires runtime dependency installation, but some packages in your uv.lock file do not have pre-built binary wheels available.
Runtime dependency installation requires all public packages to have binary wheels.

To fix this, either:
 1. Regenerate your lock file with: uv lock --upgrade --no-build, or
 2. Switch the problematic packages to ones that have pre-built wheels available`
      });
    }
    let lockContent;
    try {
      lockContent = await readFile(uvLockPath, "utf8");
    } catch (error) {
      if (error instanceof Error) {
        console.log(
          `Failed to read uv.lock file at "${uvLockPath}": ${error.message}`
        );
      } else {
        console.log(
          `Failed to read uv.lock file at "${uvLockPath}": ${String(error)}`
        );
      }
      throw new import_build_utils8.NowBuildError({
        code: "RUNTIME_DEPENDENCY_INSTALLATION_FAILED",
        message: `Failed to read uv.lock file at "${uvLockPath}"`
      });
    }
    let lockFile;
    try {
      lockFile = parseUvLock(lockContent, uvLockPath);
    } catch (error) {
      if (error instanceof PythonAnalysisError) {
        if (error.fileContent) {
          console.log(
            `Failed to parse "${error.path}". File content:
${error.fileContent}`
          );
        }
        throw new import_build_utils8.NowBuildError({
          code: error.code,
          message: error.message
        });
      }
      throw error;
    }
    const excludePackages = [];
    if (projectName) {
      excludePackages.push(projectName);
      (0, import_build_utils8.debug)(
        `Excluding project package "${projectName}" from runtime installation`
      );
    }
    const classification = classifyPackages({
      lockFile,
      excludePackages
    });
    (0, import_build_utils8.debug)(
      `Package classification: ${classification.privatePackages.length} private, ${classification.publicPackages.length} public`
    );
    if (classification.publicPackages.length > 0) {
      const privatePackagesWithRuntime = [
        ...classification.privatePackages,
        "vercel-runtime",
        "vercel_runtime"
      ];
      const privateVendorFiles = await mirrorPrivatePackagesIntoVendor({
        venvPath,
        vendorDirName: vendorDir,
        privatePackages: privatePackagesWithRuntime
      });
      for (const [p, f] of Object.entries(privateVendorFiles)) {
        files[p] = f;
      }
      const runtimeRequirementsContent = generateRuntimeRequirements(classification);
      const runtimeRequirementsPath = `${UV_BUNDLE_DIR}/_runtime_requirements.txt`;
      files[runtimeRequirementsPath] = new import_build_utils8.FileBlob({
        data: runtimeRequirementsContent
      });
      if (process.env.VERCEL_BUILD_IMAGE) {
        try {
          const uvBinaryPath = await getUvBinaryForBundling(
            pythonVersion.pythonPath
          );
          const uvBundleDir = (0, import_path11.join)(workPath, UV_BUNDLE_DIR);
          const uvLocalPath = (0, import_path11.join)(uvBundleDir, "uv");
          await import_fs5.default.promises.mkdir(uvBundleDir, { recursive: true });
          await import_fs5.default.promises.copyFile(uvBinaryPath, uvLocalPath);
          await import_fs5.default.promises.chmod(uvLocalPath, 493);
          const uvBundlePath = `${UV_BUNDLE_DIR}/uv`;
          files[uvBundlePath] = new import_build_utils8.FileFsRef({
            fsPath: uvLocalPath,
            mode: 33261
            // Regular file + executable
          });
          (0, import_build_utils8.debug)(`Bundled uv binary from ${uvBinaryPath} to ${uvLocalPath}`);
        } catch (err) {
          throw new import_build_utils8.NowBuildError({
            code: "RUNTIME_DEPENDENCY_INSTALLATION_FAILED",
            message: `Failed to bundle uv binary for runtime installation: ${err instanceof Error ? err.message : String(err)}`
          });
        }
      }
    } else {
      throw new import_build_utils8.NowBuildError({
        code: "RUNTIME_DEPENDENCY_INSTALLATION_FAILED",
        message: "Bundle size exceeds limit but no public packages found for runtime installation."
      });
    }
  } else {
    for (const [p, f] of Object.entries(allVendorFiles)) {
      files[p] = f;
    }
  }
  const handlerPyFilename = "vc__handler__python";
  files[`${handlerPyFilename}.py`] = new import_build_utils8.FileBlob({ data: runtimeTrampoline });
  if (config.framework === "fasthtml") {
    const { SESSKEY = "" } = process.env;
    files[".sesskey"] = new import_build_utils8.FileBlob({ data: `"${SESSKEY}"` });
  }
  if (runtimeInstallEnabled) {
    const finalBundleSize = await calculateBundleSize(files);
    if (finalBundleSize > LAMBDA_SIZE_THRESHOLD_BYTES) {
      const finalSizeMB = (finalBundleSize / (1024 * 1024)).toFixed(2);
      const limitMB = (LAMBDA_SIZE_THRESHOLD_BYTES / (1024 * 1024)).toFixed(0);
      throw new import_build_utils8.NowBuildError({
        code: "LAMBDA_SIZE_EXCEEDED",
        message: `Bundle size (${finalSizeMB} MB) exceeds Lambda limit (${limitMB} MB) even after deferring public packages to runtime installation. This usually means your private packages or source code are too large. Consider reducing the size of private dependencies or splitting your application.`
      });
    }
  }
  const output = new import_build_utils8.Lambda({
    files,
    handler: `${handlerPyFilename}.vc_handler`,
    runtime: pythonVersion.runtime,
    environment: lambdaEnv,
    supportsResponseStreaming: true
  });
  return { output };
};
var shouldServe = (opts) => {
  const framework = opts.config.framework;
  if (framework === "fastapi") {
    const requestPath = opts.requestPath.replace(/\/$/, "");
    if (requestPath.startsWith("api") && opts.hasMatched) {
      return false;
    }
    return true;
  } else if (framework === "flask") {
    const requestPath = opts.requestPath.replace(/\/$/, "");
    if (requestPath.startsWith("api") && opts.hasMatched) {
      return false;
    }
    return true;
  }
  return defaultShouldServe(opts);
};
var defaultShouldServe = ({
  entrypoint,
  files,
  requestPath
}) => {
  requestPath = requestPath.replace(/\/$/, "");
  entrypoint = entrypoint.replace(/\\/g, "/");
  if (entrypoint === requestPath && hasProp(files, entrypoint)) {
    return true;
  }
  const { dir, name } = (0, import_path11.parse)(entrypoint);
  if (name === "index" && dir === requestPath && hasProp(files, entrypoint)) {
    return true;
  }
  return false;
};
function hasProp(obj, key) {
  return Object.hasOwnProperty.call(obj, key);
}
function parsePythonVersionFile2(content) {
  const lines = content.split("\n");
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#"))
      continue;
    return trimmed;
  }
  return void 0;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  build,
  defaultShouldServe,
  downloadFilesInWorkPath,
  installRequirement,
  installRequirementsFile,
  shouldServe,
  startDevServer,
  version
});
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT *)

smol-toml/dist/error.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/util.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/date.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/primitive.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/extract.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/struct.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/parse.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/stringify.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

smol-toml/dist/index.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)
*/
